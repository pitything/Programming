## 设计模式七大原则

### 设计模式的目的

> 编写软件过程中，程序员面临着来自耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性等多方面的挑战，设计模式是为了让程序拥有如下几个性质：
>
>  1 ) 代码重用性 (即：相同功能的代码，不用多次编写)
>  2 ) 可读性 (即：编程规范性, 便于其他程序员的阅读和理解)
>  3 ) 可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)
>  4 ) 可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)
>  5 ) 使程序呈现高内聚，低耦合的特性

### 设计模式七大原则

> - 设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础(即：设计模式为什么这样设计的依据)
> - 设计模式常用的**七大原则**有:
>
>  1 ) 单一职责原则
>  2 ) 接口隔离原则
>  3 ) 依赖倒转(倒置)原则
>  4 ) 里氏替换原则
>  5 ) 开闭原则
>  6 ) 迪米特法则
>  7 ) 合成复用原则

### 单一职责原则

#### 基本介绍

> 对类来说的，即一个类应该只负责一项职责。如类A负责两个不同职责：职责 1 ，职责 2 。当职责 1 需求变更而改变A时，可能造成职责 2 执行错误，所以需要将类A的粒度分解为A 1 ，A 2

#### 应用实例

 以交通工具案例讲解

 看老师代码演示

 1 ) 方案 1 [分析说明]
```java
package BasicKnowledge.设计模式._7大原则;

public class 单一职责原则 {
    public static void main(String[] args) {
        Vehicle vehicle = new Vehicle();
        vehicle.run("摩托车");
        vehicle.run("汽车");
        vehicle.run("飞机");

        RoadVehicle roadVehicle = new RoadVehicle();
        roadVehicle.run("摩托车");
        roadVehicle.run("汽车");
        AirVehicle airVehicle = new AirVehicle();
        airVehicle.run("飞机");

        Vehicle2 vehicle2 = new Vehicle2();
        vehicle2.run("汽车");
        vehicle2.runAir("飞机");
    }
}

// 方式 1
// 1. 在方式 1 的run方法中，违反了单一职责原则
// 2. 解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可
class Vehicle {
    public void run(String vehicle) {
        System.out.println(vehicle + " 在公路上运行");
    }
}

// 方式 2
// 1. 遵守单一职责原则
// 2. 但是这样做的改动很大，即将类分解，同时修改客户端
// 3. 改进：直接修改Vehicle 类，改动的代码会比较少=>方案 3
class RoadVehicle {
    public void run(String vehicle) {
        System.out.println(vehicle + "公路运行");
    }
}

class AirVehicle {
    public void run(String vehicle) {
        System.out.println(vehicle + "天空运行");
    }
}

// 方式 3
// 1. 这种修改方法没有对原来的类做大的修改，只是增加方法
// 2. 这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责
class Vehicle2 {
    public void run(String vehicle) {
        System.out.println(vehicle + " 在公路上运行");
    }

    public void runAir(String vehicle) {
        System.out.println(vehicle + " 在天空上运行");
    }
}
```
#### 单一职责原则注意事项和细节

>  1 ) 降低类的复杂度，一个类只负责一项职责。
>  2 ) 提高类的可读性，可维护性
>  3 ) 降低变更引起的风险
>  4 ) 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则

### 接口隔离原则

#### 基本介绍

>  1 ) 客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上
>  2 ) 先看一张图:
>
>  <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220802165204910.png" alt="image-20220802165204910" style="zoom:50%;" />
>
>  3 ) 类A通过接口 Interface1 依赖类B，类C通过接口 Interface1 依赖类D，如果接口 Interface1 对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不需要的方法。
>  4 ) 按隔离原则应当这样处理：将接口 **Interface1** 拆分为独立的几个接口 **(** 这里我们拆分成 **3** 个接口 **)** ，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则
>
>  <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220802172611336.png" alt="image-20220802172611336" style="zoom:50%;" />

#### 应用实例

```java
package BasicKnowledge.设计模式._7大原则;

public class 接口隔离原则 {
    public static void main(String[] args) {
        A a = new A();
        a.depend1(new B());
        a.depend2(new B());
        a.depend3(new B());
        C c = new C();
        c.depend1(new D());
        c.depend4(new D());
        c.depend5(new D());

        AA aa = new AA();
        aa.depend1(new BB());
        aa.depend2(new BB());
        aa.depend3(new BB());
        CC cc = new CC();
        cc.depend1(new DD());
        cc.depend4(new DD());
        cc.depend5(new DD());
    }
}

// 方式1：没有使用接口隔离原则代码
interface Interface1 {
    void operation1();
    void operation2();
    void operation3();
    void operation4();
    void operation5();
}

class B implements Interface1 {
    public void operation1() {
        System.out.println("B 实现了 operation1 ");
    }
    public void operation2() {
        System.out.println("B 实现了 operation2 ");
    }
    public void operation3() {
        System.out.println("B 实现了 operation3 ");
    }
    public void operation4() {
        System.out.println("B 实现了 operation4 ");
    }
    public void operation5() {
        System.out.println("B 实现了 operation5 ");
    }
}

class D implements Interface1 {
    public void operation1() {
        System.out.println("D 实现了 operation1 ");
    }
    public void operation2() {
        System.out.println("D 实现了 operation2 ");
    }
    public void operation3() {
        System.out.println("D 实现了 operation3 ");
    }
    public void operation4() {
        System.out.println("D 实现了 operation4 ");
    }
    public void operation5() {
        System.out.println("D 实现了 operation5 ");
    }
}

class A {//A类通过接口Interface1 依赖(使用)B类，但是只会用到 1 , 2 , 3 方法
    public void depend1(Interface1 i) {
        i.operation1();
    }
    public void depend2(Interface1 i) {
        i.operation2();
    }
    public void depend3(Interface1 i) {
        i.operation3();
    }
}

class C {//C 类通过接口Interface1 依赖(使用)D类，但是只会用到 1 , 4 , 5 方法
    public void depend1(Interface1 i) {
        i.operation1();
    }
    public void depend4(Interface1 i) {
        i.operation4();
    }
    public void depend5(Interface1 i) {
        i.operation5();
    }
}

// 方式2：使用接口隔离原则改进
// 接口 1
interface Interface11 {
    void operation1();
}
// 接口 2
interface Interface22 {
    void operation2();
    void operation3();
}

// 接口 3
interface Interface33 {
    void operation4();
    void operation5();
}

class BB implements Interface11, Interface22 {
    public void operation1() {
        System.out.println("B 实现了 operation1 ");
    }
    public void operation2() {
        System.out.println("B 实现了 operation2 ");
    }
    public void operation3() {
        System.out.println("B 实现了 operation3 ");
    }
}

class DD implements Interface11, Interface33 {
    public void operation1() {
        System.out.println("D 实现了 operation1 ");
    }
    public void operation4() {
        System.out.println("D 实现了 operation4 ");
    }
    public void operation5() {
        System.out.println("D 实现了 operation5 ");
    }
}

class AA {//A类通过接口Interface1 ,Interface2 依赖(使用)B类，但是只会用到 1 , 2 , 3 方法
    public void depend1(Interface11 i) {
        i.operation1();
    }
    public void depend2(Interface22 i) {
        i.operation2();
    }
    public void depend3(Interface22 i) {
        i.operation3();
    }
}

class CC {//C 类通过接口Interface1 ,Interface3 依赖(使用)D类，但是只会用到 1 , 4 , 5 方法
    public void depend1(Interface11 i) {
        i.operation1();
    }
    public void depend4(Interface33 i) {
        i.operation4();
    }
    public void depend5(Interface33 i) {
        i.operation5();
    }
}
```


### 依赖倒转原则

#### 基本介绍

> 依赖倒转原则(Dependence Inversion Principle)是指：
> 1 ) 高层模块不应该依赖低层模块，二者都应该依赖其抽象
> 2 ) 抽象不应该依赖细节，细节应该依赖抽象
> 3 ) 依赖倒转(倒置)的中心思想是**面向接口编程**
> 4 ) 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类
> 5 ) 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成

#### 应用实例

```java
package BasicKnowledge.设计模式._7大原则;


public class 依赖倒转原则 {
    public static void main(String[] args) {
        Person person = new Person();
        person.receive(new Email());

        // 客户端无需改变
        Person2 person2=new Person2();
        person2.receive(new Email2());
        person2.receive(new WeiXin());
    }
}

// 方式 1
class Email {
    public String getInfo() {
        return "电子邮件信息:hello,world";
    }
}

class Person {
    public void receive(Email email) {
        System.out.println(email.getInfo());
    }
}

// 方式 2
// 1. 如果我们获取的对象是 微信，短信等等，则新增类，同时Perons也要增加相应的接收方法
// 2. 解决思路：引入一个抽象的接口IReceiver, 表示接收者, 这样Person类与接口IReceiver发生依赖
// 因为Email,WeiXin 等等属于接收的范围，他们各自实现IReceiver 接口就ok, 这样我们就符号依赖倒转原则
interface IReceiver {
    public String getInfo();
}

class Email2 implements IReceiver {
    public String getInfo() {
        return "电子邮件信息:hello,world";
    }
}

// 增加微信
class WeiXin implements IReceiver {
    public String getInfo() {
        return "微信信息:hello,ok";
    }
}

class Person2 {
    // 这里我们是对接口的依赖
    public void receive(IReceiver receiver) {
        System.out.println(receiver.getInfo());
    }
}
```

#### 依赖关系传递的三种方式

> 1 ) 接口传递
> 2 ) 构造方法传递
> 3 ) setter方式传递

##### 代码实现

```java
package BasicKnowledge.设计模式._7大原则;

public class _3_依赖倒转原则2 {
    public static void main(String[] args) {
        ITV changHong = new ChangHong();

        // 通过接口传递实现依赖
        OpenAndClose1 openAndClose1 = new OpenAndClose1();
        openAndClose1.open(changHong);

        // 通过构造器进行依赖传递
        OpenAndClose2 openAndClose2 = new OpenAndClose2(changHong);
        openAndClose2.open();

        // 通过setter方法进行依赖传递
        OpenAndClose3 openAndClose3 = new OpenAndClose3();
        openAndClose3.setTv(changHong);
        openAndClose3.open();
    }
}

//ITV接口
interface ITV {
    void play();
}

class ChangHong implements ITV {
    @Override
    public void play() {
        System.out.println("长虹电视机，打开");
    }
}

// 方式 1 ： 通过接口传递实现依赖
// 开关的接口
interface IOpenAndClose1 {
    void open(ITV tv);//抽象方法,接收接口
}

class OpenAndClose1 implements IOpenAndClose1 {
    public void open(ITV tv) {
        tv.play();
    }
}

// 方式 2 : 通过构造方法依赖传递
interface IOpenAndClose2 {
    void open();//抽象方法
}

class OpenAndClose2 implements IOpenAndClose2 {
    public ITV tv;//成员
    public OpenAndClose2(ITV tv) {//构造器
        this.tv = tv;
    }
    public void open() {
        this.tv.play();
    }
}

// 方式 3 : 通过setter方法传递
interface IOpenAndClose3 {
    void open();// 抽象方法
    void setTv(ITV tv);
}

class OpenAndClose3 implements IOpenAndClose3 {
    private ITV tv;
    public void setTv(ITV tv) {
        this.tv = tv;
    }
    public void open() {
        this.tv.play();
    }
}
```

#### 依赖倒转原则的注意事项和细节

>  1 ) 低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好.
>
>  2 ) 变量的声明类型尽量是抽象类或接口, 这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化
>
>  3 ) 继承时遵循里氏替换原则


### 里氏替换原则

#### OO中的继承性的思考和说明

>  1 ) 继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。
>
>  2 ) 继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低， 增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障
>
>  3 ) 问题提出：在编程中，如何正确的使用继承 => 里氏替换原则

#### 基本介绍

> 1 ) 里氏替换原则(Liskov Substitution Principle)在 1988 年，由麻省理工学院的以为姓里的女士提出的。
>
> 2 ) 如果对每个类型为 T1 的对象 o1 ，都有类型为 T2 的对象 o2 ，使得以 T1 定义的所有程序P在所有的对象 o1 都代换成 o2 时，程序P的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。换句话说，`所有引用基类的地方必须能透明地使用其子类的对象`。
>
>  3 ) 在使用继承时，遵循里氏替换原则，`在子类中尽量不要重写父类的方法`
>
>  4 ) 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖 来 解决问题。


#### 一个程序引出的问题和思考

```java
package BasicKnowledge.设计模式._7大原则;

public class _4_里氏替换原则 {
    public static void main(String[] args) {
        A_4_里氏替换原则 a = new A_4_里氏替换原则();
        System.out.println(" 11 - 3 = " + a.func1(11, 3));
        System.out.println(" 1 - 8 = " + a.func1(1, 8));
        System.out.println("-----------------------");
        B_4_里氏替换原则 b = new B_4_里氏替换原则();
        System.out.println(" 11 - 3 = " + b.func1(11, 3));//这里本意是求出 11 - 3
        System.out.println(" 1 - 8 = " + b.func1(1, 8));// 1 - 8
        System.out.println(" 11 + 3 + 9 = " + b.func2(11, 3));
    }
}

// A类
class A_4_里氏替换原则 {
    // 返回两个数的差
    public int func1(int num1, int num2) {
        return num1 - num2;
    }
}

// B类继承了A
// 增加了一个新功能：完成两个数相加,然后和 9 求和
class B_4_里氏替换原则 extends A_4_里氏替换原则 {
    // 重写了A类的方法, 可能是无意识
    public int func1(int a, int b) {
        return a + b;
    }

    public int func2(int a, int b) {
        return func1(a, b) + 9;
    }
}
```

#### 解决方法

> 1 ) 我们发现原来运行正常的相减功能发生了错误。原因就是类B无意中重写了父类的方法，造成原有功能出现错误。在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候
>
>  2 ) 通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等关系代替.

```java
class Liskov {
    public static void main(String[] args) {
        A_Base a = new A_Base();
        System.out.println(" 11 - 3 =" + a.func1(11, 3));
        System.out.println(" 1 - 8 =" + a.func1(1, 8));
        
        System.out.println("-----------------------");
        B_Base b = new B_Base();
        //因为B类不再继承A类，因此调用者，不会再func1 是求减法
        //调用完成的功能就会很明确
        System.out.println(" 11 + 3 =" + b.func1(11, 3));//这里本意是求出 11 + 3
        System.out.println(" 1 + 8 =" + b.func1(1, 8));// 1 + 8
        System.out.println(" 11 + 3 + 9 =" + b.func2(11, 3));

        //使用组合仍然可以使用到A类相关方法
        System.out.println(" 11 - 3 =" + b.func3(11, 3));// 这里本意是求出 11 - 3
    }
}

//创建一个更加基础的基类
abstract class Base {
    //把更加基础的方法和成员写到Base类
    abstract int func1(int num1, int num2);
}

//A类
class A_Base extends Base {
    // 返回两个数的差
    @Override
    public int func1(int num1, int num2) {
        return num1 - num2;
    }
}

//B类继承了A，增加了一个新功能：完成两个数相加,然后和 9 求和
class B_Base extends Base {
    //如果B需要使用A类的方法,使用组合关系
    private A_Base a = new A_Base();

    //这里，重写了A类的方法, 可能是无意识
    public int func1(int a, int b) {
        return a + b;
    }

    public int func2(int a, int b) {
        return func1(a, b) + 9;
    }

    //我们仍然想使用A的方法
    public int func3(int a, int b) {
        return this.a.func1(a, b);
    }
}
```

### 开闭原则

#### 基本介绍

> 1 ) 开闭原则(OpenClosed Principle)是编程中最基础、最重要的设计原则
>
> 2 ) 一个软件实体如`类，模块和函数应该对扩展开放 ( 对提供方 ) ，对修改关闭 ( 对使用方 )` 。用抽象构建框架，用实现扩展细节。
>
> 3 ) 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。
>
> 4 ) 编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。

#### 看下面一段代码

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220802201941778.png" alt="image-20220802201941778" style="zoom:70%;" />

```java
package BasicKnowledge.设计模式._7大原则;

public class _5_开闭原则 {
    public static void main(String[] args) {
        //使用看看存在的问题
        GraphicEditor graphicEditor = new GraphicEditor();
        graphicEditor.drawShape(new Rectangle());
        graphicEditor.drawShape(new Circle());
    }
}

//这是一个用于绘图的类 [使用方]
class GraphicEditor {
    //接收 Shape 对象，然后根据type，来绘制不同的图形
    public void drawShape(Shape s) {
        if (s.m_type == 1) drawRectangle(s);
        else if (s.m_type == 2) drawCircle(s);
    }

    //绘制矩形
    public void drawRectangle(Shape r) {
        System.out.println("绘制矩形 ");
    }

    //绘制圆形
    public void drawCircle(Shape r) {
        System.out.println("绘制圆形 ");
    }
}

// Shape 类，基类
class Shape {
    int m_type;
}

class Rectangle extends Shape {
    Rectangle() {
        super.m_type = 1;
    }
}

class Circle extends Shape {
    Circle() {
        super.m_type = 2;
    }
}
```

#### 方式 1 的优缺点

> 1 ) 优点是比较好理解，简单易操作。
>
> 2 ) 缺点是违反了设计模式的ocp原则，即对扩展开放(提供方)，对修改关闭(使用方)。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.
>
> 3 ) 比如我们这时要新增加一个图形种类 三角形，我们需要做如下修改，修改的地方较多

#### 改进的思路分析

> 思路：把创建 **Shape** 类做成抽象类，并提供一个抽象的 **draw** 方法，让子类去实现即可，这样我们有新的图形种类时，只需要让新的图形类继承Shape，并实现draw方法即可，使用方的代码就不需要修改

```java
class Ocp {
    public static void main(String[] args) {
//使用看看存在的问题
        GraphicEditor1 graphicEditor = new GraphicEditor1();
        graphicEditor.drawShape(new Rectangle1());
        graphicEditor.drawShape(new Circle1());
        graphicEditor.drawShape(new Triangle1());
    }

}

//这是一个用于绘图的类 [使用方]
class GraphicEditor1 {
    //接收Shape对象，调用draw方法
    public void drawShape(Shape1 s) {
        s.draw();
    }
}

//Shape类，基类
abstract class Shape1 {
    int m_type;
    public abstract void draw();//抽象方法
}

class Rectangle1 extends Shape1 {
    Rectangle1() {
        super.m_type = 1;
    }

    @Override
    public void draw() {
        System.out.println("绘制矩形 ");
    }
}

class Circle1 extends Shape1 {
    Circle1() {
        super.m_type = 2;
    }

    @Override
    public void draw() {
        System.out.println("绘制圆形 ");
    }
}

//新增画三角形
class Triangle1 extends Shape1 {
    Triangle1() {
        super.m_type = 3;
    }

    @Override
    public void draw() {
        System.out.println("绘制三角形 ");
    }
}
```


### 迪米特原则

#### 基本介绍

> 1 ) 一个对象应该对其他对象保持最少的了解
>
> 2 ) 类与类关系越密切，耦合度越大
>
> 3 ) 迪米特原则(Demeter Principle)又叫`最少知道原则`，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public 方法，不对外泄露任何信息
>
> 4 ) 迪米特法则还有个更简单的定义：只与直接的朋友通信
>
> 5 ) 直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现`成员变量，方法参数，方法返回值中的类为直接的朋友`，而出现在`局部变量中的类不是直接的朋友`。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。

#### 应用实例

> 1 ) 有一个学校，下属有各个学院和总部，现要求打印出学校总部员工ID和学院员工的id

```java
package BasicKnowledge.设计模式._7大原则;

import java.util.ArrayList;
import java.util.List;

public class _6_迪米特原则 {
    public static void main(String[] args) {
        //创建了一个 SchoolManager 对象
        SchoolManager schoolManager = new SchoolManager();
        //输出学院的员工id 和 学校总部的员工信息
        schoolManager.printAllEmployee(new CollegeManager());
    }
}

//学校总部员工类
class Employee {
    private String id;
    public void setId(String id) {
        this.id = id;
    }
    public String getId() {
        return id;
    }
}

//学院的员工类
class CollegeEmployee {
    private String id;
    public void setId(String id) {
        this.id = id;
    }
    public String getId() {
        return id;
    }
}

//管理学院员工的管理类
class CollegeManager {
    //返回学院的所有员工
    public List<CollegeEmployee> getAllEmployee() {
        List<CollegeEmployee> list = new ArrayList<CollegeEmployee>();
        for (int i = 0; i < 10; i++) {//这里我们增加了 10 个员工到 list
            CollegeEmployee emp = new CollegeEmployee();
            emp.setId("学院员工id=" + i);
            list.add(emp);
        }
        return list;
    }
}

//学校管理类
//分析 SchoolManager 类的直接朋友类有哪些  Employee 、CollegeManager
//CollegeEmployee  不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则
class SchoolManager {
    //返回学校总部的员工
    public List<Employee> getAllEmployee() {
        List<Employee> list = new ArrayList<Employee>();
        for (int i = 0; i < 5; i++) {//这里我们增加了 5 个员工到 list
            Employee emp = new Employee();
            emp.setId("学校总部员工id=" + i);
            list.add(emp);
        }
        return list;
    }

    //该方法完成输出学校总部和学院员工信息(id)
    void printAllEmployee(CollegeManager sub) {
        //分析问题
        // 1. 这里的 CollegeEmployee  不是 SchoolManager的直接朋友
        // 2. CollegeEmployee  是以局部变量方式出现在 SchoolManager
        // 3. 违反了 迪米特法则

        //获取到学院员工
        List<CollegeEmployee> list1 = sub.getAllEmployee();
        System.out.println("------------学院员工------------");
        for (CollegeEmployee e : list1) {
            System.out.println(e.getId());
        }
        //获取到学校总部员工
        List<Employee> list2 = this.getAllEmployee();
        System.out.println("------------学校总部员工------------");
        for (Employee e : list2) {
            System.out.println(e.getId());
        }
    }
}   
```

#### 应用实例改进

> 1 ) 前面设计的问题在于SchoolManager中， **CollegeEmployee** 类并不是 **SchoolManager** 类的直接朋友 (分析)
> 2 ) 按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合

```java
//管理学院员工的管理类
class CollegeManager1 {
    //返回学院的所有员工
    public List<CollegeEmployee> getAllEmployee() {
        List<CollegeEmployee> list = new ArrayList<CollegeEmployee>();

        for (int i = 0; i < 10; i++) {//这里我们增加了 10 个员工到 list
            CollegeEmployee emp = new CollegeEmployee();
            emp.setId("学院员工id=" + i);
            list.add(emp);
        }
        return list;
    }

    //输出学院员工的信息
    public void printEmployee() {
//获取到学院员工
        List<CollegeEmployee> list1 = getAllEmployee();
        System.out.println("------------学院员工------------");
        for (CollegeEmployee e : list1) {
            System.out.println(e.getId());
        }
    }
}

//学校管理类
//分析 SchoolManager  类的直接朋友类有哪些 Employee 、 CollegeManager
//CollegeEmployee  不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则
class SchoolManager1 {
    //返回学校总部的员工
    public List<Employee> getAllEmployee() {
        List<Employee> list = new ArrayList<Employee>();
        for (int i = 0; i < 5; i++) {//这里我们增加了 5 个员工到 list
            Employee emp = new Employee();
            emp.setId("学校总部员工id=" + i);
            list.add(emp);
        }
        return list;
    }

    //该方法完成输出学校总部和学院员工信息(id)
    void printAllEmployee(CollegeManager1 sub) {
        //分析问题
        // 1. 将输出学院的员工方法，封装到 CollegeManager 
        sub.printEmployee();
        //获取到学校总部员工
        List<Employee> list2 = this.getAllEmployee();
        System.out.println("------------学校总部员工------------");
        for (Employee e : list2) {
            System.out.println(e.getId());
        }
    }
}
```

#### 迪米特法则注意事项和细节

> 1 ) 迪米特法则的核心是降低类之间的耦合
>
> 2 ) 但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系，并不是要求完全没有依赖关系

### 合成复用原则

#### 基本介绍

> 合成复用原则(Composite Reuse Principle)是尽量使用合成/聚合的方式，而不是使用继承
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220802205630019.png" alt="image-20220802205630019" style="zoom:50%;" />

#### 设计原则核心思想

>  1 ) 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。
>
>  2 ) 针对接口编程，而不是针对实现编程。
>
>  3 ) 为了交互对象之间的松耦合设计而努力


## UML 类图

### UML基本介绍

> 1 ) UML——Unified modeling language(统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果
> 2 ) UML本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等

### UML图

> 画UML图与写文章差不多，都是把自己的思想描述给别人看，关键在于思路和条理，UML图分类：
>
> 1 ) 用例图(usecase)
> 2 ) 静态结构图：类图、对象图、包图、组件图、部署图
> 3 ) 动态行为图：交互图(时序图与协作图)、状态图、活动图

### UML类图

> 1 ) 用于描述系统中的类 ( 对象 ) 本身的组成和类 ( 对象 ) 之间的各种静态关系。
>
> 2 ) 类之间的关系：依赖、泛化(继承)、实现、关联、聚合与组合。
>
> 3 ) 类图简单举例
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220803100456498.png" alt="image-20220803100456498" style="zoom:50%;" />

### 类关系

#### 依赖关系(dependence)

> - 只要是在类中用到了对方，那么他们之间就存在依赖关系。如果没有对方，连编绎都通过不了。使用`虚线箭头`表示
> - 包括：`类的成员属性、方法的返回类型、方法接收的参数类型、方法中使用到的类型`
>

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220803100818910.png" alt="image-20220803100818910" style="zoom:40%;" />

#### 泛化关系(generalization)

> - 泛化关系实际上就是继承关系，他是依赖关系的特例
> - 如果A类继承了B类，我们就说A和B存在泛化关系，使用`带三角形的实线`表示

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220803101041310.png" alt="image-20220803101041310" style="zoom:43%;" />

#### 实现关系(implementation)

> - 实现关系实际上就是 A 类实现 B 接口，他是依赖关系的特例
> - 实现关系使用`带三角形的虚线`表示

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220803101254895.png" alt="image-20220803101254895" style="zoom:50%;" />

#### 关联关系(association)

> - 关联关系是类与类的联系，是依赖关系的特例。
> - 一个类做为另一个类的属性类型存在，即 has-a
> - 关联关系具有导航性：包括单向关系、双向关系
> - 关联关系使用`实线或者实线箭头`表示

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220803103602905.png" alt="image-20220803103602905" style="zoom:50%;" />

#### 聚合关系(aggregation)

> - 聚合关系(Aggregation)表示的是整体和部分的关系，整体与部分可以分开。
> - 聚合关系是关联关系的特例，所以他具有关联的导航性与多重性。
> - 如：一台电脑由键盘(keyboard)、显示器(monitor)，鼠标等组成；如果认为组成电脑的各个配件是可以从电脑上分离出来的，用聚合关系，使用带`空心菱形的实线`来表示

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220803103707281.png" alt="image-20220803103707281" style="zoom:50%;" />


#### 组合关系(composition)

> - 组合关系：也是整体与部分的关系，但是整体与部分不可以分开。
> - 如果认为组成电脑的各个配件是不可以从电脑上分离出来的，用组合关系，使用带`实心菱形的实线`来表示

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220803104754454.png" alt="image-20220803104754454" style="zoom:50%;" />

### 使用PlantUML画类图

#### 要素

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220804110319312.png" alt="image-20220804110319312" style="zoom:50%;" />

```java
@startuml
  abstract        abstract
  abstract class  "abstract class"
  annotation      annotation
  circle          circle
  ()              circle_short_form
  class           class
  diamond         diamond
  <>              diamond_short_form
  entity          entity
  enum            enum
  interface       interface
  protocol        protocol
  struct          struct
@enduml
```

#### 类关系

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220804110441658.png" alt="image-20220804110441658" style="zoom:47%;" />

```java
@startuml
  '类关系
  '依赖
  Class01 <.. Class02
  '泛化
  Class03 <|-- Class04
  '实现
  Class05 <|.. Class06
  '关联
  Class07 -- Class08
  '聚合
  Class09 o-- Class10
  '组合
  Class011 *-- Class12

  '关系标签
  类01 "1" *-- "many" 类02 : 组合
@enduml
```

#### 属性和方法

> - 访问权限
>
>   <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220804110809246.png" alt="image-20220804110809246" style="zoom:45%;" />
>
> - 静态：{static} ；抽象：{abstract}
>
> - 注释
>
>   - 类注释：note left of ArrayList: ArrayList类注释
>
>   - 方法或者属性注释：
>
>     note right of ArrayList::"equals(Object o)"
>         equals方法
>     end note

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220804110548980.png" alt="image-20220804110548980" style="zoom:30%;" />

```java
@startuml
interface List {
    - int size()
    ~ boolean isEmpty()
    # boolean equals(Object o)
    + {static} int hashCode()
    + {abstract} int indexOf(Object o)
    + boolean remove(Object o)
    + boolean containsAll(Collection<?> c)
}
note left of List: List接口注释

class ArrayList {
    - {static} int DEFAULT_CAPACITY
    - Object[] EMPTY_ELEMENTDATA
    - Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA
    - int size

    + int size()
    + boolean isEmpty()
    + boolean equals(Object o)
    + {static} int hashCode()
    + int indexOf(Object o)
    + boolean remove(Object o)
    + boolean containsAll(Collection<?> c)
}
note left of ArrayList: ArrayList类注释
note right of ArrayList::"size"
    List大小
end note
note right of ArrayList::"equals(Object o)"
    equals方法
end note

List <|.. ArrayList
@enduml
```

## 设计模式概述

### 设计模式介绍

> 1 ) 设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，模式不是代码，而是`某类问题的通用解决方案`，设计模式(Design pattern)代表了最佳的实践。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。
>
> 2 ) 设计模式的本质提高软件的维护性，通用性和扩展性，并降低软件的复杂度。
>
> 3 ) <<设计模式>>是经典的书，作者是 ErichGamma、RichardHelm、RalphJohnson 和 JohnVlissidesDesign(俗称 “四人组 GOF”)
>
> 4 ) 设计模式并不局限于某种语言，java，php，c++ 都有设计模式

### 设计模式类型

>  设计模式分为三种类型，共 23 种
>
>  1 ) 创建型模式：单例模式、工厂方法模式、抽象工厂模式、原型模式、建造者模式。
>
>
>  2 ) 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
>
>  3 ) 行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式(Interpreter模式)、状态模式、策略模式、职责链模式(责任链模式)。
>
> 注意：不同的书籍上对分类和名称略有差别

## 创建型

### 单例模式

#### 单例设计模式介绍

> - 采取一定的方法保证在整个的软件系统中，`某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法(静态方法)`
>
> - 使用场景
>   - 要求生成唯一序列号的环境；
>   - 在整个项目中需要一个共享访问点或共享数据，例如一个Web页面上的计数器，可以不用把每次刷新都记录到数据库中，使用单例模式保持计数器的值，并确保是线程安全的；
>   - 创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源；
>   - 需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即：重量级对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据源、 session 工厂等)

#### 饿汉式(静态常量)

> 1 ) 构造器私有化 (防止 new)
> 2 ) 类的内部创建对象并实例化
> 3 ) 向外暴露一个静态的公共方法。getInstance

```java
package BasicKnowledge.设计模式.创建型.单例模式;

public class 饿汉式_静态常量 {
    public static void main(String[] args) {
        Singleton instance = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();
        System.out.println(instance == instance2);//true
        System.out.println("instance.hashCode=" + instance.hashCode());
        System.out.println("instance 2 .hashCode=" + instance2.hashCode());
    }
}

//饿汉式(静态变量)
class Singleton {
    // 1. 构造器私有化, 外部能new
    private Singleton() {
    }

    // 2 .本类内部创建对象实例
    private final static Singleton instance = new Singleton();

    // 3. 提供一个公有的静态方法，返回实例对象
    public static Singleton getInstance() {
        return instance;
    }
}
```

##### 优缺点

> 1 ) 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。
>
> 2 ) 缺点：在类装载的时候就完成实例化，没有达到LazyLoading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费
>
> 3 ) 这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，在单例模式中大多数都是调用getInstance方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式(或者其他的静态方法)导致类装载，这时候初始化instance就没有达到lazyloading的效果
>
> 4 ) 结论：这种单例模式可用，可能造成内存浪费

#### 饿汉式(静态代码块)

```java
//饿汉式(静态代码块)
class Singleton2 {
    // 1. 构造器私有化, 外部能new 
    private Singleton2() {}

    // 2 .本类内部创建对象实例
    private static Singleton2 instance;

    static {// 在静态代码块中，创建单例对象
        instance = new Singleton2();
    }

    // 3. 提供一个公有的静态方法，返回实例对象
    public static Singleton2 getInstance() {
        return instance;
    }
}
```

##### 优缺点

> 1 ) 这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。`优缺点和上面是一样的`。

#### 懒汉式(线程不安全)

```java
// 懒汉式_线程不安全
class Singleton3 {
    private Singleton3() {}

    private static Singleton3 instance;

    // 懒汉式：提供一个静态的公有方法，当使用到该方法时，才去创建 instance
    public static Singleton3 getInstance() {
        if (instance == null) {
            instance = new Singleton3();
        }
        return instance;
    }
}
```

##### 优缺点说明：

> 1 ) 起到了 **LazyLoading** 的效果，但是只能在单线程下使用。
> 2 ) 如果在多线程下，一个线程进入了if(singleton==null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式
> 3 ) 结论：在实际开发中，不要使用这种方式.

#### 懒汉式(同步方法)

```java
// 懒汉式(线程安全，同步方法)
class Singleton4 {
    private Singleton4() {}

    private static Singleton4 instance;

    // 懒汉式：提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题
    public static synchronized Singleton4 getInstance() {
        if (instance == null) {
            instance = new Singleton4();
        }
        return instance;
    }
}
```

##### 优缺点

> 1 ) 解决了线程安全问题
>
> 2 ) 效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低
>
> 3 ) 结论：在实际开发中，不推荐使用这种方式

#### 懒汉式(同步代码块)

```java
// 懒汉式(线程安全，同步代码块)
class Singleton5 {
    private Singleton5() {}

    private static Singleton5 instance;

    // 懒汉式：提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题
    public static Singleton5 getInstance() {
        if (instance == null) {
            synchronized(Singleton5.class) {
                instance = new Singleton5();
            }
        }
        return instance;
    }
}
```

#### 双重检查

```java
class Singleton6 {
    private Singleton6() {}

    private static volatile Singleton6 instance;

    // 提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 解决懒加载问题，同时保证了效率, 推荐使用
    public static synchronized Singleton6 getInstance() {
        if (instance == null) {
            synchronized (Singleton6.class) {
                if (instance == null) {
                    instance = new Singleton6();
                }
            }
        }
        return instance;
    }
}
```

##### 优缺点

> 1 ) Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两次if(singleton==null)检查，这样就可以保证线程安全了。
> 2 ) 这样，实例化代码只用执行一次，后面再次访问时，判断if(singleton==null)，直接return实例化对象，也避免的反复进行方法同步.
> 3 ) 线程安全；延迟加载；效率较高
> 4 ) 结论：在实际开发中，推荐使用这种单例设计模式

#### 静态内部类

```java
// 静态内部类完成， 推荐使用
class Singleton7 {
    private Singleton7() {}
    private static volatile Singleton7 instance;

    //写一个静态内部类,该类中有一个静态属性 Singleton
    private static class SingletonInstance {
        private static final Singleton7 INSTANCE = new Singleton7();
    }

    //提供一个静态的公有方法，直接返回Singleton7Instance.INSTANCE
    public static synchronized Singleton7 getInstance() {
        return SingletonInstance.INSTANCE;
    }
}
```

 ##### 优缺点

> 1 ) 这种方式采用了类装载的机制来保证初始化实例时只有一个线程。
>
> 2 ) 静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。
>
> 3 ) 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。
>
> 4 ) 优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高
>
> 5 ) 结论：推荐使用.

#### 枚举

```java
//使用枚举，可以实现单例, 推荐
enum Singleton8 {
    INSTANCE;//属性
}
```

##### 优缺点

> 1 ) 这借助JDK 1. 5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。
>
> 2 ) 这种方式是 **EffectiveJava** 作者 **JoshBloch** 提倡的方式
>
> 3 ) 结论：推荐使用

#### 在JDK应用的源码分析

单例模式在JDK应用的源码分析

> 我们JDK中，java.lang.Runtime就是经典的单例模式(饿汉式)
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220803161053335.png" alt="image-20220803161053335" style="zoom:50%;" />

### 工厂模式

#### 简单工厂模式(不属于23种)

##### 看一个具体的需求

> 看一个披萨的项目：要便于披萨种类的扩展，要便于维护
>
> 1 ) 披萨的种类很多(比如 GreekPizz、CheesePizz 等)
> 2 ) 披萨的制作有 prepare，bake,cut,box
> 3 ) 完成披萨店订购功能。

#####  基本介绍

> - 简单工厂模式又叫静态工厂模式，是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式
>
> - 简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为(代码)，避免直接创建对象，不需要关注如何创建对象，直接通过工厂创建。
>
> - 在软件开发中，当大量的创建某种、某类或者某批对象时，就会使用到工厂模式.

##### 使用简单工厂模式

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220805112944955.png" alt="image-20220805112944955" style="zoom:50%;" />

```java
package BasicKnowledge.设计模式._1_创建型._2_3_工厂模式;

public class _1_简单工厂模式 {
    public static void main(String[] args) {
        Pizza pizza = new PizzaFactory().createPizza("greek");
    }
}

// Pizza 抽象类
abstract class Pizza {
    protected String name;

    public abstract void prepare();
    public void bake() {
        System.out.println(name + " baking;");
    }
    public void cut() {
        System.out.println(name + " cutting;");
    }
    public void box() {
        System.out.println(name + " boxing;");
    }
    public void setName(String name) {
        this.name = name;
    }
}

class GreekPizza extends Pizza {
    @Override
    public void prepare() {
        System.out.println(" 希腊披萨 准备 ");
    }
}

class CheesePizza extends Pizza {
    @Override
    public void prepare() {
        System.out.println(" 奶酪披萨 准备 ");
    }
}

class PepperPizza extends Pizza {
    @Override
    public void prepare() {
        System.out.println(" 胡椒披萨 准备 ");
    }
}

//简单工厂类
class PizzaFactory {
    //更加orderType 返回对应的Pizza   对象
    public Pizza createPizza(String orderType) {
        Pizza pizza = null;

        System.out.println("使用简单工厂模式");
        if (orderType.equals("greek")) {
            pizza = new GreekPizza();
            pizza.setName(" 希腊披萨 ");
        } else if (orderType.equals("cheese")) {
            pizza = new CheesePizza();
            pizza.setName(" 奶酪披萨 ");
        } else if (orderType.equals("pepper")) {
            pizza = new PepperPizza();
            pizza.setName("胡椒披萨");
        }
        return pizza;
    }
}
```

#### 工厂方法模式

##### 工厂方法模式介绍

> - 工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。
>
> - 工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂 方法使一个类的实例化延迟到其子类。
> - 使用场景：jdbc连接数据库，硬件访问，降低对象的产生和销毁

##### 工厂方法模式应用案例

> 使用简单工厂模式，新增1个pizza实现类，需要修改工厂的代码，不符合开闭原则，改进：使用工厂方法模式

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220805143355754.png" alt="image-20220805143355754" style="zoom:50%;" />

```java
package BasicKnowledge.设计模式._1_创建型._2_3_工厂模式;

public class _2_工厂方法模式 {
    public static void main(String[] args) {
        Pizza pizza = new GreekPizzaFactory().createPizza();
    }
}

abstract class FactoryMethod {
    //定义一个抽象方法，createPizza , 让各个工厂子类自己实现
    abstract Pizza createPizza();

    // 构造器
    public FactoryMethod() {
        Pizza pizza = null;
        // 订购披萨的类型
        pizza = createPizza();//抽象方法，由工厂子类完成
        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();
    }
}

class GreekPizzaFactory extends FactoryMethod{
    @Override
    GreekPizza createPizza() {
        return new GreekPizza();
    }
}

class CheesePizzaFactory extends FactoryMethod{
    @Override
    CheesePizza createPizza() {
        return new CheesePizza();
    }
}

class PepperPizzaFactory extends FactoryMethod{
    @Override
    PepperPizza createPizza() {
        return new PepperPizza();
    }
}
```

#### 抽象工厂模式

##### 基本介绍

> - 抽象工厂模式：定义了一个接口用于创建相关或有依赖关系的产品族，而无需指明具体的类
>
> - 将工厂抽象成两层， **AbsFactory(** 抽象工厂 **)** 和 具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂族，更利于代码的维护和扩展。
>
>   <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220805151019874.png" alt="image-20220805151019874" style="zoom:33%;" />
>
> - 使用场景：一个对象族（或是一组没有任何关系的对象）都有相同的约束。 涉及不同操作系统的时候，都可以考虑使用抽象工厂模式

##### 抽象工厂模式应用实例

> 客户可以点不同大小的Pizza，如：大、中、小的Pizza
>
> - 使用工厂方法模式：需要新增9种不同的Pizza，每种Pizza新增一个Factory与之对应，过程繁琐
> - 使用抽象工厂模式：新增9种不同Pizza，新增3个（大、中、小）具体的工厂，`大、中、小对应产品族，不同种类的Pizza对应产品等级`，新增一个产品族只要新增类即可，但是新增了产品等级要修改之前产品族的代码，不符合开闭原则

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220805155718783.png" alt="image-20220805155718783" style="zoom:33%;" />

```java
package BasicKnowledge.设计模式._1_创建型._2_3_工厂模式;

public class _3_抽象工厂模式 {
    public static void main(String[] args) {
        Pizza pizza = new BigFactory().createPizza("cheese");
        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();
    }
}

class BigCheesePizza extends Pizza {
    @Override
    public void prepare() {
        setName("BigCheesePizza");
        System.out.println(" BigCheesePizza 准备");
    }
}
class BigPepperPizza extends Pizza {
    @Override
    public void prepare() {
        setName("BigPepperPizza");
        System.out.println(" BigPepperPizza 准备");
    }
}

class MiddleCheesePizza extends Pizza{
    @Override
    public void prepare() {
        setName("MiddleCheesePizza");
        System.out.println("MiddleCheesePizza 准备");
    }
}
class MiddlePepperPizza extends Pizza{
    @Override
    public void prepare() {
        setName("MiddlePepperPizza");
        System.out.println("MiddlePepperPizza 准备");
    }
}

class SmallCheesePizza extends Pizza{
    @Override
    public void prepare() {
        setName("SmallCheesePizza");
        System.out.println("SmallCheesePizza 准备");
    }
}
class SmallPepperPizza extends Pizza{
    @Override
    public void prepare() {
        setName("SmallPepperPizza");
        System.out.println("SmallPepperPizza 准备");
    }
}

//一个抽象工厂模式的抽象层(接口)
abstract class AbsFactory {
    //让下面的工厂子类来 具体实现
    abstract Pizza createPizza(String orderType);
}

//这是工厂子类
class BigFactory extends AbsFactory {
    @Override
    public Pizza createPizza(String orderType) {
        Pizza pizza = null;
        if (orderType.equals("cheese")) {
            pizza = new BigCheesePizza();
        } else if (orderType.equals("pepper")) {
            pizza = new BigPepperPizza();
        }
        return pizza;
    }
}

class MiddleFactory extends AbsFactory {
    @Override
    public Pizza createPizza(String orderType) {
        Pizza pizza = null;
        if (orderType.equals("cheese")) {
            pizza = new MiddleCheesePizza();
        } else if (orderType.equals("pepper")) {
            pizza = new MiddlePepperPizza();
        }
        return pizza;
    }
}

class SmallFactory extends AbsFactory {
    @Override
    public Pizza createPizza(String orderType) {
        Pizza pizza = null;
        if (orderType.equals("cheese")) {
            pizza = new SmallCheesePizza();
        } else if (orderType.equals("pepper")) {
            pizza = new SmallPepperPizza();
        }
        return pizza;
    }
}
```

#### 在JDK应用的源码分析

> JDK 中的Calendar类中，就使用了简单工厂模式


### 原型模式

#### 克隆羊问题

> 现在有一只羊tom，姓名为:tom, 年龄为： 1 ，颜色为：白色，请编写程序创建和tom羊 属性完全相同的 10只羊。

#### 传统方式解决克隆羊问题

```java
package BasicKnowledge.设计模式._1_创建型._5_原型模式;

public class _1_传统的方式 {
    public static void main(String[] args) {
        Sheep sheep = new Sheep("tom", 1, "白色");

        Sheep sheep1 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());
        Sheep sheep2 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());
        Sheep sheep3 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());
        Sheep sheep4 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());
        Sheep sheep5 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());
        System.out.println(sheep);
        System.out.println(sheep1);
        System.out.println(sheep2);
        System.out.println(sheep3);
        System.out.println(sheep4);
        System.out.println(sheep5);
    }
}

class Sheep {
    private String name;
    private int age;
    private String color;

    public Sheep(String name, int age, String color) {
        this.name = name;
        this.age = age;
        this.color = color;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }
}
```

#### 传统的方式的优缺点

>  1 ) 优点是比较好理解，简单易操作。
>
>  2 ) 在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低
>
>  3 ) 总是需要重新初始化对象，而不是动态地获得对象运行时的状态, 不够灵活
>
>  4 ) 改进的思路分析
>
> 思路：Java中Object类是所有类的根类，Object类提供了一个clone()方法，该方法可以将一个Java对象复制一份，但是需要实现clone的Java类必须要实现一个接口Cloneable，该接口表示该类能够复制且具有复制的能力 =>原型模式

#### 基本介绍

> 1 ) 原型模式是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象
>
> 

#### 类图

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220804151441988.png" alt="image-20220804151441988" style="zoom:50%;" />

> 1 ) Prototype: 原型类，声明一个克隆自己的接口
> 2 ) ConcretePrototype: 具体的原型类, 实现一个克隆自己的操作
> 3 ) Client: 让一个原型对象克隆自己，从而创建一个新的对象(属性一样)

#### 应用实例

```java
package BasicKnowledge.设计模式._1_创建型._5_原型模式;

public class _2_原型模式 {
    public static void main(String[] args) {
        Sheep1 sheep = new Sheep1("tom", 1, "白色");
        sheep.friend = new Sheep1("jack", 2, "黑色");
        
        Sheep1 sheep1 = (Sheep1) sheep.clone();//克隆
        Sheep1 sheep2 = (Sheep1) sheep.clone();//克隆
        Sheep1 sheep3 = (Sheep1) sheep.clone();//克隆
        Sheep1 sheep4 = (Sheep1) sheep.clone();//克隆
        Sheep1 sheep5 = (Sheep1) sheep.clone();//克隆

        System.out.println("sheep1 = " + sheep1 + " sheep1.friend = " + sheep1.friend.hashCode());
        System.out.println("sheep2 = " + sheep2 + " sheep2.friend = " + sheep2.friend.hashCode());
        System.out.println("sheep3 = " + sheep3 + " sheep3.friend = " + sheep3.friend.hashCode());
        System.out.println("sheep4 = " + sheep4 + " sheep4.friend = " + sheep4.friend.hashCode());
        System.out.println("sheep5 = " + sheep5 + " sheep5.friend = " + sheep5.friend.hashCode());
    }
}

class Sheep1 implements Cloneable {
    private String name;
    private int age;
    private String color;
    private String address = "蒙古羊";
    public Sheep1 friend;//是对象, 克隆是会如何处理, 默认是浅拷贝

    public Sheep1(String name, int age, String color) {
        super();
        this.name = name;
        this.age = age;
        this.color = color;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    @Override
    public String toString() {
        return "Sheep1 [name=" + name + ",age=" + age + ",color=" + color + ",address=" + address + "]";
    }

    //克隆该实例，使用默认的clone方法来完成
    @Override
    protected Object clone() {
        Sheep1 sheep = null;
        try {
            sheep = (Sheep1) super.clone();
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
        return sheep;
    }
}
```

#### 浅拷贝和深拷贝

##### 浅拷贝

> 1 ) 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。
>
> 2 ) 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值(内存地址)复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值
>
> 3 ) 前面我们克隆羊就是浅拷贝
>
> 4 ) 浅拷贝是使用默认的 clone()方法来实现sheep=(Sheep)super.clone();

##### 深拷贝

> 1 ) 复制对象的所有基本数据类型的成员变量值
>
> 2 ) 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象 ( 包括对象的引用类型 ) 进行拷贝
>
> 3 ) 深拷贝实现方式 1 ：重写 **clone** 方法来实现深拷贝
>
> 4 ) 深拷贝实现方式 2 ：通过对象序列化实现深拷贝(推荐)

#### 深拷贝应用实例

> 1 ) 使用 重写clone方法实现深拷贝
> 2 ) 使用序列化来实现深拷贝

```java
package BasicKnowledge.设计模式._1_创建型._5_原型模式;

import java.io.*;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

public class _2_原型模式 {
    public static void main(String[] args) throws CloneNotSupportedException {
        DeepProtoType d1 = new DeepProtoType("d1");
        d1.deepCloneableTarget = new DeepCloneableTarget("dt1", "dt1");
        // 1.使用clone实现深拷贝
        DeepProtoType d2 = (DeepProtoType) d1.clone();
        System.out.println(d1.hashCode() + " " + d1.deepCloneableTarget.hashCode());
        System.out.println(d2.hashCode() + " " + d2.deepCloneableTarget.hashCode());

        // 2.通过序列化实现深拷贝
        DeepProtoType d3 = d1.deepClone();
        System.out.println(d1.hashCode() + " " + d1.deepCloneableTarget.hashCode());
        System.out.println(d3.hashCode() + " " + d3.deepCloneableTarget.hashCode());
    }
}

class DeepCloneableTarget implements Serializable, Cloneable {
    private static final long serialVersionUID = 1L;
    private String cloneName;
    private String cloneClass;

    //构造器
    public DeepCloneableTarget(String cloneName, String cloneClass) {
        this.cloneName = cloneName;
        this.cloneClass = cloneClass;
    }

    //因为该类的属性，都是String , 因此我们这里使用默认的clone完成即可
    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}

class DeepProtoType implements Serializable, Cloneable {
    public String name;//String  属性
    public DeepCloneableTarget deepCloneableTarget;// 引用类型

    public DeepProtoType(String name){this.name = name;}

    //深拷贝 - 方式 1 使用clone方法
    @Override
    protected Object clone() throws CloneNotSupportedException {
        Object deep = null;
        //这里完成对基本数据类型(属性)和String 的克隆
        deep = super.clone();
        //对引用类型的属性，进行单独处理
        DeepProtoType deepProtoType = (DeepProtoType) deep;
        deepProtoType.deepCloneableTarget = (DeepCloneableTarget) deepCloneableTarget.clone();
        return deepProtoType;
    }

    //深拷贝 - 方式 2 通过对象的序列化实现 (推荐)
    public DeepProtoType deepClone() {
        //创建流对象
        ByteArrayOutputStream bos = null;
        ObjectOutputStream oos = null;
        ByteArrayInputStream bis = null;
        ObjectInputStream ois = null;

        try {
            //序列化
            bos = new ByteArrayOutputStream();
            oos = new ObjectOutputStream(bos);
            oos.writeObject(this);//当前这个对象以对象流的方式输出

            //反序列化
            bis = new ByteArrayInputStream(bos.toByteArray());
            ois = new ObjectInputStream(bis);
            DeepProtoType copyObj = (DeepProtoType) ois.readObject();

            return copyObj;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        } finally {
            //关闭流
            try {
                bos.close();
                oos.close();
                bis.close();
                ois.close();
            } catch (Exception e2) {
                System.out.println(e2.getMessage());
            }
        }
    }
}
```

#### 原型模式的注意事项和细节

> 1 ) 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率
>
>  2 ) 不用重新初始化对象，而是动态地获得对象运行时的状态
>
>  3 ) 如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码
>
>  4 ) 在实现深克隆的时候可能需要比较复杂的代码
>
>  5 ) 缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了ocp原则，这点请同学们注意.

### 建造者模式

#### 建造者模式基本介绍

> 1 ) 建造者模式( **Builder Pattern** )又叫`生成器模式`，是一种对象构建模式。将一个复杂对象的构建与它的表示分离，使这个抽象过程的不同实现方法可以构造出不同表现(属性)的对象。
> 2 ) 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。
>
> - 使用场景
>
>   - 相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式。
>
>   - 多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时，则可以使用该模式。
>
>   - 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式非常合适。

#### 盖房项目需求

>  1 ) 需要建房子：这一过程为打桩、砌墙、封顶
>
>  2 ) 房子有各种各样的，比如普通房，高楼，别墅，各种房子的过程虽然一样，但是要求不要相同的.
>

#### 建造者模式原理类图

> 1 ) Product(产品角色)：一个具体的产品对象。
>
> 2 ) Builder(抽象建造者)：创建一个Product对象的各个部件指定的 接口 **/** 抽象类。
>
> 3 ) ConcreteBuilder(具体建造者)：实现接口，构建和装配各个部件。
>
> 4 ) Director(指挥者)：构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220804161534623.png" alt="image-20220804161534623" style="zoom:50%;" />


#### 应用实例

> 需要建房子：这一过程为打桩、砌墙、封顶。不管是普通房子也好，别墅也好都需要经历这些过程，下面我们使用建造者模式(Builder Pattern)来完成

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220804161621055.png" alt="image-20220804161621055" style="zoom:50%;" />

```java
package BasicKnowledge.设计模式._1_创建型._5_建造者模式;

public class _2_建造者模式 {
    public static void main(String[] args) {
        //盖普通房子
        HouseBuilder commonHouse = new CommonHouse1();
        //准备创建房子的指挥者
        HouseDirector houseDirector = new HouseDirector(commonHouse);
        //完成盖房子，返回产品(普通房子)
        houseDirector.constructHouse();

        System.out.println("--------------------------");
        //盖高楼
        HouseBuilder highBuilding = new HighBuilding1();
        //重置建造者
        houseDirector.setHouseBuilder(highBuilding);
        //完成盖房子，返回产品(高楼)
        houseDirector.constructHouse();
    }
}

//产品->Product
class House {
    public String baise;
    public String wall;
    public String roofed;
}

// 抽象的建造者
abstract class HouseBuilder {
    protected House house = new House();

    //将建造的流程写好, 抽象的方法
    public abstract void buildBasic();
    public abstract void buildWalls();
    public abstract void roofed();

    //建造房子好， 将产品(房子) 返回
    public House buildHouse() {
        return house;
    }
}

class CommonHouse1 extends HouseBuilder {
    @Override
    public void buildBasic() {
        System.out.println("普通房子打地基 5 米 ");
    }
    @Override
    public void buildWalls() {
        System.out.println("普通房子砌墙 10 cm");
    }
    @Override
    public void roofed() {
        System.out.println("普通房子屋顶 ");
    }
}

class HighBuilding1 extends HouseBuilder {
    @Override
    public void buildBasic() {
        System.out.println("高楼的打地基 100 米 ");
    }
    @Override
    public void buildWalls() {
        System.out.println("高楼的砌墙 20 cm");
    }
    @Override
    public void roofed() {
        System.out.println("高楼的透明屋顶 ");
    }
}

//指挥者，这里去指定制作流程，返回产品
class HouseDirector {
    HouseBuilder houseBuilder = null;

    //构造器传入 houseBuilder
    public HouseDirector(HouseBuilder houseBuilder) {
        this.houseBuilder = houseBuilder;
    }

    //通过setter 传入 houseBuilder
    public void setHouseBuilder(HouseBuilder houseBuilder) {
        this.houseBuilder = houseBuilder;
    }

    //如何处理建造房子的流程，交给指挥者
    public House constructHouse() {
        houseBuilder.buildBasic();
        houseBuilder.buildWalls();
        houseBuilder.roofed();
        return houseBuilder.buildHouse();
    }
}
```


#### 在JDK的应用和源码分析

> 1 ) java.lang.StringBuilder中的建造者模式
>
> 2 ) 源码中建造者模式角色分析
>
> - Appendable 接口定义了多个append方法(抽象方法), 即Appendable 为抽象建造者, 定义了抽象方法
>
> - AbstractStringBuilder 实现了Appendable 接口方法，这里的 AbstractStringBuilder 已经是建造者，只是不能实例化
>
> - StringBuilder 即充当了指挥者角色，同时充当了具体的建造者，建造方法的实现是由 AbstractStringBuilder 完成, 而StringBuilder 继承了AbstractStringBuilder

#### 注意事项和细节

> 1 ) 客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象
>
>  2 ) 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象
>
>
>  3 ) 可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程
>
>  4 ) 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”
>
>  5 ) 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。
>
>  6 ) 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式.
>
>  7 ) 抽象工厂模式VS建造者模式
>
> - 抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。
> - 建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品

## 结构型

### 适配器模式

#### 现实生活中的适配器例子

> 泰国插座用的是两孔的(欧标)，可以买个多功能转换插头 (适配器) ，这样就可以使用了。

#### 基本介绍 

> - 适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)。从用户的角度看不到被适配者，是解耦的
>
> - 根据 src是以怎样的形式给到Adapter(在Adapter里的形式)，主要分为三类：类适配器模式、对象适配器模式、接口适配器模式
>
> - 类适配：创建新类，继承源类，并实现新接口，例如 class adapter extends oldClass implements newFunc{}
>
>   对象适配：创建新类持源类的实例，并实现新接口，例如 class adapter implements newFunc { private oldClass oldInstance ;}
>
>   接口适配：创建新的抽象类实现旧接口方法。例如 abstract class adapter implements oldClassFunc { void newFunc();}
>
> - 使用场景：修改一个已经投产中的接口时，适配器模式可能是适合你的模式。


#### 类适配器模式

##### 类适配器模式介绍

> 基本介绍：Adapter类，通过继承src类，实现dst 类接口，完成src->dst的适配。

##### 类适配器模式应用实例

> 以生活中充电器的例子来讲解适配器，充电器本身相当于Adapter， 220 V交流电相当于src(即被适配者)，dst(即 目标)是 5 V直流电

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220806163435194.png" alt="image-20220806163435194" style="zoom:60%;" />

```java
package BasicKnowledge.设计模式._2_结构型._1_适配器模式;

public class _1_类适配器 {
    public static void main(String[] args) {
        Phone phone = new Phone();
        phone.charging(new VoltageAdapter());
    }
}

class Phone {
    //充电
    public void charging(IVoltage5V iVoltage5V) {
        if (iVoltage5V.output5V() == 5) {
            System.out.println("电压为 5V, 可以充电~~");
        } else if (iVoltage5V.output5V() > 5) {
            System.out.println("电压大于 5V, 不能充电~~");
        }
    }
}

//适配接口
interface IVoltage5V {
    public int output5V();
}

//被适配的类
class Voltage220V {
    //输出 220V的电压
    public int output220V() {
        int src = 220;
        System.out.println("电压=" + src + "伏");
        return src;
    }
}

//适配器类
class VoltageAdapter extends Voltage220V implements IVoltage5V {
    @Override
    public int output5V() {
        //获取到 220V电压
        int srcV = output220V();
        int dstV = srcV / 44;//转成 5 v
        return dstV;
    }
}
```

##### 类适配器模式注意事项和细节

> 1 ) Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点,因为这要求dst必须是接口，有一定局限性;
> 2 ) src类的方法在Adapter中都会暴露出来，也增加了使用的成本。
> 3 ) 由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强了。

#### 对象适配器模式

##### 对象适配器模式介绍

> 1 ) 基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承src类，而是持有src类的实例，以解决兼容性的问题。 即：持有 src类的对象，实现 dst 类接口，完成src->dst的适配
>
> 2 ) 根据“合成复用原则”，在系统中尽量使用关联关系(聚合)来替代继承关系。
>
> 3 ) 对象适配器模式是适配器模式常用的一种

##### 对象适配器模式应用实例

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220806162805278.png" alt="image-20220806162805278" style="zoom:50%;" />

```java
package BasicKnowledge.设计模式._2_结构型._1_适配器模式;

public class _2_对象适配器 {
    public static void main(String[] args) {
        Phone phone = new Phone();
        phone.charging(new VoltageAdapter1(new Voltage220V()));
    }
}

//适配器类
class VoltageAdapter1 implements IVoltage5V {
    private Voltage220V voltage220V;// 关联关系-聚合
    //通过构造器，传入一个Voltage220V 实例
    public VoltageAdapter1(Voltage220V voltage220v) {
        this.voltage220V = voltage220v;
    }

    @Override
    public int output5V() {
        int dst = 0;
        if (null != voltage220V) {
            int src = voltage220V.output220V();//获取 220 V 电压
            System.out.println("使用对象适配器，进行适配~~");
            dst = src / 44;
            System.out.println("适配完成，输出的电压为=" + dst);
        }
        return dst;
    }
}
```


##### 对象适配器模式注意事项和细节.

> 1 ) 对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。根据合成复用原则，使用组合替代继承，所以它解决了类适配器必须继承src的局限性问题，也不再要求dst必须是接口。
>
> 2 ) 使用成本更低，更灵活。

#### 接口适配器模式

##### 接口适配器模式介绍

> 1 ) 一些书籍称为：适配器模式(DefaultAdapterPattern)或缺省适配器模式。
> 2 ) 核心思路：当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现(空方法)，那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求
> 3 ) 适用于一个接口不想使用其所有的方法的情况。

##### 接口适配器模式应用实例

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220806165819751.png" alt="image-20220806165819751" style="zoom:60%;" />

```java
package BasicKnowledge.设计模式._2_结构型._1_适配器模式;

public class _3_接口适配器 {
    public static void main(String[] args) {
        AbsAdapter absAdapter = new AbsAdapter() {
            //只需要去覆盖我们 需要使用 接口方法
            @Override
            public void m1() {
                System.out.println("使用了 m1 的方法");
            }
        };
        absAdapter.m1();
    }
}

interface Interface4 {
    void m1();
    void m2();
    void m3();
    void m4();
}

//在AbsAdapter 我们将 Interface4 的方法进行默认实现
abstract class AbsAdapter implements Interface4 {
    //默认实现
    public void m1() {}
    public void m2() {}
    public void m3() {}
    public void m4() {}
}
```

#### SPRINGMVC框架应用的源码剖析

> 1 ) SpringMvc中的 **HandlerAdapter,** 就使用了适配器模式
>
> 2 ) 使用HandlerAdapter 的原因分析:可以看到处理器的类型不同，有多重实现方式，那么调用方式就不是确定的，如果需要直接调用Controller方法，需要调用的时候就得不断是使用if else来进行判断是哪一种子类然后执行。那么如果后面要扩展Controller，就得修改原来的代码，这样违背了OCP原则


### 桥接模式

#### 手机操作问题

> 现在对不同手机类型的不同品牌实现操作编程(比如:开机、关机、上网，打电话等)
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220806172127738.png" alt="image-20220806172127738" style="zoom:50%;" />

#### 传统方案解决手机操作问题

> 传统方法对应的类图
>
> ![image-20220806172153214](https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220806172153214.png)


#### 传统方案解决手机操作问题分析

> 1 ) 扩展性问题(类爆炸)，如果我们再增加手机的样式(旋转式)，就需要增加各个品牌手机的类，同样如果我们增加一个手机品牌，也要在各个手机样式类下增加。
>
>  2 ) 违反了单一职责原则，当我们增加手机样式时，要同时增加所有品牌的手机，这样增加了代码维护成本.
>
>  3 ) 解决方案-使用桥接模式

#### 基本介绍

> 1 ) 桥接模式(Bridge模式)是指：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。
> 3 ) Bridge模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是`把 抽象 与 行为实现 分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展`

#### 类图

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220806172544815.png" alt="image-20220806172544815" style="zoom:50%;" />

> 1 ) Client类：桥接模式的调用者
> 2 ) Abstraction：维护了 Implementor/ 即它的实现类ConcreteImplementorA, 二者是聚合关系,Abstraction充当桥接类
>3 ) RefinedAbstraction： 是 Abstraction 抽象类的子类
4 ) Implementor：行为实现类的接口
5 ) ConcreteImplementorA/B：行为的具体实现类
6 ) 从UML图：这里的抽象类和接口是聚合的关系，其实调用和被调用关系

#### 桥接模式解决手机操作问题

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220806174812198.png" alt="image-20220806174812198" style="zoom:50%;" />

```java
package BasicKnowledge.设计模式._2_结构型._2_桥接模式;

public class _1_桥接模式 {
    public static void main(String[] args) {
        //获取折叠式手机 (样式 +品牌 )
        Phone phone1 = new FoldedPhone(new XiaoMi());
        phone1.open();
        phone1.call();
        phone1.close();

        System.out.println("================================");
        Phone phone2 = new FoldedPhone(new Vivo());
        phone2.open();
        phone2.call();
        phone2.close();

        System.out.println("================================");
        UpRightPhone phone3 = new UpRightPhone(new XiaoMi());
        phone3.open();
        phone3.call();
        phone3.close();

        System.out.println("================================");
        UpRightPhone phone4 = new UpRightPhone(new Vivo());
        phone4.open();
        phone4.call();
        phone4.close();
    }
}

abstract class Phone {

    private Brand brand;
    //构造器
    public Phone(Brand brand) {
        super();
        this.brand = brand;
    }
    protected void open() {
        this.brand.open();
    }

    protected void close() {
        brand.close();
    }

    protected void call() {
        brand.call();
    }

}
class UpRightPhone extends Phone {

    public UpRightPhone(Brand brand) {
        super(brand);
    }
    public void open() {
        super.open();
        System.out.println("直立样式手机 ");
    }

    public void close() {
        super.close();
        System.out.println("直立样式手机 ");
    }

    public void call() {
        super.call();
        System.out.println("直立样式手机 ");
    }
}
//折叠式手机类，继承 抽象类 Phone
class FoldedPhone extends Phone {
    //构造器
    public FoldedPhone(Brand brand) {
        super(brand);
    }

    public void open() {
        super.open();
        System.out.println("折叠样式手机 ");
    }

    public void close() {
        super.close();
        System.out.println("折叠样式手机 ");
    }

    public void call() {
        super.call();
        System.out.println("折叠样式手机 ");
    }
}

// 品牌
interface Brand {
    void open();
    void close();
    void call();
}
class Vivo implements Brand {

    @Override
    public void open() {
        System.out.println("Vivo手机开机 ");
    }

    @Override
    public void close() {
        System.out.println("Vivo手机关机 ");
    }

    @Override
    public void call() {
        System.out.println("Vivo手机打电话 ");
    }
}

class XiaoMi implements Brand {
    @Override
    public void open() {
        System.out.println("小米手机开机 ");
    }

    @Override
    public void close() {
        System.out.println("小米手机关机 ");
    }

    @Override
    public void call() {
        System.out.println("小米手机打电话 ");
    }
}
```

#### 桥接模式在JDBC的源码剖析

> 1 ) Jdbc 的 **Driver** 接口，如果从桥接模式来看，Driver就是一个接口，下面可以有MySQL的Driver，Oracle的
> Driver，这些就可以当做实现接口类
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220808101934540.png" alt="image-20220808101934540" style="zoom:50%;" />

#### 常见的应用场景

> 1 ) -JDBC驱动程序
>
> 2 ) -银行转账系统
>  转账分类: 网上转账，柜台转账，AMT转账
>  转账用户类型：普通用户，银卡用户，金卡用户
>
> 3 ) -消息管理
>  消息类型：即时消息，延时消息
>  消息分类：手机短信，邮件消息，QQ消息.


### 装饰者模式

#### 星巴克咖啡订单项目(咖啡馆)

> 1 ) 咖啡种类/单品咖啡：Espresso(意大利浓咖啡)、ShortBlack、LongBlack(美式咖啡)、Decaf(无因咖啡)
> 2 ) 调料：Milk、Soy(豆浆)、Chocolate
> 3 ) 要求在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便
> 4 ) 使用OO的来计算不同种类咖啡的费用: 客户可以点单品咖啡，也可以单品咖啡+调料组合。

#### 方案 1

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220808102828413.png" alt="image-20220808102828413" style="zoom:50%;" />

##### 问题分析

> 1 ) Drink 是一个抽象类，表示饮料
> 2 ) des就是对咖啡的描述, 比如咖啡的名字
> 3 ) cost() 方法就是计算费用，Drink 类中做成一个抽象方法.
> 4 ) Decaf就是单品咖啡， 继承Drink, 并实现cost
> 5 ) Espress&&Milk 就是单品咖啡+调料， 这个组合很多
> 6 ) 存在问题：这样设计，会有很多类，当我们增加一个单品咖啡，或者一个新的调料，类的数量就会倍增，就会出现类爆炸

#### 方案 2

> 1 ) 前面分析到方案 1 因为咖啡单品+调料组合会造成类的倍增，因此可以做改进，将调料内置到Drink类，这样就不会造成类数量过多。从而提高项目的维护性(如图)
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220808103308556.png" alt="image-20220808103308556" style="zoom:50%;" />
>
> 2 ) 说明:milk,soy,chocolate 可以设计为Boolean，表示是否要添加相应的调料.

##### 问题分析

> 1 ) 方案 2 可以控制类的数量，不至于造成很多的类
> 2 ) 在增加或者删除调料种类时，代码的维护量很大
> 3 ) 考虑到用户可以添加多份 调料时，可以将hasMilk 返回一个对应int
> 4 ) 考虑使用 装饰者 模式


#### 装饰者模式定义

> 1 ) 装饰者模式：动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则 **(ocp** )
> 2 ) 这里提到的动态的将新功能附加到对象和ocp原则，在后面的应用实例上会以代码的形式体现，请同学们注意体会。
>
> 使用场景
>
> - 需要扩展一个类的功能，或给一个类增加附加功能。
> - 需要动态地给一个对象增加功能，这些功能可以再动态地撤销。
> - 需要为一批的兄弟类进行改装或加装功能，当然是首选装饰模式。

#### 装饰者模式原理

> 1 ) 装饰者模式就像打包一个快递
> 	主体：比如：陶瓷、衣服 (Component)// 被装饰者
> 	包装：比如：报纸填充、塑料泡沫、纸板、木板(Decorator)
> 2 ) Component主体：比如类似前面的Drink
> 3 ) ConcreteComponent和Decorator
> 	ConcreteComponent：具体的主体，比如前面的各个单品咖啡
> 	Decorator：装饰者，比如各调料.
> 在如图的Component与ConcreteComponent之间，如果ConcreteComponent类很多,还可以设计一个缓冲层，将共有的部分提取出来，抽象层一个类。
>
> ![image-20220808103954212](https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220808103954212.png)

#### 解决星巴克咖啡订单

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220808104118325.png" alt="image-20220808104118325" style="zoom:67%;" />

#### 装饰者模式下的订单

> 2 份巧克力+一份牛奶的LongBlack
>
> ![image-20220808104153009](https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220808104153009.png)

#### 应用实例

```java
package BasicKnowledge.设计模式._2_结构型._3_装饰者模式;

public class _1_装饰者模式 {
    public static void main(String[] args) {

        // 装饰者模式下的订单： 2 份巧克力+一份牛奶的LongBlack
        // 1. 点一份 LongBlack
        Drink order = new LongBlack();
        System.out.println("费用 1 =" + order.cost());
        System.out.println("描述=" + order.getDes());

        // 2 .order加入一份牛奶
        order = new Milk(order);
        System.out.println("order加入一份牛奶 费用 =" + order.cost());
        System.out.println("order加入一份牛奶 描述 =" + order.getDes());

        // 3 .order加入一份巧克力
        order = new Chocolate(order);
        System.out.println("order加入一份牛奶 加入一份巧克力 费用 =" + order.cost());
        System.out.println("order加入一份牛奶 加入一份巧克力 描述 =" + order.getDes());

        // 3 .order加入一份巧克力
        order = new Chocolate(order);
        System.out.println("order加入一份牛奶 加入 2 份巧克力 费用 =" + order.cost());
        System.out.println("order加入一份牛奶 加入 2 份巧克力 描述 =" + order.getDes());

        System.out.println("===========================");
        Drink order2 = new DeCaf();
        System.out.println("order2 无因咖啡 费用 =" + order2.cost());
        System.out.println("order2 无因咖啡 描述 =" + order2.getDes());

        order2 = new Milk(order2);
        System.out.println("order2 无因咖啡 加入一份牛奶 费用 =" + order2.cost());
        System.out.println("order2 无因咖啡 加入一份牛奶 描述 =" + order2.getDes());
    }
}

abstract class Drink {
    public String des;// 描述
    private float price = 0.0f;

    public String getDes() {
        return des;
    }

    public void setDes(String des) {
        this.des = des;
    }

    public float getPrice() {
        return price;
    }

    public void setPrice(float price) {
        this.price = price;
    }

    //计算费用的抽象方法
    //子类来实现
    public abstract float cost();
}

class Coffee extends Drink {
    @Override
    public float cost() {
        return super.getPrice();
    }
}
class DeCaf extends Coffee {
    public DeCaf() {
        setDes(" 无因咖啡 ");
        setPrice(1.0f);
    }
}
class Espresso extends Coffee {
    public Espresso() {
        setDes(" 意大利咖啡 ");
        setPrice(6.0f);
    }
}
class LongBlack extends Coffee {
    public LongBlack() {
        setDes("longblack");
        setPrice(5.0f);
    }
}
class ShortBlack extends Coffee {
    public ShortBlack() {
        setDes("shortblack");
        setPrice(4.0f);
    }
}

class Decorator extends Drink {
    private Drink obj;
    public Decorator(Drink obj) {//组合
        this.obj = obj;
    }

    @Override
    public float cost() {
        //getPrice 自己价格
        return super.getPrice() + obj.cost();
    }

    @Override
    public String getDes() {
        //obj.getDes() 输出被装饰者的信息
        return des + "" + getPrice() + "&&" + obj.getDes();
    }
}
//具体的Decorator， 这里就是调味品
class Chocolate extends Decorator {
    public Chocolate(Drink obj) {
        super(obj);
        setDes(" 巧克力 ");
        setPrice(3.0f);// 调味品 的价格
    }
}
class Milk extends Decorator {
    public Milk(Drink obj) {
        super(obj);
        setDes(" 牛奶 ");
        setPrice(2.0f);
    }
}
class Soy extends Decorator {
    public Soy(Drink obj) {
        super(obj);
        setDes(" 豆浆 ");
        setPrice(1.5f);
    }
}
```

#### JDK应用的源码分析

> Java的IO结构，FilterInputStream就是一个装饰者
>
> ![image-20220808110126285](https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220808110126285.png)

```java
// 1. InputStream 是抽象类, 类似我们前面讲的 Drink
// 2. FileInputStream 是 InputStream 子类，类似我们前面的 DeCaf,LongBlack
// 3. FilterInputStream 是 InputStream 子类：类似我们前面 的 Decorator 修饰者
// 4. DataInputStream 是 FilterInputStream 子类，具体的修饰者，类似前面的 Milk,Soy 等
// 5. FilterInputStream 类 有 protectedvolatileInputStreamin; 即含被装饰者
// 6  分析得出在jdk 的io体系中，就是使用装饰者模式
DataInputStream dis=new DataInputStream(new FileInputStream("d:\\abc.txt"));
System.out.println(dis.read());
dis.close();
```


### 组合模式

#### 看一个学校院系展示需求

> 编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系。
>
> 如图：
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220808111018088.png" alt="image-20220808111018088" style="zoom:50%;" />

#### 传统方案解决学校院系展示

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220808111136906.png" alt="image-20220808111136906" style="zoom:50%;" />

##### 问题分析

> 1 ) 将学院看做是学校的子类，系是学院的子类，这样实际上是站在组织大小来进行分层次的
>
> 2 ) 实际上我们的要求是 ：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系，因此这种方案，不能很好实现的管理的操作，比如对学院、系的添加，删除，遍历等
>
> 3 ) 解决方案：把学校、院、系都看做是组织结构，他们之间没有继承的关系，而是一个树形结构，可以更好的实现管理操作。 => 组合模式

#### 基本介绍

> 1 ) 组合模式(CompositePattern)，又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示“整体 **-** 部分”的层次关系。
>
>  2 ) 组合模式依据树形结构来组合对象，用来表示部分以及整体层次。
>
>  3 ) 组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象

#### 类图

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220808111751871.png" alt="image-20220808111751871" style="zoom:50%;" />

> 1 ) **Component** :这是组合中对象声明接口，在适当情况下，实现所有类共有的接口默认行为,用于访问和管理Component 子部件,Component 可以是抽象类或者接口
> 2 ) **Leaf:** 在组合中表示叶子节点，叶子节点没有子节点
> 3 ) **Composite** :非叶子节点， 用于存储子部件， 在Component 接口中实现 子部件的相关操作，比如增加(add),删除。

#### 应用实例

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220808111944065.png" alt="image-20220808111944065" style="zoom:50%;" />

```java
package BasicKnowledge.设计模式._2_结构型._4_组合模式;

import java.util.ArrayList;
import java.util.List;

public class _1_组合模式 {
    public static void main(String[] args) {
        //从大到小创建对象 学校
        OrganizationComponent university = new University("清华大学", " 中国顶级大学 ");
        //创建 学院
        OrganizationComponent computerCollege = new College("计算机学院", " 计算机学院 ");
        OrganizationComponent infoEngineercollege = new College("信息工程学院", " 信息工程学院 ");
        //创建各个学院下面的系(专业)
        computerCollege.add(new Department("软件工程", " 软件工程不错 "));
        computerCollege.add(new Department("网络工程", " 网络工程不错 "));
        computerCollege.add(new Department("计算机科学与技术", " 计算机科学与技术是老牌的专业 "));

        // 将学院加入到 学校
        university.add(computerCollege);
        university.add(infoEngineercollege);

        // 将 系 加入到 学院
        infoEngineercollege.add(new Department("通信工程", " 通信工程不好学 "));
        infoEngineercollege.add(new Department("信息工程", " 信息工程好学 "));
        infoEngineercollege.print();
    }
}

class College extends OrganizationComponent {
    //List 中 存放的Department
    List<OrganizationComponent> organizationComponents = new ArrayList<OrganizationComponent>();

    // 构造器
    public College(String name, String des) {
        super(name, des);
    }

    // 重写add
    @Override
    protected void add(OrganizationComponent organizationComponent) {
        // 将来实际业务中，Colleage 的 add 和 Universityadd 不一定完全一样
        organizationComponents.add(organizationComponent);
    }

    // 重写remove
    @Override
    protected void remove(OrganizationComponent organizationComponent) {
        organizationComponents.remove(organizationComponent);
    }

    @Override
    public String getName() {
        return super.getName();
    }

    @Override
    public String getDes() {
        return super.getDes();
    }

    //print方法，就是输出University 包含的学院
    @Override
    protected void print() {
        System.out.println("--------------" + getName() + "--------------");
        //遍历 organizationComponents
        for (OrganizationComponent organizationComponent : organizationComponents) {
            organizationComponent.print();
        }
    }
}

class Department extends OrganizationComponent {
    //没有集合
    public Department(String name, String des) {
        super(name, des);

    }

    //add,remove 就不用写了，因为他是叶子节点
    @Override
    public String getName() {
        return super.getName();
    }

    @Override
    public String getDes() {

        return super.getDes();
    }

    @Override
    protected void print() {
        System.out.println(getName());
    }
}

abstract class OrganizationComponent {
    private String name;// 名字
    private String des;// 说明

    protected void add(OrganizationComponent organizationComponent) {
        throw new UnsupportedOperationException();
    }

    protected void remove(OrganizationComponent organizationComponent) {
        throw new UnsupportedOperationException();
    }

    //构造器
    public OrganizationComponent(String name, String des) {
        super();
        this.name = name;
        this.des = des;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDes() {
        return des;
    }

    public void setDes(String des) {
        this.des = des;
    }

    //方法print, 做成抽象的, 子类都需要实现
    protected abstract void print();
}

//University 就是 Composite, 可以管理College
class University extends OrganizationComponent {
    List<OrganizationComponent> organizationComponents = new ArrayList<OrganizationComponent>();

    // 构造器
    public University(String name, String des) {
        super(name, des);
    }

    // 重写add
    @Override
    protected void add(OrganizationComponent organizationComponent) {
        organizationComponents.add(organizationComponent);
    }

    // 重写remove
    @Override
    protected void remove(OrganizationComponent organizationComponent) {
        organizationComponents.remove(organizationComponent);
    }

    @Override
    public String getName() {
        return super.getName();
    }

    @Override
    public String getDes() {
        return super.getDes();
    }

    //print方法，就是输出University 包含的学院
    @Override
    protected void print() {
        System.out.println("--------------" + getName() + "--------------");
        //遍历 organizationComponents
        for (OrganizationComponent organizationComponent : organizationComponents) {
            organizationComponent.print();
        }
    }
}
```

#### 组合模式在JDK集合的源码分析

> Java的集合类- **HashMap** 就使用了组合模式
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220808113508701.png" alt="image-20220808113508701" style="zoom:50%;" />

#### 组合模式的注意事项和细节

> 1 ) 简化客户端操作。客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题。
>
> 2 ) 具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动.
>
> 3 ) 方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构
>
> 4 ) 需要遍历组织机构，或者处理的对象具有树形结构时, 非常适合使用组合模式.
>
> 5 ) 要求较高的抽象性，如果节点和叶子有很多差异性的话，比如很多方法和属性都不一样，不适合使用组合模式


### 外观模式

#### 影院管理项目

 组建一个家庭影院：

> DVD播放器、投影仪、自动屏幕、环绕立体声、爆米花机,要求完成使用家庭影院的功能，其过程为：
>
> 直接用遥控器：统筹各设备开关
> 开爆米花机
放下屏幕
开投影仪
开音响
开DVD，选dvd
去拿爆米花
调暗灯光
播放
观影结束后，关闭各种设备

#### 传统方式解决影院管理

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220808145921992.png" alt="image-20220808145921992" style="zoom:67%;" />


##### 问题分析

> 1 ) 在ClientTest 的main方法中，创建各个子系统的对象，并直接去调用子系统(对象)相关方法，会造成调用过程混乱，没有清晰的过程
> 2 ) 不利于在ClientTest 中，去维护对子系统的操作
> 3 ) 解决思路：定义一个高层接口，给子系统中的一组接口提供一个一致的界面(比如在高层接口提供四个方法ready,play,pause,end)，用来访问子系统中的一群接口
> 4 ) 也就是说 就是通过定义一个一致的接口(界面类)，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节 => 外观模式

#### 外观模式基本介绍

> 1 ) 外观模式(Facade)，也叫过程模式：外观模式为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
> 2 ) 外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节

#### 类图

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220808150031611.png" alt="image-20220808150031611" style="zoom:50%;" />

> 1 ) 外观类(Facade): 为调用端提供统一的调用接口, 外观类知道哪些子系统负责处理请求,从而将调用端的请求代理给适当子系统对象
> 2 ) 调用者(Client): 外观接口的调用者
> 3 ) 子系统的集合：指模块或者子系统，处理Facade 对象指派的任务，他是功能的实际提供者

#### 应用实例

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220808150206079.png" alt="image-20220808150206079" style="zoom:80%;" />

```java
package BasicKnowledge.设计模式._2_结构型._5_外观模式;

public class _1_外观模式 {
    public static void main(String[] args) {
        //这里直接调用。。 很麻烦
        HomeTheaterFacade homeTheaterFacade = new HomeTheaterFacade();
        homeTheaterFacade.ready();
        homeTheaterFacade.play();
        homeTheaterFacade.end();
    }
}

class HomeTheaterFacade {
    //定义各个子系统对象
    private TheaterLight theaterLight;
    private Popcorn popcorn;
    private Stereo stereo;
    private Projector projector;
    private Screen screen;
    private DVDPlayer dVDPlayer;

    public HomeTheaterFacade() {
        super();
        this.theaterLight = TheaterLight.getInstance();
        this.popcorn = Popcorn.getInstance();
        this.stereo = Stereo.getInstance();
        this.projector = Projector.getInstance();
        this.screen = Screen.getInstance();
        this.dVDPlayer = DVDPlayer.getInstanc();
    }

    //操作分成 4 步
    public void ready() {
        popcorn.on();
        popcorn.pop();
        screen.down();
        projector.on();
        stereo.on();
        dVDPlayer.on();
        theaterLight.dim();
    }

    public void play() {
        dVDPlayer.play();
    }

    public void pause() {
        dVDPlayer.pause();
    }

    public void end() {
        popcorn.off();
        theaterLight.bright();
        screen.up();
        projector.off();
        stereo.off();
        dVDPlayer.off();
    }
}

class Popcorn {
    private static Popcorn instance = new Popcorn();

    public static Popcorn getInstance() {
        return instance;
    }

    public void on() {
        System.out.println("popcornon");
    }

    public void off() {
        System.out.println("popcornff");
    }

    public void pop() {
        System.out.println("popcornispoping ");
    }
}

class Projector {
    private static Projector instance = new Projector();

    public static Projector getInstance() {
        return instance;
    }

    public void on() {
        System.out.println(" Projector   on");
    }

    public void off() {
        System.out.println(" Projector   ff");
    }

    public void focus() {
        System.out.println(" Projector   is Projector    ");
    }
}

class Screen {
    private static Screen instance = new Screen();

    public static Screen getInstance() {
        return instance;
    }

    public void up() {
        System.out.println(" Screen   up");
    }

    public void down() {
        System.out.println(" Screen   down");
    }
}


class Stereo {
    private static Stereo instance = new Stereo();

    public static Stereo getInstance() {
        return instance;
    }

    public void on() {
        System.out.println(" Stereo   on");
    }

    public void off() {
        System.out.println(" Screen   off");
    }

    public void up() {

        System.out.println(" Screen   up");
    }
}

class TheaterLight {
    private static TheaterLight instance = new TheaterLight();

    public static TheaterLight getInstance() {
        return instance;
    }
    public void on() {
        System.out.println(" TheaterLight   on");
    }

    public void off() {
        System.out.println(" TheaterLight   off");
    }

    public void dim() {
        System.out.println(" TheaterLight   dim");
    }

    public void bright() {
        System.out.println(" TheaterLight   bright");
    }
}
class DVDPlayer {
    //使用单例模式, 使用饿汉式
    private static DVDPlayer instance = new DVDPlayer();

    public static DVDPlayer getInstanc() {
        return instance;
    }

    public void on() {
        System.out.println("dvdon");
    }

    public void off() {
        System.out.println("dvdoff");
    }

    public void play() {
        System.out.println("dvdisplaying");
    }

    public void pause() {
        System.out.println("dvdpause");
    }
}
```

#### MYBATIS框架应用的源码分析

> **MyBatis** 中的 **Configuration** 去创建 **MetaObject** 对象使用到外观模式

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220808150756668.png" alt="image-20220808150756668" style="zoom:50%;" />


#### 外观模式的注意事项和细节

> 1 ) 外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复杂性
>
> 2 ) 外观模式对客户端与子系统的耦合关系 - 解耦，让子系统内部的模块更易维护和扩展
>
> 3 ) 通过合理的使用外观模式，可以帮我们更好的划分访问的层次
>
> 4 ) 当系统需要进行分层设计时，可以考虑使用Facade模式
>
> 5 ) 在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口，让新系统与Facade类交互，提高复用性
>
> 6 ) 不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。要以让系统有层次，利于维护为目的。


### 享元模式

#### 展示网站项目需求

> 小型的外包项目，给客户A做一个产品展示网站，客户A的朋友感觉效果不错，也希望做这样的产品展示网站，但是要求都有些不同：
>
>  1 ) 有客户要求以新闻的形式发布
>
>  2 ) 有客户人要求以博客的形式发布
>
>  3 ) 有客户希望以微信公众号的形式发布

#### 传统方案解决网站展现项目

>  1 ) 直接复制粘贴一份，然后根据客户不同要求，进行定制修改
>
>  2 ) 给每个网站租用一个空间
>
>  3 ) 方案设计示意图
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220808151754218.png" alt="image-20220808151754218" style="zoom:50%;" />

##### 问题分析

>  1 ) 需要的网站结构相似度很高，而且都不是高访问量网站，如果分成多个虚拟空间来处理，相当于一个相同网站的实例对象很多，造成服务器的资源浪费
>
>  2 ) 解决思路：整合到一个网站中，共享其相关的代码和数据，对于硬盘、内存、CPU、数据库空间等服务器资源都可以达成共享，减少服务器资源
>
>  3 ) 对于代码来说，由于是一份实例，维护和扩展都更加容易
>
>  4 ) 上面的解决思路就可以使用 享元模式 来解决

#### 基本介绍

> 1 ) 享元模式(FlyweightPattern) 也叫 蝇量模式: 运用共享技术有效地支持大量细粒度的对象
>
> 2 ) 常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个
>
> 3 ) 享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率
>
> 4 ) 享元模式经典的应用场景就是`池技术`了，String常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式

#### 类图

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220808152259460.png" alt="image-20220808152259460" style="zoom:50%;" />

> 1 ) FlyWeight 是抽象的享元角色, 他是产品的抽象类, 同时定义出对象的外部状态和内部状态(后面介绍) 的接口或实现
> 2 ) ConcreteFlyWeight 是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务
> 3 ) UnSharedConcreteFlyWeight 是不可共享的角色，一般不会出现在享元工厂。
> 4 ) FlyWeightFactory 享元工厂类，用于构建一个池容器(集合)， 同时提供从池中获取对象方法

#### 内部状态和外部状态

> 比如围棋、五子棋、跳棋，它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色多一点，所以棋子颜色就是棋子的内部状态；而各个棋子之间的差别就是位置的不同，当我们落子后，落子颜色是定的，但位置是变化的，所以棋子坐标就是棋子的外部状态
>
>  1 ) 享元模式提出了两个要求：细粒度和共享对象。这里就涉及到内部状态和外部状态了，即将对象的信息分为两个部分：内部状态和外部状态
>
>  2 ) 内部状态：对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变
>
>  3 ) 外部状态：对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。
>
>
>  4 ) 举个例子：围棋理论上有 361 个空位可以放棋子，每盘棋都有可能有两三百个棋子对象产生，因为内存空间有限，一台服务器很难支持更多的玩家玩围棋游戏，如果用享元模式来处理棋子，那么棋子对象就可以减少到只有两个实例，这样就很好的解决了对象的开销问题
>

#### 享元模式解决网站展现项目

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220808152908597.png" alt="image-20220808152908597" style="zoom:80%;" />

```java
package BasicKnowledge.设计模式._2_结构型._6_享元模式;

import java.util.HashMap;

class _1_享元模式 {
    public static void main(String[] args) {
        // 创建一个工厂类
        WebSiteFactory factory = new WebSiteFactory();

        // 客户要一个以新闻形式发布的网站
        WebSite webSite1 = factory.getWebSiteCategory ("新闻");
        webSite1 .use(new User("tom"));

        // 客户要一个以博客形式发布的网站
        WebSite webSite2 = factory.getWebSiteCategory ("博客");
        webSite2 .use(new User("jack"));

        // 客户要一个以博客形式发布的网站
        WebSite webSite3 = factory.getWebSiteCategory ("博客");
        webSite3 .use(new User("smith"));

        // 客户要一个以博客形式发布的网站
        WebSite webSite4 = factory.getWebSiteCategory ("博客");
        webSite4 .use(new User("king"));
        System.out.println("网站的分类共=" + factory.getWebSiteCount());
    }
}

abstract class WebSite {
    public abstract void use(User user);//抽象方法
}

//具体网站
class ConcreteWebSite extends WebSite {
    //共享的部分，内部状态
    private String type;//网站发布的形式(类型)

    public ConcreteWebSite(String type) {
        this.type = type;
    }
    @Override
    public void use(User user) {
        System.out.println("网站的发布形式为:" + type + " 在使用中  使用者是" + user.getName());
    }
}

class User {
    private String name;

    public User(String name) {
        super();
        this.name = name;
    }

    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}

// 网站工厂类，根据需要返回压一个网站
class WebSiteFactory {
    //集合， 充当池的作用
    private HashMap<String, ConcreteWebSite > pool=new HashMap<>();

    //根据网站的类型，返回一个网站, 如果没有就创建一个网站，并放入到池中,并返回
    public WebSite getWebSiteCategory(String type) {
        if (!pool.containsKey(type)) {
            //就创建一个网站，并放入到池中
            pool.put(type, new ConcreteWebSite(type));
        }
        return (WebSite) pool.get(type);
    }

    //获取网站分类的总数 (池中有多少个网站类型)
    public int getWebSiteCount() {
        return pool.size();
    }
}
```

#### JDK-Integer类的应用源码分析

> Integer中的享元模式

```java
//如果  Integer .valueOf(x)x在 - 128 - -- 127 直接，就是使用享元模式返回,如果不在范围类，则仍然 new

//小结:
// 1. 在valueOf 方法中，先判断值是否在  Integer Cache 中，如果不在，就创建新的 Integer (new), 否则，就直接从 缓存池返回
// 2 .valueOf 方法，就使用到享元模式
// 3. 如果使用valueOf 方法得到一个 Integer  实例，范围在 - 128 - 127 ，执行速度比 new 快
Integer x = Integer.valueOf(127);// 得到 x实例，类型  Integer 
Integer y = new Integer(127);// 得到 y 实例，类型  Integer 
Integer z = Integer.valueOf(127);//
Integer w = new Integer(127);

System.out.println(x.equals(y));// 大小，true
System.out.println(x == y);// false
System.out.println(x == z);//true
System.out.println(w == x);//false
System.out.println(w == y);//false

Integer x1 = Integer.valueOf(200);
Integer x2 = Integer.valueOf(200);
System.out.println("x1 ==x2 " + (x1 == x2));//false
```

#### 享元模式的注意事项和细节

> 1 ) 在享元模式这样理解，“享”就表示共享，“元”表示对象
>
> 2 ) 系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式
>
> 3 ) 用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用HashMap/HashTable存储
>
> 4 ) 享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率
>
> 5 ) 享元模式提高了系统的复杂度。需要分离出内部状态和外部状态，而外部状态具有固化特性，不应该随着内部状态的改变而改变，这是我们使用享元模式需要注意的地方.
>
> 6 ) 使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制。
>
> 7 ) 享元模式经典的应用场景是需要缓冲池的场景，比如 String常量池、数据库连接池


### 代理模式

#### 基本介绍

> 1 ) 代理模式：为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象，可以在目标对象实现的基础上，扩展目标对象的功能。
>
> 2 ) 被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象
>
> 3 ) 代理模式有不同的形式, 主要有三种 静态代理、动态代理 (JDK代理、接口代理)和 **Cglib** 代理 (可以在内存动态的创建对象，而不需要实现接口， 他是属于动态代理的范畴) 。
>
> 4 ) 代理模式示意图
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220808155426186.png" alt="image-20220808155426186" style="zoom:50%;" />

#### 静态代理

> 静态代理在使用时,需要定义接口或者父类,被代理对象(即目标对象)与代理对象一起实现相同的接口或者是继承相同父类


##### 应用实例

> 1 ) 定义一个接口:ITeacherDao
> 2 ) 目标对象TeacherDAO实现接口ITeacherDAO
> 3 ) 使用静态代理方式,就需要在代理对象TeacherDAOProxy中也实现ITeacherDAO
> 4 ) 调用的时候通过调用代理对象的方法来调用目标对象.
> 5 ) 特别提醒：代理对象与目标对象要实现相同的接口,然后通过调用相同的方法来调用目标对象的方法

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220808160003026.png" alt="image-20220808160003026" style="zoom:50%;" />

```java
package BasicKnowledge.设计模式._2_结构型._7_代理模式;

public class _1_静态代理 {
    public static void main(String[] args) {
        //创建目标对象(被代理对象)
        TeacherDao teacherDao = new TeacherDao();
        //创建代理对象, 同时将被代理对象传递给代理对象
        TeacherDaoProxy teacherDaoProxy = new TeacherDaoProxy(teacherDao);

        //通过代理对象，调用到被代理对象的方法
        //即：执行的是代理对象的方法，代理对象再去调用目标对象的方法
        teacherDaoProxy.teach();
    }
}

//接口
interface ITeacherDao {
    void teach();// 授课的方法
}

class TeacherDao implements ITeacherDao {
    @Override
    public void teach() {
        System.out.println("老师授课中 。。。。。");
    }
}

//代理对象,静态代理
class TeacherDaoProxy implements ITeacherDao {
    private ITeacherDao target;// 目标对象，通过接口来聚合

    //构造器
    public TeacherDaoProxy(ITeacherDao target) {
        this.target = target;
    }

    @Override
    public void teach() {
        System.out.println("开始代理 完成某些操作。。。。。 ");//方法
        target.teach();
        System.out.println("提交。。。。。");//方法
    }
}
```

##### 静态代理优缺点

> 1 ) 优点：在不修改目标对象的功能前提下, 能通过代理对象对目标功能扩展
>
> 2 ) 缺点：因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类，一旦接口增加方法,目标对象与代理对象都要维护

#### 动态代理

##### 动态代理模式的基本介绍

> 1 ) 代理对象,不需要实现接口，但是目标对象要实现接口，否则不能用动态代理
>
> 2 ) 代理对象的生成，是利用JDK的API，动态的在内存中构建代理对象
>
> 3 ) 动态代理也叫做：JDK代理、接口代理

##### JDK中生成代理对象的API

> 1 ) 代理类所在包:java.lang.reflect.Proxy
>
> 2 ) JDK实现代理只需要使用 **newProxyInstance** 方法,但是该方法需要接收三个参数
>
> ```java
> static Object newProxyInstance(ClassLoader loader,
>                                       Class<?>[] interfaces,
>                                       InvocationHandler h)
> ```

##### 动态代理应用实例

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220808161541126.png" alt="image-20220808161541126" style="zoom:50%;" />

```java
package BasicKnowledge.设计模式._2_结构型._7_代理模式;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class _2_动态代理 {
    public static void main(String[] args) {
        //创建目标对象
        ITeacherDao1 target = new TeacherDao1();

        //给目标对象，创建代理对象, 可以转成  ITeacherDao1 
        ITeacherDao1 proxyInstance = (ITeacherDao1) new ProxyFactory(target).getProxyInstance();

        //proxyInstance= class com.sun.proxy.$Proxy 0 内存中动态生成了代理对象
        System.out.println("proxyInstance=" + proxyInstance.getClass());

        //通过代理对象，调用目标对象的方法
        proxyInstance.teach();
        proxyInstance.sayHello("tom");
    }
}

//接口
interface ITeacherDao1 {
    void teach();// 授课方法
    void sayHello(String name);
}

class TeacherDao1 implements ITeacherDao1 {
    @Override
    public void teach() {
        System.out.println("老师授课中");
    }

    @Override
    public void sayHello(String name) {
        System.out.println("hello" + name);
    }
}

class ProxyFactory {
    //维护一个目标对象 , Object 
    private Object target;

    //构造器 ， 对target 进行初始化
    public ProxyFactory(Object target) {
        this.target = target;
    }

    //给目标对象 生成一个代理对象
    public Object getProxyInstance() {
        /**
         * ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定
         * Class<?>[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型
         * InvocationHandler h: 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传入
         */
        return Proxy.newProxyInstance(target.getClass().getClassLoader(),
                target.getClass().getInterfaces(),
                new InvocationHandler() {
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        System.out.println("JDK代理开始~~");
                        //反射机制调用目标对象的方法
                        Object returnVal = method.invoke(target, args);
                        System.out.println("JDK代理提交");
                        return returnVal;
                    }
                });
    }
}
```

#### Cglib代理

##### Cglib代理模式的基本介绍

> 1 ) 静态代理和JDK代理模式都要求目标对象是实现一个接口,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候可使用目标对象子类来实现代理
>
> 2 ) Cglib代理也叫作子类代理 **,** 它是在内存中构建一个子类对象从而实现对目标对象功能扩展, 有些书也将Cglib代理归属到动态代理。
>
> 3 ) Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如SpringAOP，实现方法拦截
>
> 4 ) 在AOP编程中如何选择代理模式：
>
> 1. 目标对象需要实现接口，用JDK代理
> 2. 目标对象不需要实现接口，用Cglib代理
>
> 5 ) Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类


##### Cglib代理模式实现步骤

> 1 ) 需要引入cglib的jar文件
>
> ![image-20220808170237528](https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220808170237528.png)
>
> 2 ) 在内存中动态构建子类，注意代理的类不能为final，否则报错 java.lang.IllegalArgumentException:
> 3 ) 目标对象的方法如果为final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法.

##### Cglib代理模式应用实例

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220808170523790.png" alt="image-20220808170523790" style="zoom:70%;" />

```java
package BasicKnowledge.设计模式._2_结构型._7_代理模式;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class _3_Cglib代理 {
    public static void main(String[] args) {
        //创建目标对象
        TeacherDao2 target = new TeacherDao2();
        //获取到代理对象，并且将目标对象传递给代理对象
        TeacherDao2 proxyInstance = (TeacherDao2) new ProxyFactory(target).getProxyInstance();

        //执行代理对象的方法，触发intecept 方法，从而实现 对目标对象的调用
        String res = proxyInstance.teach();
        System.out.println("res=" + res);
    }
}

class TeacherDao2 {
    public String teach() {
        System.out.println("老师授课中 ， 我是cglib代理，不需要实现接口 ");
        return "hello";
    }
}

class ProxyFactory implements MethodInterceptor {
    //维护一个目标对象
    private Object target;

    //构造器，传入一个被代理的对象
    public ProxyFactory(Object target) {
        this.target = target;
    }

    //返回一个代理对象: 是 target 对象的代理对象
    public Object getProxyInstance() {
// 1. 创建一个工具类
        Enhancer enhancer = new Enhancer();
// 2. 设置父类
        enhancer.setSuperclass(target.getClass());
// 3. 设置回调函数
        enhancer.setCallback(this);
// 4. 创建子类对象，即代理对象
        return enhancer.create();
    }

    //重写 intercept 方法，会调用目标对象的方法
    @Override
    public Object intercept(Object arg0, Method method, Object[] args, Method Proxyarg3) throws Throwable {
        System.out.println("Cglib代理模式 ~~ 开始");
        Object returnVal = method.invoke(target, args);
        System.out.println("Cglib代理模式 ~~ 提交");
        return returnVal;
    }
}
```

#### 几种常见的代理模式介绍

>  1 ) 防火墙代理：内网通过代理穿透防火墙，实现对公网的访问。
>
>  2 ) 缓存代理：比如：当请求图片文件等资源时，先到缓存代理取，如果取到资源则ok,如果取不到资源，再到公网或者数据
> 库取，然后缓存。
>
>  3 ) 远程代理：远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息。
>
>  4 ) 同步代理：主要使用在多线程编程中，完成多线程间同步工作
>

## 行为型

### 模板方法模式

#### 豆浆制作问题

> 编写制作豆浆的程序，说明如下:
>
>  1 ) 制作豆浆的流程 选材--->添加配料--->浸泡--->放到豆浆机打碎
>
>  2 ) 通过添加不同的配料，可以制作出不同口味的豆浆
>
>  3 ) 选材、浸泡和放到豆浆机打碎这几个步骤对于制作每种口味的豆浆都是一样的
>

#### 基本介绍

> 1 ) 模板方法模式(TemplateMethodPattern)，又叫模板模式(Template Pattern)，z在一个抽象类公开定义了执行它的方法的模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。
>
> 2 ) 简单说，模板方法模式 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤

#### 类图

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220808173642595.png" alt="image-20220808173642595" style="zoom:70%;" />

> 1 ) AbstractClass 抽象类，类中实现了模板方法(template)，定义了算法的骨架，具体子类需要去实现 其它的抽象方法operationr 2 , 3 , 4
> 2 ) ConcreteClass 实现抽象方法operationr 2 , 3 , 4 , 以完成算法中特点子类的步骤

#### 模板方法模式解决豆浆制作问题

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220808173852282.png" alt="image-20220808173852282" style="zoom:67%;" />

```java
package BasicKnowledge.设计模式._3_行为型._1_模版方法模式;

public class _1_模版方法模式 {
    public static void main(String[] args) {
        //制作红豆豆浆
        System.out.println("----制作红豆豆浆----");
        SoyaMilk redBeanSoyaMilk = new RedBeanSoyaMilk();
        redBeanSoyaMilk.make();

        System.out.println("----制作花生豆浆----");
        SoyaMilk peanutSoyaMilk = new PeanutSoyaMilk();
        peanutSoyaMilk.make();
    }
}

//抽象类，表示豆浆
abstract class SoyaMilk {
    //模板方法,make, 模板方法可以做成final, 不让子类去覆盖.
    final void make() {
        select();
        addCondiments();
        soak();
        beat();
    }

    //选材料
    void select() {
        System.out.println("第一步：选择好的新鲜黄豆 ");
    }

    //添加不同的配料， 抽象方法, 子类具体实现
    abstract void addCondiments();

    //浸泡
    void soak() {
        System.out.println("第三步， 黄豆和配料开始浸泡， 需要 3 小时 ");
    }

    void beat() {
        System.out.println("第四步：黄豆和配料放到豆浆机去打碎 ");
    }
}
class PeanutSoyaMilk extends SoyaMilk {
    @Override
    void addCondiments() {
        System.out.println("加入上好的花生 ");
    }

}
class RedBeanSoyaMilk extends SoyaMilk {
    @Override
    void addCondiments() {
        System.out.println("加入上好的红豆 ");
    }
}
```

#### 模板方法模式的钩子方法

> 1 ) 在模板方法模式的父类中，我们可以定义一个方法，它默认不做任何事，子类可以视情况要不要覆盖它，该方法称为“钩子”。
>
>  2 ) 还是用上面做豆浆的例子来讲解，比如，我们还希望制作纯豆浆，不添加任何的配料，请使用钩子方法对前面的模板方法进行改造

```java
//抽象类，表示豆浆
abstract class SoyaMilk1 {

    //模板方法,make, 模板方法可以做成final, 不让子类去覆盖.
    final void make() {
        select();
        if (customerWantCondiments()) {
            addCondiments();
        }
        soak();
        beat();
    }

    //选材料
    void select() {
        System.out.println("第一步：选择好的新鲜黄豆 ");
    }

    //添加不同的配料， 抽象方法, 子类具体实现
    abstract void addCondiments();

    //浸泡
    void soak() {
        System.out.println("第三步， 黄豆和配料开始浸泡， 需要 3 小时 ");
    }

    void beat() {
        System.out.println("第四步：黄豆和配料放到豆浆机去打碎 ");
    }

    //钩子方法，决定是否需要添加配料
    boolean customerWantCondiments() {
        return true;
    }

}
```

#### Spring框架应用的源码分析

> SpringIOC容器初始化时运用到的模板方法模式

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220808174744831.png" alt="image-20220808174744831" style="zoom:80%;" />


#### 模板方法模式的注意事项和细节

> 1 ) 基本思想是：算法只存在于一个地方，也就是在父类中，容易修改。需要修改算法时，只要修改父类的模板方法或者已经实现的某些步骤，子类就会继承这些修改
>
> 2 ) 实现了最大化代码复用。父类的模板方法和已实现的某些步骤会被子类继承而直接使用。
>
> 3 ) 既统一了算法，也提供了很大的灵活性。父类的模板方法确保了算法的结构保持不变，同时由子类提供部分步骤的实现。
>
> 4 ) 该模式的不足之处：每一个不同的实现都需要一个子类实现，导致类的个数增加，使得系统更加庞大
>
> 5 ) 一般模板方法都加上final关键字， 防止子类重写模板方法.
>
> 6 ) 模板方法模式使用场景：当要完成在某个过程，该过程要执行一系列步骤 ，这一系列的步骤基本相同，但其
> 个别步骤在实现时 可能不同，通常考虑用模板方法模式来处理


### 命令模式

#### 智能生活项目需求

> 1 ) 我们买了一套智能家电，有照明灯、风扇、冰箱、洗衣机，我们只要在手机上安装app就可以控制对这些家电工作。
> 2 ) 这些智能家电来自不同的厂家，我们不想针对每一种家电都安装一个App，分别控制，我们希望只要一个app就可以控制全部智能家电。
> 3 ) 要实现一个app控制所有智能家电的需要，则每个智能家电厂家都要提供一个统一的接口给app调用，这时就可以考虑使用命令模式。
> 4 ) 命令模式可将“动作的请求者”从“动作的执行者”对象中解耦出来.
> 5 ) 在我们的例子中，动作的请求者是手机app，动作的执行者是每个厂商的一个家电产品

#### 命令模式基本介绍

> 1 ) 命令模式(Command Pattern)：在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计
>
> 2 ) 命令模式使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活，实现解耦。
>
> 3 ) 在命令模式中，会将一个请求封装为一个对象，以便使用不同参数来表示不同的请求(即命名)，同时命令模式也支持可撤销的操作。
>
> 4 ) 通俗易懂的理解：将军发布命令，士兵去执行。其中有几个角色：将军(命令发布者)、士兵(命令的具体执行者)、命令(连接将军和士兵)。
>
> Invoker是调用者(将军)，Receiver是被调用者(士兵)，MyCommand是命令，实现了Command接口，持
> 有接收对象

#### 命令模式的原理类图

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220808181245850.png" alt="image-20220808181245850" style="zoom:67%;" />

> 1 ) Invoker 是调用者角色
> 2 ) Command: 是命令角色，需要执行的所有命令都在这里，可以是接口或抽象类
> 3 ) Receiver: 接受者角色，知道如何实施和执行一个请求相关的操作
> 4 ) ConcreteCommand: 将一个接受者对象与一个动作绑定，调用接受者相应的操作，实现execute

#### 命令模式解决智能生活项目

 应用实例要求

 1 ) 编写程序，使用命令模式 完成前面的智能家电项目

 2 ) 思路分析和图解


 3 ) 代码实现

```
command.zip
```
packagecom.atguigu.command;

publicclassClient{

```
publicstaticvoidmain(String[]args){
//TODOAuto-generatedmethodstub
```
 //使用命令设计模式，完成通过遥控器，对电灯的操作

 //创建电灯的对象(接受者)

```
LightReceiverlightReceiver=newLightReceiver();
```
 //创建电灯相关的开关命令

```
LightOnCommandlightOnCommand=newLightOnCommand(lightReceiver);
```

LightOffCommandlightOffCommand=newLightOffCommand(lightReceiver);

 //需要一个遥控器

RemoteControllerremoteController=newRemoteController();

//给我们的遥控器设置命令, 比如 no= 0 是电灯的开和关的操作
remoteController.setCommand( 0 ,lightOnCommand,lightOffCommand);

System.out.println("--------按下灯的开按钮-----------");
remoteController.onButtonWasPushed( 0 );
System.out.println("--------按下灯的关按钮-----------");
remoteController.offButtonWasPushed( 0 );
System.out.println("--------按下撤销按钮-----------");
remoteController.undoButtonWasPushed();

System.out.println("=========使用遥控器操作电视机==========");

TVReceivertvReceiver=newTVReceiver();

TVOffCommandtvOffCommand=newTVOffCommand(tvReceiver);
TVOnCommandtvOnCommand=newTVOnCommand(tvReceiver);

//给我们的遥控器设置命令, 比如 no= 1 是电视机的开和关的操作
remoteController.setCommand( 1 ,tvOnCommand,tvOffCommand);


```
System.out.println("--------按下电视机的开按钮-----------");
remoteController.onButtonWasPushed( 1 );
System.out.println("--------按下电视机的关按钮-----------");
remoteController.offButtonWasPushed( 1 );
System.out.println("--------按下撤销按钮-----------");
remoteController.undoButtonWasPushed();
```
 }

 }

packagecom.atguigu.command;

 //创建命令接口

publicinterfaceCommand{

//执行动作(操作)
publicvoidexecute();
//撤销动作(操作)
publicvoidundo();
}

packagecom.atguigu.command;

publicclassLightOffCommandimplementsCommand{


```
// 聚合LightReceiver
```
```
LightReceiverlight;
```
 // 构造器

```
publicLightOffCommand(LightReceiverlight){
super();
this.light=light;
}
```
```
@Override
publicvoidexecute(){
//TODOAuto-generatedmethodstub
// 调用接收者的方法
light.off();
}
```
@Override
publicvoidundo(){
//TODOAuto-generatedmethodstub
// 调用接收者的方法
light.on();
}
}


packagecom.atguigu.command;

publicclassLightOnCommandimplementsCommand{

```
//聚合LightReceiver
```
```
LightReceiverlight;
```
 //构造器

```
publicLightOnCommand(LightReceiverlight){
super();
this.light=light;
}
```
```
@Override
publicvoidexecute(){
//TODOAuto-generatedmethodstub
//调用接收者的方法
light.on();
}
```
```
@Override
publicvoidundo(){
//TODOAuto-generatedmethodstub
```

 //调用接收者的方法

```
light.off();
}
```
 }

packagecom.atguigu.command;

publicclassLightReceiver{

```
publicvoidon(){
System.out.println("电灯打开了");
}
```
publicvoidoff(){
System.out.println("电灯关闭了");
}
}

packagecom.atguigu.command;

/**
* 没有任何命令，即空执行: 用于初始化每个按钮, 当调用空命令时，对象什么都不做
* 其实，这样是一种设计模式, 可以省掉对空判断
*@authorAdministrator
*


 */

publicclassNoCommandimplementsCommand{

```
@Override
publicvoidexecute(){
//TODOAuto-generatedmethodstub
```
 }

```
@Override
publicvoidundo(){
//TODOAuto-generatedmethodstub
```
 }

 }

packagecom.atguigu.command;

publicclassRemoteController{

 // 开 按钮的命令数组

```
Command[]onCommands;
Command[]offCommands;
```
 // 执行撤销的命令


CommandundoCommand;

 // 构造器，完成对按钮初始化

publicRemoteController(){

```
onCommands=newCommand[ 5 ];
offCommands=newCommand[ 5 ];
```
for(inti= 0 ;i< 5 ;i++){
onCommands[i]=newNoCommand();
offCommands[i]=newNoCommand();
}
}

 // 给我们的按钮设置你需要的命令

publicvoidsetCommand(intno,CommandonCommand,CommandoffCommand){
onCommands[no]=onCommand;
offCommands[no]=offCommand;
}

// 按下开按钮
publicvoidonButtonWasPushed(intno){//no 0
// 找到你按下的开的按钮， 并调用对应方法
onCommands[no].execute();
// 记录这次的操作，用于撤销


```
undoCommand=onCommands[no];
```
 }

 // 按下开按钮

```
publicvoidoffButtonWasPushed(intno){//no 0
// 找到你按下的关的按钮， 并调用对应方法
offCommands[no].execute();
// 记录这次的操作，用于撤销
undoCommand=offCommands[no];
```
```
}
```
 // 按下撤销按钮

```
publicvoidundoButtonWasPushed(){
undoCommand.undo();
}
```
 }

packagecom.atguigu.command;

publicclassTVOffCommandimplementsCommand{

```
// 聚合TVReceiver
```

```
TVReceivertv;
```
 // 构造器

```
publicTVOffCommand(TVReceivertv){
super();
this.tv=tv;
}
```
```
@Override
publicvoidexecute(){
//TODOAuto-generatedmethodstub
// 调用接收者的方法
tv.off();
}
```
@Override
publicvoidundo(){
//TODOAuto-generatedmethodstub
// 调用接收者的方法
tv.on();
}
}

packagecom.atguigu.command;

publicclassTVOnCommandimplementsCommand{


```
// 聚合TVReceiver
```
```
TVReceivertv;
```
 // 构造器

```
publicTVOnCommand(TVReceivertv){
super();
this.tv=tv;
}
```
```
@Override
publicvoidexecute(){
//TODOAuto-generatedmethodstub
// 调用接收者的方法
tv.on();
}
```
@Override
publicvoidundo(){
//TODOAuto-generatedmethodstub
// 调用接收者的方法
tv.off();
}
}


packagecom.atguigu.command;

publicclassTVReceiver{

```
publicvoidon(){
System.out.println("电视机打开了");
}
```
publicvoidoff(){
System.out.println("电视机关闭了");
}
}

#### Spring框架JdbcTemplate应用的源码分析.

> Spring框架的JdbcTemplate就使用到了命令模式
> 

 3 ) 模式角色分析说明


 StatementCallback 接口 ,类似命令接口(Command)
 classQueryStatementCallbackimplementsStatementCallback<T>,SqlProvider, 匿名内部类， 实现了命令接口，
同时也充当命令接收者
 命令调用者 是 JdbcTemplate, 其中execute(StatementCallback<T>action) 方法中，调用action.doInStatement 方
法. 不同的 实现 StatementCallback 接口的对象，对应不同的doInStatemnt 实现逻辑
 另外实现 StatementCallback 命令接口的子类还有 QueryStatementCallback、

#### 命令模式的注意事项和细节

1 ) 将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要调用命令对象的execute()方
法就可以让接收者工作，而不必知道具体的接收者对象是谁、是如何实现的，命令对象会负责让接收者执行请
求的动作，也就是说：”请求发起者”和“请求执行者”之间的解耦是通过命令对象实现的，命令对象起到了
纽带桥梁的作用。
2 ) 容易设计一个命令队列。只要把命令对象放到列队，就可以多线程的执行命令
3 ) 容易实现对请求的撤销和重做
4 ) 命令模式不足：可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这点在在使用的时候要注意
5 ) 空命令也是一种设计模式，它为我们省去了判空的操作。在上面的实例中，如果没有用空命令，我们每按下一
个按键都要判空，这给我们编码带来一定的麻烦。
6 ) 命令模式经典的应用场景：界面的一个按钮都是一条命令、模拟CMD(DOS命令)订单的撤销/恢复、触发-
反馈机制


## 第 18 章 访问者模式

### 18 1 测评系统的需求

 完成测评系统需求

 1 ) 将观众分为男人和女人，对歌手进行测评，当看完某个歌手表演后，得到他们对该歌手不同的评价(评价 有不

 同的种类，比如 成功、失败 等)

 2 ) 传统方案

### 18 2 传统方式的问题分析

1 ) 如果系统比较小，还是ok的，但是考虑系统增加越来越多新的功能时，对代码改动较大，违反了ocp原则，不
利于维护
2 ) 扩展性不好，比如 增加了 新的人员类型，或者管理方法，都不好做
3 ) 引出我们会使用新的设计模式 – 访问者模式

### 18 3 访问者模式基本介绍

1 ) 访问者模式(VisitorPattern)，封装一些作用于某种数据结构的各元素的操作，它可以在不改变数据结构的前
提下定义作用于这些元素的新的操作。
2 ) 主要将数据结构与数据操作分离，解决 数据结构和操作耦合性问题
3 ) 访问者模式的基本工作原理是：在被访问的类里面加一个对外提供接待访问者的接口

 4 ) 访问者模式主要应用场景是：需要对一个对象结构中的对象进行很多不同操作(这些操作彼此没有关联)，同时


 需要避免让这些操作"污染"这些对象的类，可以选用访问者模式解决

### 18 4 访问者模式的原理类图

  对原理类图的说明-

 即(访问者模式的角色及职责)

1 ) Visitor是抽象访问者，为该对象结构中的ConcreteElement的每一个类声明一个visit操作
2 ) ConcreteVisitor ：是一个具体的访问值 实现每个有Visitor 声明的操作，是每个操作实现的部分.
3 ) ObjectStructure 能枚举它的元素， 可以提供一个高层的接口，用来允许访问者访问元素
4 ) Element 定义一个accept 方法，接收一个访问者对象
5 ) ConcreteElement 为具体元素，实现了accept 方法


### 18 5 访问者模式应用实例

 应用实例要求

 1 ) 将人分为男人和女人，对歌手进行测评，当看完某个歌手表演后，得到他们对该歌手不同的评价(评价 有不同

 的种类，比如 成功、失败 等)，请使用访问者模式来说实现

 2 ) 思路分析和图解(类图)

 3 ) 代码实现

```
visitor.zip
```
packagecom.atguigu.visitor;

publicabstractclassAction{

 //得到男性 的测评

```
publicabstractvoidgetManResult(Manman);
```

 //得到女的 测评

publicabstractvoidgetWomanResult(Womanwoman);
}

packagecom.atguigu.visitor;

publicclassClient{

```
publicstaticvoidmain(String[]args){
//TODOAuto-generatedmethodstub
//创建ObjectStructure
ObjectStructureobjectStructure=newObjectStructure();
```
```
objectStructure.attach(newMan());
objectStructure.attach(newWoman());
```
 //成功

```
Successsuccess=newSuccess();
objectStructure.display(success);
```
```
System.out.println("===============");
Failfail=newFail();
objectStructure.display(fail);
```

```
System.out.println("=======给的是待定的测评========");
```
```
Waitwait=newWait();
objectStructure.display(wait);
}
```
}

packagecom.atguigu.visitor;

publicclassFailextendsAction{

```
@Override
publicvoidgetManResult(Manman){
//TODOAuto-generatedmethodstub
System.out.println("男人给的评价该歌手失败 !");
}
```
```
@Override
publicvoidgetWomanResult(Womanwoman){
//TODOAuto-generatedmethodstub
System.out.println("女人给的评价该歌手失败 !");
}
```
 }


packagecom.atguigu.visitor;

publicclassManextendsPerson{

```
@Override
publicvoidaccept(Actionaction){
//TODOAuto-generatedmethodstub
action.getManResult(this);
}
```
 }

packagecom.atguigu.visitor;

importjava.util.LinkedList;
importjava.util.List;

//数据结构，管理很多人(Man,Woman)
publicclassObjectStructure{

 //维护了一个集合

```
privateList<Person>persons=newLinkedList<>();
```
```
//增加到list
publicvoidattach(Personp){
persons.add(p);
```

 }

 //移除

```
publicvoiddetach(Personp){
persons.remove(p);
}
```
//显示测评情况
publicvoiddisplay(Actionaction){
for(Personp:persons){
p.accept(action);
}
}
}

packagecom.atguigu.visitor;

publicabstractclassPerson{

 //提供一个方法，让访问者可以访问

publicabstractvoidaccept(Actionaction);
}

packagecom.atguigu.visitor;

publicclassSuccessextendsAction{


```
@Override
publicvoidgetManResult(Manman){
//TODOAuto-generatedmethodstub
System.out.println("男人给的评价该歌手很成功 !");
}
```
```
@Override
publicvoidgetWomanResult(Womanwoman){
//TODOAuto-generatedmethodstub
System.out.println("女人给的评价该歌手很成功 !");
}
```
 }

packagecom.atguigu.visitor;

publicclassWaitextendsAction{

```
@Override
publicvoidgetManResult(Manman){
//TODOAuto-generatedmethodstub
System.out.println("男人给的评价是该歌手待定 ");
}
```
```
@Override
publicvoidgetWomanResult(Womanwoman){
```

```
//TODOAuto-generatedmethodstub
System.out.println("女人给的评价是该歌手待定 ");
}
```
 }

packagecom.atguigu.visitor;

 //说明

// 1. 这里我们使用到了双分派, 即首先在客户端程序中，将具体状态作为参数传递Woman中(第一次分派)
// 2. 然后Woman 类调用作为参数的 "具体方法" 中方法getWomanResult, 同时将自己(this)作为参数
// 传入，完成第二次的分派
publicclassWomanextendsPerson{

```
@Override
publicvoidaccept(Actionaction){
//TODOAuto-generatedmethodstub
action.getWomanResult(this);
}
```
 }

 4 ) 应用案例的小结-双分派

 - 上面提到了双分派，所谓双分派是指不管类怎么变化，我们都能找到期望的方法运行。双分派意味着得到执

 行的操作取决于请求的种类和两个接收者的类型


- 以上述实例为例，假设我们要添加一个 **Wait** 的状态类，考察 **Man** 类和 **Woman** 类的反应，由于使用了双分
派，只需增加一个Action子类即可在客户端调用即可，不需要改动任何其他类的代码。

### 18 6 访问者模式的注意事项和细节

  优点

 1 ) 访问者模式符合单一职责原则、让程序具有优秀的扩展性、灵活性非常高

 2 ) 访问者模式可以对功能进行统一，可以做报表、UI、拦截器与过滤器，适用于数据结构相对稳定的系统

  缺点

 1 ) 具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的, 这样造

 成了具体元素变更比较困难

 2 ) 违背了依赖倒转原则。访问者依赖的是具体元素，而不是抽象元素

 3 ) 因此，如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么访问者模式就是比较合适的.


## 第 19 章迭代器模式

### 19 1 看一个具体的需求

 编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院，

 一个学院有多个系。如图：

### 19 2 传统的设计方案(类图).

### 19 3 传统的方式的问题分析

 1 ) 将学院看做是学校的子类，系是学院的子类，这样实际上是站在组织大小来进行分层次的

 2 ) 实际上我们的要求是 ：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系，因

 此这种方案，不能很好实现的遍历的操作

 3 ) 解决方案：=>迭代器模式

### 19 4 迭代器模式基本介绍

 基本介绍


1 ) 迭代器模式(IteratorPattern)是常用的设计模式，属于行为型模式
2 ) 如果我们的集合元素是用不同的方式实现的，有数组，还有java的集合类，或者还有其他方式，当客户端要遍
历这些集合元素的时候就要使用多种遍历方式，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决。
3 ) 迭代器模式，提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表
示，即：不暴露其内部的结构。

### 19 5 迭代器模式的原理类图

  对原理类图的说明-即(迭代器模式的角色及职责)

1 ) Iterator ： 迭代器接口，是系统提供，含义 hasNext,next,remove
2 ) ConcreteIterator: 具体的迭代器类，管理迭代
3 ) Aggregate:一个统一的聚合接口， 将客户端和具体聚合解耦
4 ) ConcreteAggreage: 具体的聚合持有对象集合， 并提供一个方法，返回一个迭代器， 该迭代器可以正确遍历
集合
5 ) Client:客户端， 通过Iterator 和 Aggregate 依赖子类

### 19 6 迭代器模式应用实例


 1 ) 应用实例要求

 编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院，

 一个学院有多个系。

 2 ) 设计思路分析

 3 ) 代码实现

```
iterator.zip
```
packagecom.atguigu.iterator;

importjava.util.ArrayList;
importjava.util.List;


publicclassClient{

```
publicstaticvoidmain(String[]args){
//TODOAuto-generatedmethodstub
//创建学院
List<College>collegeList=newArrayList<College>();
```
```
ComputerCollegecomputerCollege=newComputerCollege();
InfoCollegeinfoCollege=newInfoCollege();
```
```
collegeList.add(computerCollege);
//collegeList.add(infoCollege);
```
```
OutPutImploutPutImpl=newOutPutImpl(collegeList);
outPutImpl.printCollege();
}
```
 }

packagecom.atguigu.iterator;

importjava.util.Iterator;

publicinterfaceCollege{


```
publicStringgetName();
```
 //增加系的方法

```
publicvoidaddDepartment(Stringname,Stringdesc);
```
 //返回一个迭代器,遍历

publicIterator createIterator();
}

packagecom.atguigu.iterator;

importjava.util.Iterator;

publicclassComputerCollegeimplementsCollege{

```
Department[]departments;
intnumOfDepartment= 0 ;// 保存当前数组的对象个数
```
```
publicComputerCollege(){
departments=newDepartment[ 5 ];
addDepartment("Java专业","Java专业 ");
addDepartment("PHP专业","PHP专业 ");
addDepartment("大数据专业"," 大数据专业 ");
```
 }


```
@Override
publicStringgetName(){
//TODOAuto-generatedmethodstub
return"计算机学院";
}
```
```
@Override
publicvoidaddDepartment(Stringname,Stringdesc){
//TODOAuto-generatedmethodstub
Departmentdepartment=newDepartment(name,desc);
departments[numOfDepartment]=department;
numOfDepartment+= 1 ;
}
```
```
@Override
publicIteratorcreateIterator(){
//TODOAuto-generatedmethodstub
returnnewComputerCollegeIterator(departments);
}
```
 }

packagecom.atguigu.iterator;


importjava.util.Iterator;

publicclassComputerCollegeIteratorimplementsIterator{

```
//这里我们需要Department 是以怎样的方式存放=>数组
Department[]departments;
intposition= 0 ;//遍历的位置
```
```
publicComputerCollegeIterator(Department[]departments){
this.departments=departments;
}
```
```
//判断是否还有下一个元素
@Override
publicbooleanhasNext(){
//TODOAuto-generatedmethodstub
if(position>=departments.length||departments[position]==null){
returnfalse;
}else{
```
```
returntrue;
}
```

 }

```
@Override
publicObjectnext(){
//TODOAuto-generatedmethodstub
Departmentdepartment=departments[position];
position+= 1 ;
returndepartment;
}
```
 //删除的方法，默认空实现

```
publicvoidremove(){
```
 }

 }

packagecom.atguigu.iterator;

 //系

publicclassDepartment{

```
privateStringname;
privateStringdesc;
publicDepartment(Stringname,Stringdesc){
super();
```

```
this.name=name;
this.desc=desc;
}
publicStringgetName(){
returnname;
}
publicvoidsetName(Stringname){
this.name=name;
}
publicStringgetDesc(){
returndesc;
}
publicvoidsetDesc(Stringdesc){
this.desc=desc;
}
```
 }

packagecom.atguigu.iterator;

importjava.util.Iterator;
importjava.util.List;

publicclassInfoColleageIteratorimplementsIterator{


List<Department>departmentList;// 信息工程学院是以List方式存放系
intindex=- 1 ;//索引

publicInfoColleageIterator(List<Department>departmentList){
this.departmentList=departmentList;
}

//判断list中还有没有下一个元素
@Override
publicbooleanhasNext(){
//TODOAuto-generatedmethodstub
if(index>=departmentList.size()- 1 ){
returnfalse;
}else{
index+= 1 ;
returntrue;
}
}

@Override
publicObjectnext(){
//TODOAuto-generatedmethodstub
returndepartmentList.get(index);


 }

```
//空实现remove
publicvoidremove(){
```
 }

 }

packagecom.atguigu.iterator;

importjava.util.ArrayList;
importjava.util.Iterator;
importjava.util.List;

publicclassInfoCollegeimplementsCollege{

```
List<Department>departmentList;
```
```
publicInfoCollege(){
departmentList=newArrayList<Department>();
addDepartment("信息安全专业"," 信息安全专业 ");
addDepartment("网络安全专业"," 网络安全专业 ");
addDepartment("服务器安全专业"," 服务器安全专业 ");
}
```

```
@Override
publicStringgetName(){
//TODOAuto-generatedmethodstub
return"信息工程学院";
}
```
```
@Override
publicvoidaddDepartment(Stringname,Stringdesc){
//TODOAuto-generatedmethodstub
Departmentdepartment=newDepartment(name,desc);
departmentList.add(department);
}
```
```
@Override
publicIteratorcreateIterator(){
//TODOAuto-generatedmethodstub
returnnewInfoColleageIterator(departmentList);
}
```
 }

packagecom.atguigu.iterator;

importjava.util.Iterator;
importjava.util.List;


publicclassOutPutImpl{

 //学院集合

```
List<College>collegeList;
```
```
publicOutPutImpl(List<College>collegeList){
```
```
this.collegeList=collegeList;
}
//遍历所有学院,然后调用printDepartment 输出各个学院的系
publicvoidprintCollege(){
```
```
//从collegeList 取出所有学院,Java 中的 List 已经实现Iterator
Iterator<College>iterator=collegeList.iterator();
```
```
while(iterator.hasNext()){
//取出一个学院
Collegecollege=iterator.next();
System.out.println("==="+college.getName()+"=====");
printDepartment(college.createIterator());//得到对应迭代器
}
}
```
 //输出 学院输出 系


publicvoidprintDepartment(Iteratoriterator){
while(iterator.hasNext()){
Departmentd=(Department)iterator.next();
System.out.println(d.getName());
}
}
}

### 19 7 迭代器模式在JDK-ARRAYLIST集合应用的源码分析

1 ) JDK的ArrayList 集合中就使用了迭代器模式
2 ) 代码分析+类图+说明


 3 ) 对类图的角色分析和说明

 内部类Itr 充当具体实现迭代器Iterator的类， 作为ArrayList 内部类
 List 就是充当了聚合接口，含有一个iterator() 方法，返回一个迭代器对象
 ArrayList 是实现聚合接口List 的子类，实现了iterator()
 Iterator 接口系统提供
 迭代器模式解决了 不同集合(ArrayList,LinkedList) 统一遍历问题

### 19 8 迭代器模式的注意事项和细节

  优点

 1 ) 提供一个统一的方法遍历对象，客户不用再考虑聚合的类型，使用一种方法就可以遍历对象了。

 2 ) 隐藏了聚合的内部结构，客户端要遍历聚合的时候只能取到迭代器，而不会知道聚合的具体组成。

 3 ) 提供了一种设计思想，就是一个类应该只有一个引起变化的原因(叫做单一责任原则)。在聚合类中，我们把

 迭代器分开，就是要把管理对象集合和遍历对象集合的责任分开，这样一来集合改变的话，只影响到聚合对象。

 而如果遍历方式改变的话，只影响到了迭代器。

 4 ) 当要展示一组相似对象，或者遍历一组相同对象时使用, 适合使用迭代器模式


  缺点

 每个聚合对象都要一个迭代器，会生成多个迭代器不好管理类


## 第 20 章 观察者模式

### 20 1 天气预报项目需求,具体要求如下：

 1 ) 气象站可以将每天测量到的温度，湿度，气压等等以公告的形式发布出去(比如发布到自己的网站或第三方)。

 2 ) 需要设计开放型 API ，便于其他第三方也能接入气象站获取数据。

 3 ) 提供温度、气压和湿度的接口

 4 ) 测量数据更新时，要能实时的通知给第三方

### 20 2 天气预报设计方案 1 - 普通方案.

#### 20 2 1 WeatherData类

  传统的设计方案


  代码实现

```
observer.zip
```
packagecom.atguigu.observer;

publicclassClient{
publicstaticvoidmain(String[]args){
//创建接入方 currentConditions
CurrentConditionscurrentConditions=newCurrentConditions();
//创建WeatherData 并将 接入方 currentConditions传递到 WeatherData中
WeatherDataweatherData=newWeatherData(currentConditions);

 //更新天气情况

```
weatherData.setData( 30 , 150 , 40 );
```
 //天气情况变化

```
System.out.println("============天气情况变化=============");
weatherData.setData( 40 , 160 , 20 );
```
 }

 }

packagecom.atguigu.observer;

 /**


 * 显示当前天气情况(可以理解成是气象站自己的网站)

*@authorAdministrator
*
*/
publicclassCurrentConditions{
// 温度，气压，湿度
privatefloattemperature;
privatefloatpressure;
privatefloathumidity;

```
//更新 天气情况，是由WeatherData 来调用，我使用推送模式
publicvoidupdate(floattemperature,floatpressure,floathumidity){
this.temperature=temperature;
this.pressure=pressure;
this.humidity=humidity;
display();
}
```
 //显示

publicvoiddisplay(){
System.out.println("***TodaymTemperature:"+temperature+"***");
System.out.println("***TodaymPressure:"+pressure+"***");
System.out.println("***TodaymHumidity:"+humidity+"***");
}
}


packagecom.atguigu.observer;

 /**

 * 类是核心

 * 1. 包含最新的天气情况信息

* 2. 含有 CurrentConditions对象
* 3. 当数据有更新时，就主动的调用 CurrentConditions对象update方法(含 display), 这样他们(接入方)就看
到最新的信息
*@authorAdministrator
*
*/
publicclassWeatherData{
privatefloattemperatrue;
privatefloatpressure;
privatefloathumidity;
privateCurrentConditionscurrentConditions;
//加入新的第三方

```
publicWeatherData(CurrentConditionscurrentConditions){
this.currentConditions=currentConditions;
}
```
```
publicfloatgetTemperature(){
returntemperatrue;
}
```

```
publicfloatgetPressure(){
returnpressure;
}
```
```
publicfloatgetHumidity(){
returnhumidity;
}
```
```
publicvoiddataChange(){
//调用 接入方的 update
currentConditions.update(getTemperature(),getPressure(),getHumidity());
}
```
//当数据有更新时，就调用 setData
publicvoidsetData(floattemperature,floatpressure,floathumidity){
this.temperatrue=temperature;
this.pressure=pressure;
this.humidity=humidity;
//调用dataChange， 将最新的信息 推送给 接入方 currentConditions
dataChange();
}
}

  问题分析

 1 ) 其他第三方接入气象站获取数据的问题


 2 ) 无法在运行时动态的添加第三方 (新浪网站)

3 ) 违反ocp原则=>观察者模式
//在WeatherData中，当增加一个第三方，都需要创建一个对应的第三方的公告板对象，并加入到dataChange, 不
利于维护，也不是动态加入
publicvoiddataChange(){
currentConditions.update(getTemperature(),getPressure(),getHumidity());
}

### 20 3 观察者模式原理

 1 ) 观察者模式类似订牛奶业务

2 ) 奶站/气象局：Subject
3 ) 用户/第三方网站：Observer

 Subject：登记注册、移除和通知
1 ) registerObserver 注册
2 ) removeObserver 移除
3 ) notifyObservers() 通知所有的注册的用户，根据不同需求，可以是更新数据，让用户来取，也可能是实施推送，
看具体需求定
 Observer：接收输入

 观察者模式：对象之间多对一依赖的一种设计方案，被依赖的对象为Subject，依赖的对象为Observer，Subject
通知Observer变化,比如这里的奶站是Subject，是 1 的一方。用户时Observer，是多的一方。

### 20 4 观察者模式解决天气预报需求

#### 20 4 1 类图说明.


#### 20 4 2 代码实现.

```
improve.zip
```
packagecom.atguigu.observer.improve;

publicclassBaiduSiteimplementsObserver{

 // 温度，气压，湿度

```
privatefloattemperature;
privatefloatpressure;
privatefloathumidity;
```
```
// 更新 天气情况，是由WeatherData 来调用，我使用推送模式
publicvoidupdate(floattemperature,floatpressure,floathumidity){
this.temperature=temperature;
```

```
this.pressure=pressure;
this.humidity=humidity;
display();
}
```
 // 显示

```
publicvoiddisplay(){
System.out.println("===百度网站====");
System.out.println("***百度网站 气温 :"+temperature+"***");
System.out.println("***百度网站 气压:"+pressure+"***");
System.out.println("***百度网站 湿度:"+humidity+"***");
}
```
 }

packagecom.atguigu.observer.improve;

publicclassClient{

```
publicstaticvoidmain(String[]args){
//TODOAuto-generatedmethodstub
//创建一个WeatherData
WeatherDataweatherData=newWeatherData();
```
 //创建观察者

```
CurrentConditionscurrentConditions=newCurrentConditions();
```

```
BaiduSitebaiduSite=newBaiduSite();
```
```
//注册到weatherData
weatherData.registerObserver(currentConditions);
weatherData.registerObserver(baiduSite);
```
```
//测试
System.out.println("通知各个注册的观察者, 看看信息");
weatherData.setData( 10 f, 100 f, 30. 3 f);
```
```
weatherData.removeObserver(currentConditions);
//测试
System.out.println();
System.out.println("通知各个注册的观察者, 看看信息");
weatherData.setData( 10 f, 100 f, 30. 3 f);
}
```
 }

packagecom.atguigu.observer.improve;

publicclassCurrentConditionsimplementsObserver{

 // 温度，气压，湿度

```
privatefloattemperature;
```

```
privatefloatpressure;
privatefloathumidity;
```
```
// 更新 天气情况，是由WeatherData 来调用，我使用推送模式
publicvoidupdate(floattemperature,floatpressure,floathumidity){
this.temperature=temperature;
this.pressure=pressure;
this.humidity=humidity;
display();
}
```
// 显示
publicvoiddisplay(){
System.out.println("***TodaymTemperature:"+temperature+"***");
System.out.println("***TodaymPressure:"+pressure+"***");
System.out.println("***TodaymHumidity:"+humidity+"***");
}
}

packagecom.atguigu.observer.improve;

 //观察者接口，有观察者来实现

publicinterfaceObserver{

publicvoidupdate(floattemperature,floatpressure,floathumidity);
}


packagecom.atguigu.observer.improve;

//接口, 让WeatherData 来实现
publicinterfaceSubject{

publicvoidregisterObserver(Observero);
publicvoidremoveObserver(Observero);
publicvoidnotifyObservers();
}

packagecom.atguigu.observer.improve;

importjava.util.ArrayList;

 /**

 * 类是核心

 * 1. 包含最新的天气情况信息

* 2. 含有 观察者集合，使用ArrayList管理
* 3. 当数据有更新时，就主动的调用 ArrayList, 通知所有的(接入方)就看到最新的信息
*@authorAdministrator
*
*/
publicclassWeatherDataimplementsSubject{
privatefloattemperatrue;
privatefloatpressure;


privatefloathumidity;
//观察者集合
privateArrayList<Observer>observers;

 //加入新的第三方

publicWeatherData(){
observers=newArrayList<Observer>();
}

publicfloatgetTemperature(){
returntemperatrue;
}

publicfloatgetPressure(){
returnpressure;
}

publicfloatgetHumidity(){
returnhumidity;
}

publicvoiddataChange(){
//调用 接入方的 update

```
notifyObservers();
```

 }

//当数据有更新时，就调用 setData
publicvoidsetData(floattemperature,floatpressure,floathumidity){
this.temperatrue=temperature;
this.pressure=pressure;
this.humidity=humidity;
//调用dataChange， 将最新的信息 推送给 接入方 currentConditions
dataChange();
}

//注册一个观察者
@Override
publicvoidregisterObserver(Observero){
//TODOAuto-generatedmethodstub
observers.add(o);
}

 //移除一个观察者

@Override
publicvoidremoveObserver(Observero){
//TODOAuto-generatedmethodstub
if(observers.contains(o)){
observers.remove(o);
}
}


 //遍历所有的观察者，并通知

@Override
publicvoidnotifyObservers(){
//TODOAuto-generatedmethodstub
for(inti= 0 ;i<observers.size();i++){
observers.get(i).update(this.temperatrue,this.pressure,this.humidity);
}
}
}

#### 20 4 3 观察者模式的好处

1 ) 观察者模式设计后，会以集合的方式来管理用户(Observer)，包括注册，移除和通知。
2 ) 这样，我们增加观察者(这里可以理解成一个新的公告板)，就不需要去修改核心类WeatherData不会修改代码，
遵守了ocp原则。

### 20 5 观察者模式在JDK应用的源码分析.

1 ) Jdk的Observable类就使用了观察者模式
2 ) 代码分析+模式角色分析


 3 ) 模式角色分析

 Observable 的作用和地位等价于 我们前面讲过Subject
 Observable 是类，不是接口，类中已经实现了核心的方法 ,即管理Observer的方法 adddeletenotify.
 Observer 的作用和地位等价于我们前面讲过的 Observer,有update
 Observable 和 Observer 的使用方法和前面讲过的一样，只是Observable 是类，通过继承来实现观察者模式


## 第 21 章 中介者模式

### 21 1 智能家庭项目

 智能家庭项目：

 1 ) 智能家庭包括各种设备，闹钟、咖啡机、电视机、窗帘 等

 2 ) 主人要看电视时，各个设备可以协同工作，自动完成看电视的准备工作，比如流程为：闹铃响起->咖啡机开始

 做咖啡->窗帘自动落下->电视机开始播放

### 21 2 传统方案解决智能家庭管理问题.

### 21 3 传统的方式的问题分析

 1 ) 当各电器对象有多种状态改变时，相互之间的调用关系会比较复杂

 2 ) 各个电器对象彼此联系，你中有我，我中有你，不利于松耦合.

 3 ) 各个电器对象之间所传递的消息(参数)，容易混乱

 4 ) 当系统增加一个新的电器对象时，或者执行流程改变时，代码的可维护性、扩展性都不理想 考虑中介者模

 式


### 21 4 中介者模式基本介绍

 基本介绍

1 ) 中介者模式(MediatorPattern)，用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地
相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互
2 ) 中介者模式属于行为型模式，使代码易于维护
3 ) 比如MVC模式，C(Controller控制器)是M(Model模型)和V(View视图)的中介者，在前后端交互时起
到了中间人的作用

### 21 5 中介者模式的原理类图

  对原理类图的说明-即(中介者模式的角色及职责)

1 ) Mediator 就是抽象中介者,定义了同事对象到中介者对象的接口
2 ) Colleague 是抽象同事类
3 ) ConcreteMediator 具体的中介者对象, 实现抽象方法, 他需要知道所有的具体的同事类,即以一个集合来管理
HashMap,并接受某个同事对象消息，完成相应的任务
4 ) ConcreteColleague 具体的同事类，会有很多, 每个同事只知道自己的行为，而不了解其他同事类的行为(方法)，
但 是他们都依赖中介者对象

### 21 6 中介者模式应用实例-智能家庭管理.

 1 ) 应用实例要求

 完成前面的智能家庭的项目，使用中介者模式


 2 ) 思路分析和图解(类图)

 3 ) 代码实现

```
smarthouse.zip
```
packagecom.atguigu.mediator.smarthouse;

 //具体的同事类

publicclassAlarmextendsColleague{

 //构造器

```
publicAlarm(Mediatormediator,Stringname){
```

```
super(mediator,name);
//TODOAuto-generatedconstructorstub
//在创建Alarm 同事对象时，将自己放入到ConcreteMediator对象中[集合]
mediator.Register(name,this);
}
```
```
publicvoidSendAlarm(intstateChange){
SendMessage(stateChange);
}
```
```
@Override
publicvoidSendMessage(intstateChange){
//TODOAuto-generatedmethodstub
//调用的中介者对象的getMessage
this.GetMediator().GetMessage(stateChange,this.name);
}
```
 }

packagecom.atguigu.mediator.smarthouse;

publicclassClientTest{

```
publicstaticvoidmain(String[]args){
//创建一个中介者对象
Mediatormediator=newConcreteMediator();
```

```
//创建Alarm 并且加入到 ConcreteMediator对象的HashMap
Alarmalarm=newAlarm(mediator,"alarm");
```
```
//创建了CoffeeMachine 对象，并 且加入到 ConcreteMediator 对象的HashMap
CoffeeMachinecoffeeMachine=newCoffeeMachine(mediator,
"coffeeMachine");
```
```
//创建 Curtains, 并 且加入到 ConcreteMediator 对象的HashMap
Curtainscurtains=newCurtains(mediator,"curtains");
TVtV=newTV(mediator,"TV");
```
 //让闹钟发出消息

```
alarm.SendAlarm( 0 );
coffeeMachine.FinishCoffee();
alarm.SendAlarm( 1 );
}
```
 }

packagecom.atguigu.mediator.smarthouse;

publicclassCoffeeMachineextendsColleague{

```
publicCoffeeMachine(Mediatormediator,Stringname){
super(mediator,name);
```

```
//TODOAuto-generatedconstructorstub
mediator.Register(name,this);
}
```
```
@Override
publicvoidSendMessage(intstateChange){
//TODOAuto-generatedmethodstub
this.GetMediator().GetMessage(stateChange,this.name);
}
```
```
publicvoidStartCoffee(){
System.out.println("It'stimetostartcoffee!");
}
```
```
publicvoidFinishCoffee(){
```
System.out.println("After 5 minutes!");
System.out.println("Coffeeisok!");
SendMessage( 0 );
}
}

packagecom.atguigu.mediator.smarthouse;

 //同事抽象类

publicabstractclassColleague{


```
privateMediatormediator;
publicStringname;
```
```
publicColleague(Mediatormediator,Stringname){
```
```
this.mediator=mediator;
this.name=name;
```
 }

```
publicMediatorGetMediator(){
returnthis.mediator;
}
```
publicabstractvoidSendMessage(intstateChange);
}

packagecom.atguigu.mediator.smarthouse;

importjava.util.HashMap;

 //具体的中介者类

publicclassConcreteMediatorextendsMediator{
//集合，放入所有的同事对象
privateHashMap<String,Colleague>colleagueMap;
privateHashMap<String,String>interMap;


publicConcreteMediator(){
colleagueMap=newHashMap<String,Colleague>();
interMap=newHashMap<String,String>();
}

@Override
publicvoidRegister(StringcolleagueName,Colleaguecolleague){
//TODOAuto-generatedmethodstub
colleagueMap.put(colleagueName,colleague);

```
//TODOAuto-generatedmethodstub
```
```
if(colleagueinstanceofAlarm){
interMap.put("Alarm",colleagueName);
}elseif(colleagueinstanceofCoffeeMachine){
interMap.put("CoffeeMachine",colleagueName);
}elseif(colleagueinstanceofTV){
interMap.put("TV",colleagueName);
}elseif(colleagueinstanceofCurtains){
interMap.put("Curtains",colleagueName);
}
```
 }

 //具体中介者的核心方法


 // 1. 根据得到消息，完成对应任务

 // 2. 中介者在这个方法，协调各个具体的同事对象，完成任务

@Override
publicvoidGetMessage(intstateChange,StringcolleagueName){
//TODOAuto-generatedmethodstub

```
//处理闹钟发出的消息
if(colleagueMap.get(colleagueName)instanceofAlarm){
if(stateChange== 0 ){
((CoffeeMachine)(colleagueMap.get(interMap
.get("CoffeeMachine")))).StartCoffee();
((TV)(colleagueMap.get(interMap.get("TV")))).StartTv();
}elseif(stateChange== 1 ){
((TV)(colleagueMap.get(interMap.get("TV")))).StopTv();
}
```
```
}elseif(colleagueMap.get(colleagueName)instanceofCoffeeMachine){
((Curtains)(colleagueMap.get(interMap.get("Curtains"))))
.UpCurtains();
```
```
}elseif(colleagueMap.get(colleagueName)instanceofTV){//如果TV发现消息
```
```
}elseif(colleagueMap.get(colleagueName)instanceofCurtains){
//如果是以窗帘发出的消息，这里处理.
}
```

 }

```
@Override
publicvoidSendMessage(){
//TODOAuto-generatedmethodstub
```
```
}
```
 }

packagecom.atguigu.mediator.smarthouse;

publicclassCurtainsextendsColleague{

```
publicCurtains(Mediatormediator,Stringname){
super(mediator,name);
//TODOAuto-generatedconstructorstub
mediator.Register(name,this);
}
```
```
@Override
publicvoidSendMessage(intstateChange){
//TODOAuto-generatedmethodstub
this.GetMediator().GetMessage(stateChange,this.name);
}
```

```
publicvoidUpCurtains(){
System.out.println("IamholdingUpCurtains!");
}
```
 }

packagecom.atguigu.mediator.smarthouse;

publicabstractclassMediator{
//将给中介者对象，加入到集合中
publicabstractvoidRegister(StringcolleagueName,Colleaguecolleague);

```
//接收消息, 具体的同事对象发出
publicabstractvoidGetMessage(intstateChange,StringcolleagueName);
```
publicabstractvoidSendMessage();
}

packagecom.atguigu.mediator.smarthouse;

publicclassTVextendsColleague{

```
publicTV(Mediatormediator,Stringname){
super(mediator,name);
//TODOAuto-generatedconstructorstub
mediator.Register(name,this);
```

 }

```
@Override
publicvoidSendMessage(intstateChange){
//TODOAuto-generatedmethodstub
this.GetMediator().GetMessage(stateChange,this.name);
}
```
```
publicvoidStartTv(){
//TODOAuto-generatedmethodstub
System.out.println("It'stimetoStartTv!");
}
```
publicvoidStopTv(){
//TODOAuto-generatedmethodstub
System.out.println("StopTv!");
}
}

### 21 7 中介者模式的注意事项和细节

 1 ) 多个类相互耦合，会形成网状结构, 使用中介者模式将网状结构分离为星型结构，进行解耦

 2 ) 减少类间依赖，降低了耦合，符合迪米特原则

 3 ) 中介者承担了较多的责任，一旦中介者出现了问题，整个系统就会受到影响

 4 ) 如果设计不当，中介者对象本身变得过于复杂，这点在实际使用时，要特别注意


## 第 22 章 备忘录模式

### 22 1 游戏角色状态恢复问题

游戏角色有攻击力和防御力，在大战Boss前保存自身的状态(攻击力和防御力)，当大战Boss后攻击力和防御
力下降，从备忘录对象恢复到大战前的状态

### 22 2 传统方案解决游戏角色恢复

### 22 3 传统的方式的问题分析

 1 ) 一个对象，就对应一个保存对象状态的对象， 这样当我们游戏的对象很多时，不利于管理，开销也很大.

2 ) 传统的方式是简单地做备份，new出另外一个对象出来，再把需要备份的数据放到这个新对象，但这就暴露了
对象内部的细节
3 ) 解决方案： =>备忘录模式

### 22 4 备忘录模式基本介绍

 基本介绍

1 ) 备忘录模式(MementoPattern)在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这
个状态。这样以后就可将该对象恢复到原先保存的状态


 2 ) 可以这里理解备忘录模式：现实生活中的备忘录是用来记录某些要去做的事情，或者是记录已经达成的共同意

 见的事情，以防忘记了。而在软件层面，备忘录模式有着相同的含义，备忘录对象主要用来记录一个对象的某

 种状态，或者某些数据，当要做回退时，可以从备忘录对象里获取原来的数据进行恢复操作

 3 ) 备忘录模式属于行为型模式

### 22 5 备忘录模式的原理类图

  对原理类图的说明-即(备忘录模式的角色及职责)

1 ) originator: 对象(需要保存状态的对象)
2 ) Memento ： 备忘录对象,负责保存好记录，即Originator内部状态
3 ) Caretaker: 守护者对象,负责保存多个备忘录对象， 使用集合管理，提高效率
4 ) 说明：如果希望保存多个originator对象的不同时间的状态，也可以，只需要要 HashMap<String, 集合>
 代码实现

```
theory.zip
```
packagecom.atguigu.memento.theory;


importjava.util.ArrayList;
importjava.util.List;

publicclassCaretaker{

```
//在List 集合中会有很多的备忘录对象
privateList<Memento>mementoList=newArrayList<Memento>();
```
```
publicvoidadd(Mementomemento){
mementoList.add(memento);
}
```
//获取到第index个Originator 的 备忘录对象(即保存状态)
publicMementoget(intindex){
returnmementoList.get(index);
}
}

packagecom.atguigu.memento.theory;

importjava.util.ArrayList;
importjava.util.HashMap;

publicclassClient{


publicstaticvoidmain(String[]args){
//TODOAuto-generatedmethodstub

```
Originatororiginator=newOriginator();
Caretakercaretaker=newCaretaker();
```
```
originator.setState(" 状态# 1 攻击力 100 ");
```
 //保存了当前的状态

```
caretaker.add(originator.saveStateMemento());
```
```
originator.setState(" 状态# 2 攻击力 80 ");
```
```
caretaker.add(originator.saveStateMemento());
```
```
originator.setState(" 状态# 3 攻击力 50 ");
caretaker.add(originator.saveStateMemento());
```
```
System.out.println("当前的状态是 ="+originator.getState());
```
```
//希望得到状态 1 , 将 originator 恢复到状态 1
```
```
originator.getStateFromMemento(caretaker.get( 0 ));
System.out.println("恢复到状态 1 , 当前的状态是");
```

```
System.out.println("当前的状态是 ="+originator.getState());
```
 }

 }

packagecom.atguigu.memento.theory;

publicclassMemento{
privateStringstate;

 //构造器

```
publicMemento(Stringstate){
super();
this.state=state;
}
```
```
publicStringgetState(){
returnstate;
}
```
 }


packagecom.atguigu.memento.theory;

publicclassOriginator{

```
privateStringstate;//状态信息
```
```
publicStringgetState(){
returnstate;
}
```
```
publicvoidsetState(Stringstate){
this.state=state;
}
```
```
//编写一个方法，可以保存一个状态对象 Memento
//因此编写一个方法，返回 Memento
publicMementosaveStateMemento(){
returnnewMemento(state);
}
```
 //通过备忘录对象，恢复状态

publicvoidgetStateFromMemento(Mementomemento){
state=memento.getState();
}
}


### 22 6 游戏角色恢复状态实例

 1 ) 应用实例要求

游戏角色有攻击力和防御力，在大战Boss前保存自身的状态(攻击力和防御力)，当大战Boss后攻击力和防御
力下降，从备忘录对象恢复到大战前的状态

 2 ) 思路分析和图解(类图)

 3 ) 代码实现

```
game.zip
```
packagecom.atguigu.memento.game;

importjava.util.ArrayList;
importjava.util.HashMap;


 //守护者对象, 保存游戏角色的状态

publicclassCaretaker{

 //如果只保存一次状态

```
privateMemento memento;
//对GameRole 保存多次状态
//privateArrayList<Memento>mementos;
//对多个游戏角色保存多个状态
//privateHashMap<String,ArrayList<Memento>>rolesMementos;
```
```
publicMementogetMemento(){
returnmemento;
}
```
```
publicvoidsetMemento(Mementomemento){
this.memento=memento;
}
```
 }

packagecom.atguigu.memento.game;

publicclassClient{

```
publicstaticvoidmain(String[]args){
```

```
//TODOAuto-generatedmethodstub
//创建游戏角色
GameRolegameRole=newGameRole();
gameRole.setVit( 100 );
gameRole.setDef( 100 );
```
```
System.out.println("和boss大战前的状态");
gameRole.display();
```
```
//把当前状态保存caretaker
Caretakercaretaker=newCaretaker();
caretaker.setMemento(gameRole.createMemento());
```
```
System.out.println("和boss大战~~~");
gameRole.setDef( 30 );
gameRole.setVit( 30 );
```
```
gameRole.display();
```
```
System.out.println("大战后，使用备忘录对象恢复到站前");
```
gameRole.recoverGameRoleFromMemento(caretaker.getMemento());
System.out.println("恢复后的状态");
gameRole.display();
}


 }

packagecom.atguigu.memento.game;

publicclassGameRole{

```
privateintvit;
privateintdef;
```
```
//创建Memento,即根据当前的状态得到Memento
publicMementocreateMemento(){
returnnewMemento(vit,def);
}
```
```
//从备忘录对象，恢复GameRole的状态
publicvoidrecoverGameRoleFromMemento(Mementomemento){
this.vit=memento.getVit();
this.def=memento.getDef();
}
```
 //显示当前游戏角色的状态

```
publicvoiddisplay(){
System.out.println("游戏角色当前的攻击力："+this.vit+" 防御力:"+this.def);
}
```
```
publicintgetVit(){
```

```
returnvit;
}
```
```
publicvoidsetVit(intvit){
this.vit=vit;
}
```
```
publicintgetDef(){
returndef;
}
```
```
publicvoidsetDef(intdef){
this.def=def;
}
```
 }

packagecom.atguigu.memento.game;

publicclassMemento{

```
//攻击力
privateintvit;
//防御力
privateintdef;
```

publicMemento(intvit,intdef){
super();
this.vit=vit;
this.def=def;
}
publicintgetVit(){
returnvit;
}
publicvoidsetVit(intvit){
this.vit=vit;
}
publicintgetDef(){
returndef;
}
publicvoidsetDef(intdef){
this.def=def;
}
}

### 22 7 备忘录模式的注意事项和细节

 1 ) 给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态

 2 ) 实现了信息的封装，使得用户不需要关心状态的保存细节

 3 ) 如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存, 这个需要注意

4 ) 适用的应用场景： 1 、后悔药。 2 、打游戏时的存档。 3 、Windows 里的 ctri+z。 4 、IE 中的后退。 4 、数
据库的事务管理


 5 ) 为了节约内存，备忘录模式可以和原型模式配合使用


## 第 23 章 解释器模式

### 23. 1 四则运算问题

通过解释器模式来实现四则运算，如计算a+b-c的值，具体要求
1 ) 先输入表达式的形式，比如 a+b+c-d+e, 要求表达式的字母不能重复
2 ) 在分别输入a,b,c,d,e 的值
3 ) 最后求出结果：如图

### 23 2 传统方案解决四则运算问题分析.

 1 ) 编写一个方法，接收表达式的形式，然后根据用户输入的数值进行解析，得到结果

 2 ) 问题分析：如果加入新的运算符，比如 */( 等等，不利于扩展，另外让一个方法来解析会造成程序结构混乱，

 不够清晰.

 3 ) 解决方案：可以考虑使用解释器模式， 即： 表达式 -> 解释器(可以有多种) -> 结果

### 23 3 解释器模式基本介绍

 基本介绍

 1 ) 在编译原理中，一个算术表达式通过词法分析器形成词法单元，而后这些词法单元再通过语法分析器构建语法

 分析树，最终形成一颗抽象的语法分析树。这里的词法分析器和语法分析器都可以看做是解释器

2 ) 解释器模式(InterpreterPattern)：是指给定一个语言 **(** 表达式 **)** ，定义它的文法的一种表示，并定义一个解释器，
使用该解释器来解释语言中的句子 **(** 表达式)
3 ) 应用场景

- 应用可以将一个需要解释执行的语言中的句子表示为一个抽象语法树
- 一些重复出现的问题可以用一种简单的语言来表达


 - 一个简单语法需要解释的场景

 4 ) 这样的例子还有，比如编译器、运算表达式计算、正则表达式、机器人等

### 23 4 解释器模式的原理类图

  对原理类图的说明-即(解释器模式的角色及职责)

1 ) Context: 是环境角色,含有解释器之外的全局信息.
2 ) AbstractExpression: 抽象表达式， 声明一个抽象的解释操作,这个方法为抽象语法树中所有的节点所共享
3 ) TerminalExpression: 为终结符表达式, 实现与文法中的终结符相关的解释操作
4 ) NonTermialExpression: 为非终结符表达式，为文法中的非终结符实现解释操作.
5 ) 说明： 输入ContextheTerminalExpression 信息通过Client 输入即可

### 23 5 解释器模式来实现四则

 1 ) 应用实例要求

 通过解释器模式来实现四则运算，

```
如计算a+b-c的值
```

 2 ) 思路分析和图解(类图)

 3 ) 代码实现

```
interpreter.zip
```
packagecom.atguigu.interpreter;

importjava.util.HashMap;

 /**

 * 加法解释器

*@authorAdministrator
*
*/
publicclassAddExpressionextendsSymbolExpression {


```
publicAddExpression(Expressionleft,Expressionright){
super(left,right);
}
```
 //处理相加

//var 仍然是 {a= 10 ,b= 20 }
//一会我们debug 源码,就ok
publicintinterpreter(HashMap<String,Integer>var){
//super.left.interpreter(var) ： 返回 left 表达式对应的值 a= 10
//super.right.interpreter(var): 返回right 表达式对应值 b= 20
returnsuper.left.interpreter(var)+super.right.interpreter(var);
}
}

packagecom.atguigu.interpreter;

importjava.util.HashMap;
importjava.util.Stack;

publicclassCalculator{

```
// 定义表达式
privateExpressionexpression;
```
 // 构造函数传参，并解析


```
publicCalculator(StringexpStr){//expStr=a+b
// 安排运算先后顺序
Stack<Expression>stack=newStack<>();
// 表达式拆分成字符数组
char[]charArray=expStr.toCharArray();//[a,+,b]
```
Expressionleft=null;
Expressionright=null;
//遍历我们的字符数组， 即遍历 [a,+,b]
//针对不同的情况，做处理
for(inti= 0 ;i<charArray.length;i++){
switch(charArray[i]){
case'+'://
left=stack.pop();// 从stack取出left=>"a"
right=newVarExpression(String.valueOf(charArray[++i]));// 取出右表达式 "b"
stack.push(newAddExpression(left,right));// 然后根据得到left 和 right 构建 AddExpresson加入
stack
break;
case'-'://
left=stack.pop();
right=newVarExpression(String.valueOf(charArray[++i]));
stack.push(newSubExpression(left,right));
break;
default:
//如果是一个Var 就创建要给 VarExpression 对象，并push到 stack
stack.push(newVarExpression(String.valueOf(charArray[i])));


```
break;
}
}
//当遍历完整个 charArray 数组后，stack 就得到最后Expression
this.expression=stack.pop();
}
```
publicintrun(HashMap<String,Integer>var){
//最后将表达式a+b和 var={a= 10 ,b= 20 }
//然后传递给expression的interpreter进行解释执行
returnthis.expression.interpreter(var);
}
}
packagecom.atguigu.interpreter;

importjava.io.BufferedReader;
importjava.io.IOException;
importjava.io.InputStreamReader;
importjava.util.HashMap;

publicclassClientTest{

```
publicstaticvoidmain(String[]args)throwsIOException{
//TODOAuto-generatedmethodstub
StringexpStr=getExpStr();//a+b
HashMap<String,Integer>var=getValue(expStr);//var{a= 10 ,b= 20 }
```

Calculatorcalculator=newCalculator(expStr);
System.out.println("运算结果："+expStr+"="+calculator.run(var));
}

 // 获得表达式

publicstaticStringgetExpStr()throwsIOException{
System.out.print("请输入表达式：");
return(newBufferedReader(newInputStreamReader(System.in))).readLine();
}

 // 获得值映射

publicstaticHashMap<String,Integer>getValue(StringexpStr)throwsIOException{
HashMap<String,Integer>map=newHashMap<>();

```
for(charch:expStr.toCharArray()){
if(ch!='+'&&ch!='-'){
if(!map.containsKey(String.valueOf(ch))){
System.out.print("请输入"+String.valueOf(ch)+"的值：");
Stringin=(newBufferedReader(newInputStreamReader(System.in))).readLine();
map.put(String.valueOf(ch),Integer.valueOf(in));
}
}
}
```
returnmap;
}


 }

packagecom.atguigu.interpreter;

importjava.util.HashMap;

 /**

* 抽象类表达式，通过HashMap 键值对, 可以获取到变量的值
*
*@authorAdministrator
*
*/
publicabstractclassExpression{
//a+b-c
// 解释公式和数值,key 就是公式(表达式) 参数[a,b,c],value就是就是具体值
//HashMap{a= 10 ,b= 20 }
publicabstractintinterpreter(HashMap<String,Integer>var);
}

packagecom.atguigu.interpreter;

importjava.util.HashMap;

publicclassSubExpressionextendsSymbolExpression{

```
publicSubExpression(Expressionleft,Expressionright){
```

```
super(left,right);
}
```
//求出left 和 right 表达式相减后的结果
publicintinterpreter(HashMap<String,Integer>var){
returnsuper.left.interpreter(var)-super.right.interpreter(var);
}
}

packagecom.atguigu.interpreter;

importjava.util.HashMap;

 /**

 * 抽象运算符号解析器 这里，每个运算符号，都只和自己左右两个数字有关系，

* 但左右两个数字有可能也是一个解析的结果，无论何种类型，都是Expression类的实现类
*
*@authorAdministrator
*
*/
publicclassSymbolExpressionextendsExpression{

```
protectedExpressionleft;
protectedExpressionright;
```
```
publicSymbolExpression(Expressionleft,Expressionright){
```

```
this.left=left;
this.right=right;
}
```
//因为 SymbolExpression 是让其子类来实现，因此 interpreter 是一个默认实现
@Override
publicintinterpreter(HashMap<String,Integer>var){
//TODOAuto-generatedmethodstub
return 0 ;
}
}

packagecom.atguigu.interpreter;

importjava.util.HashMap;

 /**

 * 变量的解释器

*@authorAdministrator
*
*/
publicclassVarExpressionextendsExpression{

```
privateStringkey;//key=a,key=b,key=c
```

```
publicVarExpression(Stringkey){
this.key=key;
}
```
//var 就是{a= 10 ,b= 20 }
//interpreter 根据 变量名称，返回对应值
@Override
publicintinterpreter(HashMap<String,Integer>var){
returnvar.get(this.key);
}
}

### 23 6 解释器模式在SPRING框架应用的源码剖析.

1 ) Spring框架中 SpelExpressionParser就使用到解释器模式
2 ) 代码分析+Debug源码


 3 ) 说明

### 23 7 解释器模式的注意事项和细节

 1 ) 当有一个语言需要解释执行，可将该语言中的句子表示为一个抽象语法树，就可以考虑使用解释器模式，让程

 序具有良好的扩展性

 2 ) 应用场景：编译器、运算表达式计算、正则表达式、机器人等

 3 ) 使用解释器可能带来的问题：解释器模式会引起类膨胀、解释器模式采用递归调用方法，将会导致调试非常复

 杂、效率可能降低.


## 第 24 章 状态模式

### 24 1 APP抽奖活动问题.

 请编写程序完成APP抽奖活动 具体要求如下:

 1 ) 假如每参加一次这个活动要扣除用户 50 积分，中奖概率是 10 %

 2 ) 奖品数量固定，抽完就不能抽奖

 3 ) 活动有四个状态: 可以抽奖、不能抽奖、发放奖品和奖品领完

 4 ) 活动的四个状态转换关系图(右图)

### 24 2 状态模式基本介绍

 基本介绍

1 ) 状态模式( **StatePattern** )：它主要用来解决对象在多种状态转换时，需要对外输出不同的行为的问题。状态
和行为是一一对应的，状态之间可以相互转换
2 ) 当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了其类

### 24 3 状态模式的原理类图


  对原理类图的说明-即(状态模式的角色及职责)

1 ) Context 类为环境角色, 用于维护State实例,这个实例定义当前状态
2 ) State 是抽象状态角色,定义一个接口封装与Context 的一个特点接口相关行为
3 ) ConcreteState 具体的状态角色，每个子类实现一个与Context 的一个状态相关行为

### 24 4 状态模式解决APP抽奖问

 1 ) 应用实例要求

 完成APP抽奖活动项目，使用状态模式.

 2 ) 思路分析和图解(类图)

 - 定义出一个接口叫状态接口，每个状态都实现它。

 - 接口有扣除积分方法、抽奖方法、发放奖品方法


 3 ) 代码实现

```
state.zip
```
packagecom.atguigu.state;

importjava.util.Random;

 /**

 * 可以抽奖的状态

*@authorAdministrator
*
*/
publicclassCanRaffleStateextendsState{

```
RaffleActivityactivity;
```
```
publicCanRaffleState(RaffleActivityactivity){
this.activity=activity;
}
```
 //已经扣除了积分，不能再扣

```
@Override
publicvoiddeductMoney(){
System.out.println("已经扣取过了积分");
}
```

 //可以抽奖, 抽完奖后，根据实际情况，改成新的状态

```
@Override
publicbooleanraffle(){
System.out.println("正在抽奖，请稍等！");
Randomr=newRandom();
intnum=r.nextInt( 10 );
// 10 %中奖机会
if(num== 0 ){
// 改变活动状态为发放奖品 context
activity.setState(activity.getDispenseState());
returntrue;
}else{
System.out.println("很遗憾没有抽中奖品！");
// 改变状态为不能抽奖
activity.setState(activity.getNoRafflleState());
returnfalse;
}
}
```
 // 不能发放奖品

@Override
publicvoiddispensePrize(){
System.out.println("没中奖，不能发放奖品");
}
}


packagecom.atguigu.state;

 /**

 * 状态模式测试类

*@authorAdministrator
*
*/
publicclassClientTest{

```
publicstaticvoidmain(String[]args){
//TODOAuto-generatedmethodstub
// 创建活动对象，奖品有 1 个奖品
RaffleActivityactivity=newRaffleActivity( 1 );
```
 // 我们连续抽 300 次奖

```
for(inti= 0 ;i< 30 ;i++){
System.out.println("--------第"+(i+ 1 )+"次抽奖----------");
// 参加抽奖，第一步点击扣除积分
activity.debuctMoney();
```
 // 第二步抽奖

```
activity.raffle();
}
}
```
 }


packagecom.atguigu.state;

 /**

 * 奖品发放完毕状态

* 说明，当我们activity 改变成 DispenseOutState， 抽奖活动结束
*@authorAdministrator
*
*/
publicclassDispenseOutStateextendsState{

 // 初始化时传入活动引用

```
RaffleActivityactivity;
```
```
publicDispenseOutState(RaffleActivityactivity){
this.activity=activity;
}
@Override
publicvoiddeductMoney(){
System.out.println("奖品发送完了，请下次再参加");
}
```
```
@Override
publicbooleanraffle(){
System.out.println("奖品发送完了，请下次再参加");
returnfalse;
```

 }

@Override
publicvoiddispensePrize(){
System.out.println("奖品发送完了，请下次再参加");
}
}

packagecom.atguigu.state;

 /**

 * 发放奖品的状态

*@authorAdministrator
*
*/
publicclassDispenseStateextendsState{

```
// 初始化时传入活动引用，发放奖品后改变其状态
RaffleActivityactivity;
```
```
publicDispenseState(RaffleActivityactivity){
this.activity=activity;
}
```
 //


@Override
publicvoiddeductMoney(){
System.out.println("不能扣除积分");
}

@Override
publicbooleanraffle(){
System.out.println("不能抽奖");
returnfalse;
}

//发放奖品
@Override
publicvoiddispensePrize(){
if(activity.getCount()> 0 ){
System.out.println("恭喜中奖了");
// 改变状态为不能抽奖
activity.setState(activity.getNoRafflleState());
}else{
System.out.println("很遗憾，奖品发送完了");
// 改变状态为奖品发送完毕, 后面我们就不可以抽奖
activity.setState(activity.getDispensOutState());
//System.out.println("抽奖活动结束");
//System.exit( 0 );
}


 }

 }

packagecom.atguigu.state;

 /**

 * 不能抽奖状态

*@authorAdministrator
*
*/
publicclassNoRaffleStateextendsState{

```
// 初始化时传入活动引用，扣除积分后改变其状态
RaffleActivityactivity;
```
```
publicNoRaffleState(RaffleActivityactivity){
this.activity=activity;
}
```
 // 当前状态可以扣积分 , 扣除后，将状态设置成可以抽奖状态

```
@Override
publicvoiddeductMoney(){
System.out.println("扣除 50 积分成功，您可以抽奖了");
activity.setState(activity.getCanRaffleState());
}
```

 // 当前状态不能抽奖

```
@Override
publicbooleanraffle(){
System.out.println("扣了积分才能抽奖喔！");
returnfalse;
}
```
 // 当前状态不能发奖品

@Override
publicvoiddispensePrize(){
System.out.println("不能发放奖品");
}
}

packagecom.atguigu.state;

 /**

 * 抽奖活动 //

 *

*@authorAdministrator
*
*/
publicclassRaffleActivity{

```
//state 表示活动当前的状态，是变化
Statestate=null;
```

 // 奖品数量

intcount= 0 ;

 // 四个属性，表示四种状态

StatenoRafflleState=newNoRaffleState(this);
StatecanRaffleState=newCanRaffleState(this);

StatedispenseState= newDispenseState(this);
StatedispensOutState=newDispenseOutState(this);

 //构造器

// 1. 初始化当前的状态为 noRafflleState(即不能抽奖的状态)
// 2. 初始化奖品的数量
publicRaffleActivity(intcount){
this.state=getNoRafflleState();
this.count=count;
}

//扣分, 调用当前状态的 deductMoney
publicvoiddebuctMoney(){
state.deductMoney();
}

 //抽奖

publicvoidraffle(){
// 如果当前的状态是抽奖成功


```
if(state.raffle()){
//领取奖品
state.dispensePrize();
}
```
 }

publicStategetState(){
returnstate;
}

publicvoidsetState(Statestate){
this.state=state;
}

//这里请大家注意，每领取一次奖品，count--
publicintgetCount(){
intcurCount=count;
count--;
returncurCount;
}

publicvoidsetCount(intcount){
this.count=count;
}


publicStategetNoRafflleState(){
returnnoRafflleState;
}

publicvoidsetNoRafflleState(StatenoRafflleState){
this.noRafflleState=noRafflleState;
}

publicStategetCanRaffleState(){
returncanRaffleState;
}

publicvoidsetCanRaffleState(StatecanRaffleState){
this.canRaffleState=canRaffleState;
}

publicStategetDispenseState(){
returndispenseState;
}

publicvoidsetDispenseState(StatedispenseState){
this.dispenseState=dispenseState;
}

publicStategetDispensOutState(){
returndispensOutState;


 }

publicvoidsetDispensOutState(StatedispensOutState){
this.dispensOutState=dispensOutState;
}
}

packagecom.atguigu.state;

 /**

 * 状态抽象类

*@authorAdministrator
*
*/
publicabstractclassState{

 // 扣除积分 - 50

```
publicabstractvoiddeductMoney();
```
 // 是否抽中奖品

```
publicabstractbooleanraffle();
```
 // 发放奖品

```
publicabstract voiddispensePrize();
```

 }

### 24 5 状态模式在实际项目-借贷平台 源码剖析.

 1 ) 借贷平台的订单，有审核-发布-抢单 等等 步骤，随着操作的不同，会改变订单的状态, 项目中的这个模块实

 现就会使用到状态模式

2 ) 通常通过if/else判断订单的状态，从而实现不同的逻辑，伪代码如下

 3 ) 使用状态模式完成 借贷平台项目的审核模块 [设计+代码]

```
money.zip
```
packagecom.atguigu.state.money;

publicabstractclassAbstractStateimplementsState{

```
protectedstaticfinalRuntimeExceptionEXCEPTION=newRuntimeException("操作流程不允许");
```
```
//抽象类，默认实现了 State 接口的所有方法
//该类的所有方法，其子类(具体的状态类)，可以有选择的进行重写
```

@Override
publicvoidcheckEvent(Contextcontext){
throwEXCEPTION;
}

@Override
publicvoidcheckFailEvent(Contextcontext){
throwEXCEPTION;
}

@Override
publicvoidmakePriceEvent(Contextcontext){
throwEXCEPTION;
}

@Override
publicvoidacceptOrderEvent(Contextcontext){
throwEXCEPTION;
}

@Override
publicvoidnotPeopleAcceptEvent(Contextcontext){
throwEXCEPTION;
}

@Override


```
publicvoidpayOrderEvent(Contextcontext){
throwEXCEPTION;
}
```
```
@Override
publicvoidorderFailureEvent(Contextcontext){
throwEXCEPTION;
}
```
@Override
publicvoidfeedBackEvent(Contextcontext){
throwEXCEPTION;
}
}

packagecom.atguigu.state.money;

//各种具体状态类
classFeedBackStateextendsAbstractState{

@Override
publicStringgetCurrentState(){
returnStateEnum.FEED_BACKED.getValue();
}
}


classGenerateStateextendsAbstractState{

```
@Override
publicvoidcheckEvent(Contextcontext){
context.setState(newReviewState());
}
```
```
@Override
publicvoidcheckFailEvent(Contextcontext){
context.setState(newFeedBackState());
}
```
@Override
publicStringgetCurrentState(){
returnStateEnum.GENERATE.getValue();
}
}

classNotPayStateextendsAbstractState{

```
@Override
publicvoidpayOrderEvent(Contextcontext){
context.setState(newPaidState());
}
```
```
@Override
```

```
publicvoidfeedBackEvent(Contextcontext){
context.setState(newFeedBackState());
}
```
@Override
publicStringgetCurrentState(){
returnStateEnum.NOT_PAY.getValue();
}
}

classPaidStateextendsAbstractState{

```
@Override
publicvoidfeedBackEvent(Contextcontext){
context.setState(newFeedBackState());
}
```
@Override
publicStringgetCurrentState(){
returnStateEnum.PAID.getValue();
}
}

classPublishStateextendsAbstractState{

```
@Override
```

```
publicvoidacceptOrderEvent(Contextcontext){
//把当前状态设置为 NotPayState。。。
//至于应该变成哪个状态，有流程图来决定
context.setState(newNotPayState());
}
```
```
@Override
publicvoidnotPeopleAcceptEvent(Contextcontext){
context.setState(newFeedBackState());
}
```
@Override
publicStringgetCurrentState(){
returnStateEnum.PUBLISHED.getValue();
}
}

classReviewStateextendsAbstractState{

```
@Override
publicvoidmakePriceEvent(Contextcontext){
context.setState(newPublishState());
}
```
```
@Override
publicStringgetCurrentState(){
```

```
returnStateEnum.REVIEWED.getValue();
}
```
 }

packagecom.atguigu.state.money;

 /**测试类*/

publicclassClientTest{

```
publicstaticvoidmain(String[]args){
//TODOAuto-generatedmethodstub
//创建context 对象
Contextcontext=newContext();
//将当前状态设置为 PublishState
context.setState(newPublishState());
System.out.println(context.getCurrentState());
```
// //publish-->notpay
context.acceptOrderEvent(context);
// //notpay-->paid
context.payOrderEvent(context);
// // 失败, 检测失败时，会抛出异常
// try{
// context.checkFailEvent(context);
// System.out.println("流程正常");
// }catch(Exceptione){


// //TODO:handleexception
// System.out.println(e.getMessage());
// }

 }

 }

packagecom.atguigu.state.money;

 //环境上下文

publicclassContextextendsAbstractState{
//当前的状态 state, 根据我们的业务流程处理，不停的变化
privateStatestate;

```
@Override
publicvoidcheckEvent(Contextcontext){
state.checkEvent(this);
getCurrentState();
}
```
```
@Override
publicvoidcheckFailEvent(Contextcontext){
state.checkFailEvent(this);
getCurrentState();
}
```

@Override
publicvoidmakePriceEvent(Contextcontext){
state.makePriceEvent(this);
getCurrentState();
}

@Override
publicvoidacceptOrderEvent(Contextcontext){
state.acceptOrderEvent(this);
getCurrentState();
}

@Override
publicvoidnotPeopleAcceptEvent(Contextcontext){
state.notPeopleAcceptEvent(this);
getCurrentState();
}

@Override
publicvoidpayOrderEvent(Contextcontext){
state.payOrderEvent(this);
getCurrentState();
}

@Override


```
publicvoidorderFailureEvent(Contextcontext){
state.orderFailureEvent(this);
getCurrentState();
}
```
```
@Override
publicvoidfeedBackEvent(Contextcontext){
state.feedBackEvent(this);
getCurrentState();
}
```
```
publicStategetState(){
returnstate;
}
```
```
publicvoidsetState(Statestate){
this.state=state;
}
```
@Override
publicStringgetCurrentState(){
System.out.println("当前状态 :"+state.getCurrentState());
returnstate.getCurrentState();
}
}


packagecom.atguigu.state.money;

 /**

 * 状态接口

*@authorAdministrator
*
*/
publicinterfaceState{

 /**

 * 电审

 */

```
voidcheckEvent(Contextcontext);
```
 /**

 * 电审失败

 */

```
voidcheckFailEvent(Contextcontext);
```
 /**

 * 定价发布

 */

```
voidmakePriceEvent(Contextcontext);
```
 /**

 * 接单


 */

```
voidacceptOrderEvent(Contextcontext);
```
 /**

 * 无人接单失效

 */

```
voidnotPeopleAcceptEvent(Contextcontext);
```
 /**

 * 付款

 */

```
voidpayOrderEvent(Contextcontext);
```
 /**

 * 接单有人支付失效

 */

```
voidorderFailureEvent(Contextcontext);
```
 /**

 * 反馈

 */

```
voidfeedBackEvent(Contextcontext);
```
StringgetCurrentState();
}


packagecom.atguigu.state.money;

 /**

 * 状态枚举类

*@authorAdministrator
*
*/
publicenumStateEnum{

 //订单生成

 GENERATE( 1 ,"GENERATE"),

 //已审核

 REVIEWED( 2 ,"REVIEWED"),

 //已发布

 PUBLISHED( 3 ,"PUBLISHED"),

 //待付款

 NOT_PAY( 4 ,"NOT_PAY"),

 //已付款

 PAID( 5 ,"PAID"),

 //已完结


 FEED_BACKED( 6 ,"FEED_BACKED");

```
privateintkey;
privateStringvalue;
```
StateEnum(intkey,Stringvalue){
this.key=key;
this.value=value;
}
publicintgetKey(){returnkey;}
publicStringgetValue(){returnvalue;}
}

### 24 6 状态模式的注意事项和细节

 1 ) 代码有很强的可读性。状态模式将每个状态的行为封装到对应的一个类中

2 ) 方便维护。将容易产生问题的if-else语句删除了，如果把每个状态的行为都放到一个类中，每次调用方法时都
要判断当前是什么状态，不但会产出很多if-else语句，而且容易出错
3 ) 符合“开闭原则”。容易增删状态
4 ) 会产生很多类。每个状态都要一个对应的类，当状态过多时会产生很多类，加大维护难度
5 ) 应用场景：当一个事件或者对象有很多种状态，状态之间会相互转换，对不同的状态要求有不同的行为的时候，
可以考虑使用状态模式


## 第 25 章 策略模式

### 25 1 编写鸭子项目，具体要求如下:.

 1 ) 有各种鸭子(比如 野鸭、北京鸭、水鸭等， 鸭子有各种行为，比如 叫、飞行等)

 2 ) 显示鸭子的信息

### 25 2 传统方案解决鸭子问题的分析和代码实现.

 1 ) 传统的设计方案(类图)

 2 ) 代码实现-看老师演示

```
strategy.zip
```
packagecom.atguigu.strategy;

publicclassClient{

```
publicstaticvoidmain(String[]args){
//TODOAuto-generatedmethodstub
//测试
}
```
 }


packagecom.atguigu.strategy;

publicabstractclassDuck{

```
publicDuck(){
```
```
}
```
```
publicabstractvoiddisplay();//显示鸭子信息
```
```
publicvoidquack(){
System.out.println("鸭子嘎嘎叫~~");
}
```
```
publicvoidswim(){
System.out.println("鸭子会游泳~~");
}
```
```
publicvoidfly(){
System.out.println("鸭子会飞翔~~~");
}
```
 }

packagecom.atguigu.strategy;


publicclassPekingDuckextendsDuck{

```
@Override
publicvoiddisplay(){
//TODOAuto-generatedmethodstub
System.out.println("~~北京鸭~~~");
}
```
```
//因为北京鸭不能飞翔，因此需要重写fly
@Override
publicvoidfly(){
//TODOAuto-generatedmethodstub
System.out.println("北京鸭不能飞翔");
}
```
}

packagecom.atguigu.strategy;

publicclassToyDuckextendsDuck{

```
@Override
publicvoiddisplay(){
//TODOAuto-generatedmethodstub
System.out.println("玩具鸭");
```

 }

 //需要重写父类的所有方法

```
publicvoidquack(){
System.out.println("玩具鸭不能叫~~");
}
```
```
publicvoidswim(){
System.out.println("玩具鸭不会游泳~~");
}
```
publicvoidfly(){
System.out.println("玩具鸭不会飞翔~~~");
}
}

packagecom.atguigu.strategy;

publicclassWildDuckextendsDuck{

```
@Override
publicvoiddisplay(){
//TODOAuto-generatedmethodstub
System.out.println("这是野鸭 ");
}
```

 }

### 25 3 传统的方式实现的问题分析和解决方案.

1 ) 其它鸭子，都继承了Duck类，所以fly让所有子类都会飞了，这是不正确的
2 ) 上面说的 1 的问题，其实是继承带来的问题：对类的局部改动，尤其超类的局部改动，会影响其他部分。会有
溢出效应
3 ) 为了改进 1 问题，我们可以通过覆盖fly 方法来解决 => 覆盖解决
4 ) 问题又来了，如果我们有一个玩具鸭子ToyDuck, 这样就需要 **ToyDuck** 去覆盖 **Duck** 的所有实现的方法 => 解
决思路 -》 策略模式 (strategypattern)

### 25 4 策略模式基本介绍

1 ) 策略模式(StrategyPattern)中，定义算法族(策略组)，分别封装起来，让他们之间可以互相替换，此模式
让算法的变化独立于使用算法的客户
2 ) 这算法体现了几个设计原则，第一、把变化的代码从不变的代码中分离出来；第二、针对接口编程而不是具体
类(定义了策略接口)；第三、多用组合/聚合，少用继承(客户通过组合方式使用策略)。

### 25 5 策略模式的原理类图


```
说明：从上图可以看到，客户context 有成员变量strategy或者其他的策略接口
,至于需要使用到哪个策略，我们可以在构造器中指定
```
### 25 6 策略模式解决鸭子问题

 1 ) 应用实例要求

 编写程序完成前面的鸭子项目，要求使用策略模式

 2 ) 思路分析(类图)

 策略模式：分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里具体设定行为对象。原则就是：

 分离变化部分，封装接口，基于接口编程各种功能。此模式让行为的变化独立于算法的使用者

 3 ) 代码实现

```
improve.zip
```
packagecom.atguigu.strategy.improve;

publicclassBadFlyBehaviorimplementsFlyBehavior{


```
@Override
publicvoidfly(){
//TODOAuto-generatedmethodstub
System.out.println("飞翔技术一般 ");
}
```
}

packagecom.atguigu.strategy.improve;

publicclassClient{

```
publicstaticvoidmain(String[]args){
//TODOAuto-generatedmethodstub
WildDuckwildDuck=newWildDuck();
wildDuck.fly();//
```
```
ToyDucktoyDuck=newToyDuck();
toyDuck.fly();
```
```
PekingDuckpekingDuck=newPekingDuck();
pekingDuck.fly();
```
 //动态改变某个对象的行为, 北京鸭 不能飞

```
pekingDuck.setFlyBehavior(newNoFlyBehavior());
System.out.println("北京鸭的实际飞翔能力");
```

```
pekingDuck.fly();
}
```
 }

packagecom.atguigu.strategy.improve;

publicabstractclassDuck{

 //属性, 策略接口

```
FlyBehaviorflyBehavior;
//其它属性<->策略接口
QuackBehaviorquackBehavior;
```
```
publicDuck(){
```
 }

```
publicabstractvoiddisplay();//显示鸭子信息
```
```
publicvoidquack(){
System.out.println("鸭子嘎嘎叫~~");
}
```
```
publicvoidswim(){
System.out.println("鸭子会游泳~~");
```

 }

```
publicvoidfly(){
```
 //改进

```
if(flyBehavior!=null){
flyBehavior.fly();
}
}
```
```
publicvoidsetFlyBehavior(FlyBehaviorflyBehavior){
this.flyBehavior=flyBehavior;
}
```
```
publicvoidsetQuackBehavior(QuackBehaviorquackBehavior){
this.quackBehavior=quackBehavior;
}
```
 }

packagecom.atguigu.strategy.improve;

publicinterfaceFlyBehavior{


voidfly();// 子类具体实现
}

packagecom.atguigu.strategy.improve;

publicclassGoodFlyBehaviorimplementsFlyBehavior{

```
@Override
publicvoidfly(){
//TODOAuto-generatedmethodstub
System.out.println("飞翔技术高超 ~~~");
}
```
 }

packagecom.atguigu.strategy.improve;

publicclassNoFlyBehaviorimplementsFlyBehavior{

```
@Override
publicvoidfly(){
//TODOAuto-generatedmethodstub
System.out.println("不会飞翔 ");
}
```

 }

packagecom.atguigu.strategy.improve;

publicclassPekingDuckextendsDuck{

 //假如北京鸭可以飞翔，但是飞翔技术一般

```
publicPekingDuck(){
//TODOAuto-generatedconstructorstub
flyBehavior=newBadFlyBehavior();
```
```
}
```
```
@Override
publicvoiddisplay(){
//TODOAuto-generatedmethodstub
System.out.println("~~北京鸭~~~");
}
```
 }

packagecom.atguigu.strategy.improve;


publicinterfaceQuackBehavior{
voidquack();//子类实现
}

packagecom.atguigu.strategy.improve;

publicclassToyDuckextendsDuck{

```
publicToyDuck(){
//TODOAuto-generatedconstructorstub
flyBehavior=newNoFlyBehavior();
}
```
```
@Override
publicvoiddisplay(){
//TODOAuto-generatedmethodstub
System.out.println("玩具鸭");
}
```
 //需要重写父类的所有方法

```
publicvoidquack(){
System.out.println("玩具鸭不能叫~~");
}
```

```
publicvoidswim(){
System.out.println("玩具鸭不会游泳~~");
}
```
 }

packagecom.atguigu.strategy.improve;

publicclassWildDuckextendsDuck{

```
//构造器，传入FlyBehavor 的对象
public WildDuck(){
//TODOAuto-generatedconstructorstub
flyBehavior=newGoodFlyBehavior();
}
```
```
@Override
publicvoiddisplay(){
//TODOAuto-generatedmethodstub
System.out.println("这是野鸭 ");
}
```
 }


### 25 7 策略模式在JDK-ARRAYS应用的源码分析

1 ) JDK的Arrays 的Comparator就使用了策略模式
2 ) 代码分析+Debug源码+模式角色分析

 代码

```
packagecom.atguigu.jdk;
```
```
importjava.util.Arrays;
importjava.util.Comparator;
```
```
publicclassStrategy{
```
```
publicstaticvoidmain(String[]args){
```

//TODOAuto-generatedmethodstub
//数组
Integer[]data={ 9 , 1 , 2 , 8 , 4 , 3 };
// 实现降序排序，返回- 1 放左边， 1 放右边， 0 保持不变
// 说明
// 1. 实现了 Comparator 接口(策略接口) , 匿名类 对象 newComparator<Integer>(){}
// 2. 对象 newComparator<Integer>(){} 就是实现了 策略接口 的对象
// 3 .publicintcompare(Integero 1 ,Integero 2 ){} 指定具体的处理方式
Comparator<Integer>comparator=newComparator<Integer>(){
publicintcompare(Integero 1 ,Integero 2 ){
if(o 1 >o 2 ){
return- 1 ;
}else{
return 1 ;
}
};
};

 // 说明

 /*

```
*publicstatic<T>voidsort(T[]a,Comparator<?superT>c){
if(c==null){
sort(a);//默认方法
}else{
if(LegacyMergeSort.userRequested)
legacyMergeSort(a,c);//使用策略对象c
```

```
else
// 使用策略对象c
TimSort.sort(a, 0 ,a.length,c,null, 0 , 0 );
}
}
*/
//方式 1
Arrays.sort(data,comparator);
```
```
System.out.println(Arrays.toString(data));// 降序排序
```
```
//方式 2 - 同时lambda 表达式实现 策略模式
Integer[]data 2 ={ 19 , 11 , 12 , 18 , 14 , 13 };
```
```
Arrays.sort(data 2 ,(var 1 ,var 2 )->{
if(var 1 .compareTo(var 2 )> 0 ){
return- 1 ;
}else{
return 1 ;
}
});
```
```
System.out.println("data 2 ="+Arrays.toString(data 2 ));
```
 }


 }

### 25 8 策略模式的注意事项和细节

 1 ) 策略模式的关键是：分析项目中变化部分与不变部分

 2 ) 策略模式的核心思想是：多用组合/聚合 少用继承；用行为类组合，而不是行为的继承。更有弹性

 3 ) 体现了“对修改关闭，对扩展开放”原则，客户端增加行为不用修改原有代码，只要添加一种策略(或者行为)

即可，避免了使用多重转移语句(ifelseifelse)
4 ) 提供了可以替换继承关系的办法：策略模式将算法封装在独立的Strategy类中使得你可以独立于其Context改
变它，使它易于切换、易于理解、易于扩展
5 ) 需要注意的是：每添加一个策略就要增加一个类，当策略过多是会导致类数目庞


## 第 26 章 职责链模式

### 26 1 学校OA系统的采购审批项目：需求是.

 采购员采购教学器材

1 ) 如果金额 小于等于 5000 , 由教学主任审批 ( 0 <=x<= 5000 )
2 ) 如果金额 小于等于 10000 , 由院长审批 ( 5000 <x<= 10000 )
3 ) 如果金额 小于等于 30000 , 由副校长审批 ( 10000 <x<= 30000 )
4 ) 如果金额 超过 30000 以上，有校长审批 ( 30000 <x)
请设计程序完成采购审批项目

### 26 2 传统方案解决OA系统审批，传统的设计方案(类图).

### 26 3 传统方案解决OA系统审批问题分析.

1 ) 传统方式是：接收到一个采购请求后，根据采购金额来调用对应的Approver(审批人)完成审批。
2 ) 传统方式的问题分析 : 客户端这里会使用到 分支判断(比如 switch) 来对不同的采购请求处理，这样就存在
如下问题 ( 1 ) 如果各个级别的人员审批金额发生变化，在客户端的也需要变化 ( 2 ) 客户端必须明确的知道 有
多少个审批级别和访问
3 ) 这样 对一个采购请求进行处理 和Approver(审批人) 就存在强耦合关系，不利于代码的扩展和维护


 4 ) 解决方案 =》 职责链模式

### 26 4 职责链模式基本介绍

 基本介绍

1 ) 职责链模式(ChainofResponsibilityPattern), 又叫 责任链模式，为请求创建了一个接收者对象的链(简单示意
图)。这种模式对请求的发送者和接收者进行解耦。
2 ) 职责链模式通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的
请求传给下一个接收者，依此类推。
3 ) 这种类型的设计模式属于行为型模式

### 26 5 职责链模式的原理类图

  对原理类图的说明-即(职责链模式的角色及职责)

1 ) Handler: 抽象的处理者, 定义了一个处理请求的接口, 同时含义另外Handler
2 ) ConcreteHandlerA,B 是具体的处理者, 处理它自己负责的请求，可以访问它的后继者(即下一个处理者), 如果
可以处理当前请求，则处理，否则就将该请求交个 后继者去处理，从而形成一个职责链
3 ) Request ， 含义很多属性，表示一个请求

### 26 6 职责链模式解决OA系统采购审批.


 1 ) 应用实例要求

 编写程序完成学校OA系统的采购审批项目：需求

 采购员采购教学器材

 如果金额 小于等于 5000 , 由教学主任审批

 如果金额 小于等于 10000 , 由院长审批

 如果金额 小于等于 30000 , 由副校长审批

 如果金额 超过 30000 以上，有校长审批

 2 ) 思路分析和图解(类图)

 3 ) 代码实现

```
responsibilitychain.zip
```
packagecom.atguigu.responsibilitychain;

publicabstractclassApprover{


```
Approverapprover; //下一个处理者
Stringname;// 名字
```
```
publicApprover(Stringname){
//TODOAuto-generatedconstructorstub
this.name=name;
}
```
 //下一个处理者

```
publicvoidsetApprover(Approverapprover){
this.approver=approver;
}
```
 //处理审批请求的方法，得到一个请求, 处理是子类完成，因此该方法做成抽象

```
publicabstractvoidprocessRequest(PurchaseRequestpurchaseRequest);
```
}

packagecom.atguigu.responsibilitychain;

publicclassClient{

```
publicstaticvoidmain(String[]args){
//TODOAuto-generatedmethodstub
//创建一个请求
PurchaseRequestpurchaseRequest=newPurchaseRequest( 1 , 31000 , 1 );
```

 //创建相关的审批人

```
DepartmentApproverdepartmentApprover=newDepartmentApprover("张主任");
CollegeApprovercollegeApprover=newCollegeApprover("李院长");
ViceSchoolMasterApproverviceSchoolMasterApprover=newViceSchoolMasterApprover("王副校");
SchoolMasterApproverschoolMasterApprover=newSchoolMasterApprover("佟校长");
```
 //需要将各个审批级别的下一个设置好 (处理人构成环形:)

```
departmentApprover.setApprover(collegeApprover);
collegeApprover.setApprover(viceSchoolMasterApprover);
viceSchoolMasterApprover.setApprover(schoolMasterApprover);
schoolMasterApprover.setApprover(departmentApprover);
```
```
departmentApprover.processRequest(purchaseRequest);
viceSchoolMasterApprover.processRequest(purchaseRequest);
}
```
 }

packagecom.atguigu.responsibilitychain;

publicclassCollegeApproverextendsApprover{


```
publicCollegeApprover(Stringname){
//TODOAuto-generatedconstructorstub
super(name);
}
```
@Override
publicvoidprocessRequest(PurchaseRequestpurchaseRequest){
//TODOAuto-generatedmethodstub
if(purchaseRequest.getPrice()< 5000 &&purchaseRequest.getPrice()<= 10000 ){
System.out.println("请求编号 id="+purchaseRequest.getId()+" 被 "+this.name+"处理");
}else{
approver.processRequest(purchaseRequest);
}
}
}

packagecom.atguigu.responsibilitychain;

publicclassDepartmentApproverextendsApprover{

```
publicDepartmentApprover(Stringname){
//TODOAuto-generatedconstructorstub
super(name);
}
```

```
@Override
publicvoidprocessRequest(PurchaseRequestpurchaseRequest){
//TODOAuto-generatedmethodstub
if(purchaseRequest.getPrice()<= 5000 ){
System.out.println("请求编号 id="+purchaseRequest.getId()+" 被 "+this.name+"处理");
}else{
approver.processRequest(purchaseRequest);
}
}
```
 }

packagecom.atguigu.responsibilitychain;

 //请求类

publicclassPurchaseRequest{

```
privateinttype= 0 ;//请求类型
privatefloatprice= 0. 0 f;//请求金额
privateintid= 0 ;
//构造器
publicPurchaseRequest(inttype,floatprice,intid){
this.type=type;
this.price=price;
this.id=id;
```

 }

```
publicintgetType(){
returntype;
}
publicfloatgetPrice(){
returnprice;
}
publicintgetId(){
returnid;
}
```
 }

packagecom.atguigu.responsibilitychain;

publicclassSchoolMasterApproverextendsApprover{

```
publicSchoolMasterApprover(Stringname){
//TODOAuto-generatedconstructorstub
super(name);
}
```

@Override
publicvoidprocessRequest(PurchaseRequestpurchaseRequest){
//TODOAuto-generatedmethodstub
if(purchaseRequest.getPrice()> 30000 ){
System.out.println("请求编号 id="+purchaseRequest.getId()+" 被 "+this.name+"处理");
}else{
approver.processRequest(purchaseRequest);
}
}
}

packagecom.atguigu.responsibilitychain;

publicclassViceSchoolMasterApproverextendsApprover{

```
publicViceSchoolMasterApprover(Stringname){
//TODOAuto-generatedconstructorstub
super(name);
}
```
```
@Override
publicvoidprocessRequest(PurchaseRequestpurchaseRequest){
//TODOAuto-generatedmethodstub
if(purchaseRequest.getPrice()< 10000 &&purchaseRequest.getPrice()<= 30000 ){
System.out.println("请求编号 id="+purchaseRequest.getId()+" 被 "+this.name+"处理");
}else{
```

approver.processRequest(purchaseRequest);
}
}
}

### 26 7 职责链模式在SPRINGMVC框架应用的源码分析

1 ) SpringMVC-HandlerExecutionChain 类就使用到职责链模式
2 ) SpringMVC请求流程简图
3 ) 代码分析+Debug源码+说明

 4 ) 源码和说明

packagecom.atguigu.spring.test;

importorg.springframework.web.servlet.HandlerExecutionChain;
importorg.springframework.web.servlet.HandlerInterceptor;

publicclassResponsibilityChain{


publicstaticvoidmain(String[]args){
//TODOAuto-generatedmethodstub

```
//DispatcherServlet
```
```
//说明
/*
*
* protectedvoiddoDispatch(HttpServletRequestrequest,HttpServletResponseresponse)throwsException{
* HandlerExecutionChainmappedHandler=null;
* mappedHandler=getHandler(processedRequest);//获取到HandlerExecutionChain对象
* //在 mappedHandler.applyPreHandle 内部 得到啦 HandlerInterceptorinterceptor
* //调用了拦截器的 interceptor.preHandle
* if(!mappedHandler.applyPreHandle(processedRequest,response)){
return;
}
```
```
//说明：mappedHandler.applyPostHandle 方法内部获取到拦截器，并调用
//拦截器的 interceptor.postHandle(request,response,this.handler,mv);
mappedHandler.applyPostHandle(processedRequest,response,mv);
* }
*
*
* //说明：在 mappedHandler.applyPreHandle内部中，
* 还调用了 triggerAfterCompletion 方法，该方法中调用了
```

```
* HandlerInterceptorinterceptor=getInterceptors()[i];
try{
interceptor.afterCompletion(request,response,this.handler,ex);
}
catch(Throwableex 2 ){
logger.error("HandlerInterceptor.afterCompletionthrewexception",ex 2 );
}
*/
```
 }

 }

 5 ) 对源码总结

 springmvc 请求的流程图中，执行了 拦截器相关方法 interceptor.preHandler 等等
 在处理SpringMvc请求时，使用到职责链模式还使用到适配器模式
 HandlerExecutionChain 主要负责的是请求拦截器的执行和请求处理,但是他本身不处理请求，只是将请求分配
给链上注册处理器执行，这是职责链实现方式,减少职责链本身与处理逻辑之间的耦合,规范了处理流程
 HandlerExecutionChain 维护了 HandlerInterceptor 的集合， 可以向其中注册相应的拦截器.

### 26 8 职责链模式的注意事项和细节

 1 ) 将请求和处理分开，实现解耦，提高系统的灵活性

 2 ) 简化了对象，使对象不需要知道链的结构

3 ) 性能会受到影响，特别是在链比较长的时候，因此需控制链中最大节点数量，一般通过在Handler中设置一个
最大节点数量，在setNext()方法中判断是否已经超过阀值，超过则不允许该链建立，避免出现超长链无意识地
破坏系统性能


 4 ) 调试不方便。采用了类似递归的方式，调试时逻辑可能比较复杂

5 ) 最佳应用场景：有多个对象可以处理同一个请求时，比如：多级请求、请假/加薪等审批流程、JavaWeb中Tomcat
对Encoding的处理、拦截