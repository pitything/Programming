# Java集合

## 概述

> 数组的局限性
>
> - 数组初始化之后，长度固定不可变，类型也固定了
> - 数组的方法少，不便于进行添加、删除、插入等操作，且效率不高。同时无法直接获取存储元素的个数
> - 数组是可重复的，对于不可重复的需求不能满足
>
> 集合
>
> - Collection接口：单列数据，定义了存取一组对象的方法的集合
>- List：元素有序、可重复的集合
>   - Set：元素无序、不可重复的集合
>- Map接口：双列数据，保存具有映射关系“key-value对”的集合

## Collection

### 类关系图

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220705173918756.png" alt="image-20220705173918756" style="zoom:50%;" />

### Collection接口

> - Collection接口是Set、Queue、List的父接口
> - JDK5增加了泛型，Java集合可以标记容器中的对象类型

#### 常用方法

```java
Collection<Integer> collection = new ArrayList<>();
// 1.添加
collection.add(1);
collection.add(2);
collection.add(3);
collection.add(4);
collection.add(5);
collection.addAll(new ArrayList<Integer>(){{add(6);}});
System.out.println(collection); // [1, 2, 3, 4, 5, 6]
// 2.获取有效元素的个数:6
System.out.println(collection.size());
// 3.是否包含某个元素,用元素的equals方法来判断，拿两个集合的元素挨个比较
System.out.println(collection.contains(3));                                      // true
System.out.println(collection.containsAll(new ArrayList<Integer>() {{add(3);}}));// true
// 4.删除：通过元素的equals方法判断是否是要删除的那个元素。只会删除找到的第一个元素
System.out.println(collection.remove(3)); // true
System.out.println(collection.removeAll(new ArrayList<Integer>() {{add(2);}})); // true
// 5.把交集的结果存在当前集合中，不影响其他集合
System.out.println(collection.retainAll(new ArrayList<Integer>() {{add(4);add(5);add(6);}}));//true
// 6.集合是否相等
System.out.println(collection.equals(new ArrayList<Integer>() {{add(4);add(5);}}));// false
// 7.转成对象数组
System.out.println(Arrays.toString(collection.toArray(new Integer[collection.size()])));//[4, 5, 6]
// 8.获取集合对象的哈希值
System.out.println(collection.hashCode());
// 9.返回迭代器对象，用于集合遍历
Iterator<Integer> iterator2 = collection.iterator();// 33796
// 10.清空集合
collection.clear();
// 11.是否是空集合
System.out.println(collection.isEmpty());// true
```

### Iterator迭代器

> -  Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。
> - GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。**迭代器模式，就是为容器而生。**类似于“公交车上的售票员”、“火车上的乘务员”、“空姐”。 
> - Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。 
> - Iterator 仅用于遍历集合，Iterator 本身并不提供承装对象的能力。如果需要创建Iterator 对象，则必须有一个被迭代的集合。
> - 集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。

#### 常用方法

> 注意：
>
> - Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove方法。 
> - 如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，再调用remove都会报IllegalStateException。

```java
Collection<String> collection2 = new ArrayList<String>(8){{
  add("a");
  add("b");
  add("c");
  add("d");
  add("e");
}};
// 1.获取迭代器
Iterator<String> iterator2 = collection2.iterator();
// 2.判断是否还有下一个元素
// 在调用it.next()方法之前必须要调用it.hasNext()进行检测。
// 若不调用，且下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常。
while (iterator2.hasNext()){
//            iterator2.remove(); // 要先调用next()将指针下移，否则抛出异常：java.lang.IllegalStateException
  // 3.将下一个元素赋给变量a：:①指针下移 ②将下移以后集合位置上的元素返回
  String str = iterator2.next();
  System.out.println(str);
  if(str == "a"){
    // 4.移除当前元素：会将expectedModCount = modCount
    iterator2.remove();
    // 用集合实例的remove，会导致修改数modCount+1，而期望修改数expectedModCount没变
    // 再次调用next()方法，从而抛出异常：java.util.ConcurrentModificationException
//                collection2.remove(str);
  }
  // 如果是倒数第二个元素删除，不会报错，因为hasNext()方法：:cursor != size;返回了false，不会再进入循环调用next()，不会抛出异常
//            if ("d".equals(str)){
//                collection2.remove(str);
//            }
  // 如果是最后一个元素删除，hasNext():cursor != size;返回true，因为size减少了一个，之后调用next()，同样抛出异常
//            if ("e".equals(str)){
//                collection2.remove(str);
//            }
}
System.out.println(collection2); // [b, c, d, e]
```

#### foreach循环遍历

> - Java 5.0 提供了 foreach 循环迭代访问 Collection和数组。
> - 遍历操作不需获取Collection或数组的长度，无需使用索引访问元素。
> - 遍历集合的底层调用Iterator完成操作，iterator.hasNext()，iterator.next()
> - foreach还可以用来遍历数组。

```java
Collection<String> collection3 = new ArrayList<String>(){{
  add("a");
  add("b");
  add("c");
  add("d");
  add("e");
}};
for (String entity : collection3) {
  System.out.println(entity);
}

int[] intArray = new int[]{1, 2, 3, 4, 5};
for (int entity : intArray) {
  System.out.println(entity);
}
```

### List接口

> - 鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组
> - List集合类中**元素有序、且可重复**，集合中的每个元素都有其对应的顺序索引。
> - List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。
> - JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。

#### 常用方法

> List除了从Collection集合继承的方法外，List 集合里添加了一些根据索引操作集合元素的方法。

```java
List<String> list1 = new ArrayList<>();
// 1.在index位置插入ele元素
list1.add(0, "222");
// 2.从index位置开始将所有元素添加进来
list1.addAll(1, new ArrayList<String>(){{add("333");add("444");add("555");}});
System.out.println(list1); //[222, 333, 444, 555]
// 3.获取指定index位置的元素: 555
System.out.println(list1.get(3));
// 4.返回obj在集合中首次出现的位置：2
System.out.println(list1.indexOf("444"));
// 5.返回obj在当前集合中末次出现的位置：2
System.out.println(list1.lastIndexOf("444"));
// 6.移除指定index位置的元素，并返回此元素：444
// 注意：如果参数为int，调用该方法；否则调用remove(obj)
System.out.println(list1.remove(2));
// 7.设置指定index位置的元素为ele：[222, 333, 22222]
list1.set(2, "22222");
// 8.返回从fromIndex到toIndex位置的子集合：[0,2)：[222, 333]
System.out.println(list1.subList(0, 2));
```

#### ArrayList

> - ArrayList是List接口的实现类之一，本质上是一个可变长度的数组
> - JDK1.7：直接创建一个初始容量为10的数组；JDK1.8：一开始创建一个长度为0的数组，当添加第一个元素时再创建一个始容量为10的数组
> - 每次扩容grow()为1.5倍
> - 注意：数组->List，使用Arrays.asList()，返回的是Arrays.ArrayList静态内部类，而不是这个ArrayList类

##### ArrayList优缺点

> **优点**
>
> - ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。
> - ArrayList 在顺序添加一个元素的时候非常方便。
>
> **缺点**
>
> - 删除、插入元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。 
>
> **总结**
>
> - ArrayList 比较适合顺序添加、随机访问的场景。

#### LinkedList

> - 本质上是一个双向链表，是定义了Node类型的first和last，用于记录首末元素 。
> - Node类型：item存储数据、next表示后一Node、prev表示前一Node
> - 对于**频繁的插入或删除元素**的操作，建议使用LinkedList类，效率较高

##### 新增方法

```java
//   [cc, ff, dd, ee, cc, ff]
LinkedList<String> list4 = new LinkedList<String>()			   {{add("cc");add("ff");add("dd");add("ee");add("cc");add("ff");}};

list4.addFirst("aa"); // [aa, cc, ff, dd, ee, cc, ff]
list4.addLast("zz");  // [aa, cc, ff, dd, ee, cc, ff, zz]
System.out.println(list4.getFirst()); // aa
System.out.println(list4.getLast());  // zz
System.out.println(list4.removeFirst());// aa, [cc, ff, dd, ee, cc, ff, zz]
System.out.println(list4.removeLast()); // zz, [cc, ff, dd, ee, cc, ff]
list4.removeFirstOccurrence("cc"); // 同remove("cc")：[ff, dd, ee, cc, ff]
list4.removeLastOccurrence("ff"); // [ff, dd, ee, cc]
```

##### **ArrayList** **和** **LinkedList** 区别

> - 数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。
> - 随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。
> - 增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为ArrayList 增删操作要影响数组内的其他数据的下标。
> - 内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。
> - 线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；
> - 在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。

#### Vector

> - Vector 在JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是**线程安全**的。
> - 初识容量为10，每次扩容默认为2倍，可以设置
> - public Vector(int initialCapacity, int capacityIncrement)：initialCapacity：初识容量；capacityIncrement：每次扩容大小

##### 常用方法

```java
 // [aa, bb, cc, dd]
Vector<String> vector1 = new Vector<String>(){{add("aa");add("bb");add("cc");add("dd");}};
vector1.addElement("ff"); // [aa, bb, cc, dd, ff]
vector1.insertElementAt("kk", 0); // [kk, aa, bb, cc, dd, ff]
vector1.setElementAt("jj", 1); // [kk, jj, bb, cc, dd, ff]
vector1.removeElement("dd"); // [kk, jj, bb, cc, ff]
vector1.removeAllElements();  // 空
```

##### ArrayList和Vector的区别

> - 线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而ArrayList 是非线程安全的。
> - 性能：ArrayList 在性能方面要优于 Vector。
> - 扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。
> - Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。
> - Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。

### Set接口

> - Set接口是Collection的子接口，Set接口没有提供额外的方法
> - Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set 集合中，则添加操作失败。
> - Set 判断两个对象是否相同不是使用 == 运算符，而是根据 equals() 方法
> - Set接口的主要实现：HashSet、LinkedHashSet、TreeSet

#### List和Set区别

> - List , Set 都是继承自Collection 接口
>
> - List 特点：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。
>
> - Set 特点：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是HashSet、LinkedHashSet 以及 TreeSet。
> - 另外 List 支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。
>
> - Set和List对比
>   - Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。
>   - List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变

#### HashSet

> - 不能保证数据顺序排序，但是保证数据不可重复，元素可以为null
> - 线程不安全
> - 基于 **HashMap**实现，HashMap底层用的是 Node<K,V>[] 数组
>   - HashSet的值就是HashMap的Key，HashMap的值PRESENT = new Object()；
>   - HashSet的add使用HashMap的put
> - 初始容量为16，当如果使用率超过0.75，（16*0.75=12）就会扩大容量为原来的2倍。
> - 判断对象相等：两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等。所以放在HashSet中的对象一定要实现**equals()**和**hashCode(Object obj)**方法

```java
HashSet<TestHash> set = new HashSet<>();
set.add(new TestHash(11, true));
set.add(new TestHash(21, true));
set.add(new TestHash(51, true));
set.add(new TestHash(31, true));
set.add(new TestHash(31, false));
System.out.println(set);  // [TestHash{x=31}, TestHash{x=31}, TestHash{x=11}, TestHash{x=21}, TestHash{x=51}]
```

##### 向HashSet中添加元素的过程

> - 当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法到该对象的 hashCode 值，然后根据 hashCode 值，通过某种散列函数决定该对象在 HashSet 底层数组中的存储位置。（这个散列函数会与底层数组的长度相计算得到在数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布，该散列函数设计的越好） 
>
> - 如果两个元素的hashCode()值相等，会再继续调用equals方法，如果equals方法结果为true，添加失败；如果为false，那么会保存该元素，但是该数组的位置已经有元素了，那么会通过链表的方式继续链接。 
> - **注意**：如果两个元素的 equals() 方法返回 true，但它们的 hashCode() 返回值不相等，hashSet 将会把它们存储在不同的位置，但依然可以添加成功。

##### equals()和hashCode()

> - 两个对象相等，equals方法返回true，hashcode一定也是相同的
> - 两个对象有相同的hashcode值，它们也不一定是相等的
> - 重写了hashCode()，那么equals()也要重写，否则会导致多个同样的对象能放入到Hash容器中，出现错误
> - 对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。
> - hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）

#### LinkedHashSet

> - LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的。
> - LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。
> - LinkedHashSet 不允许集合元素重复。
> - 初始容量为16，当如果使用率超过0.75，（16*0.75=12）就会扩大容量为原来的2倍。
> - 使用LinkedHashMap存储数据（在HashSet的构造器中体现）

```java
LinkedHashSet linkedHashSet = new LinkedHashSet();
linkedHashSet.add(new TestHash(11, true));
linkedHashSet.add(new TestHash(21, true));
linkedHashSet.add(new TestHash(51, true));
linkedHashSet.add(new TestHash(31, true));
linkedHashSet.add(new TestHash(31, false));
System.out.println(linkedHashSet);// [TestHash{x=11}, TestHash{x=21}, TestHash{x=51}, TestHash{x=31}, TestHash{x=31}]
```

#### TreeSet

> - TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态
> - 要求放入对象的类型相同，且该对象实现了Comparable接口，重写了compareTo方法，否则报错：java.lang.ClassCastException: TestHash cannot be cast to java.lang.Comparable；
> - 对于compareTo方法相等的对象，不会放入到set中
> - 重写compareTo方法后，应该重写对象对应的 equals() 方法，应保证该方法与 compareTo(Object obj) 方法有一致的结果
> - TreeSet底层使用**红黑树**结构存储数据
> - TreeSet 两种排序方法：**自然排序**和**定制排序**。默认情况下，TreeSet 采用自然排序。

##### 常用方法

```java
TreeSet<TestHash> treeSet = new TreeSet<>();
treeSet.add(new TestHash(5, true));
treeSet.add(new TestHash(3, true));
treeSet.add(new TestHash(2, true));
treeSet.add(new TestHash(31, true));
treeSet.add(new TestHash(31, false));
// 自动排序：按照对象的compareTo方法，[TestHash{x=2}, TestHash{x=3}, TestHash{x=5}, TestHash{x=31}]
// 注意：TreeSet根据重写的compareTo方法判断是否相等，如果TestHash只根据x判断，那么new TestHash(31, false)不能插入set中
System.out.println(treeSet);
System.out.println(treeSet.comparator());
System.out.println(treeSet.first()); // 第一个：TestHash{x=2}
System.out.println(treeSet.last()); // 最后一个：TestHash{x=31}
System.out.println(treeSet.lower(new TestHash(6, true)));// 小于6的第一个：TestHash{x=5}
System.out.println(treeSet.higher(new TestHash(4, true))); // 大于4的第一个：TestHash{x=5}
// 分隔[x=2, x=5)：[TestHash{x=2}, TestHash{x=3}]
System.out.println(treeSet.subSet(new TestHash(2, true), new TestHash(5, true)));
System.out.println(treeSet.headSet(new TestHash(5, true)));// 小于5的所有：[TestHash{x=2}, TestHash{x=3}]
System.out.println(treeSet.tailSet(new TestHash(5, true)));// 大于等于5的所有：[TestHash{x=5}, TestHash{x=31}]
```

## Map

### 类关系图

![](https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220705215835761.png)