# 数据结构与算法


##  概述

### 数据结构和算法的关系

> - 数据结构(data structure)是一门研究组织数据方式的学科，有了编程语言也就有了数据结构.学好数据结构可以编写出更加漂亮,更加有效率的代码。
> - 要学习好数据结构就要多多考虑如何将生活中遇到的问题,用程序去实现解决.
> - 程序 = 数据结构 + 算法
> - 数据结构是算法的基础, 换言之，想要学好算法，需要把数据结构学到位。

###  线性结构和非线性结构

> 数据结构包括：线性结构和非线性结构。
>
> **线性结构**
>
> - 线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系
> - 线性结构有两种不同的存储结构，即顺序存储结构 ( `数组` ) 和链式存储结构 ( `链表 `) 。
>   - 顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的
>   - 链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息
> - 线性结构常见的有：栈、队列、数组、链表
>
> **非线性结构**
>
> - 非线性结构包括：二维数组，多维数组，广义表，树结构，图结构

## 稀疏数组和队列

### 数组(array)

> 数组是一种连续存储线性结构，元素类型相同，大小相等，数组是多维的，通过使用整型索引值来访问他们的元素，数组尺寸不能改变。

#### 优缺点

>数组的优点:
>
>- 存取速度快
>
>数组的缺点:
>
>- 事先必须知道数组的长度
>- 插入删除元素很慢
>- 空间通常是有限制的
>- 需要大块连续的内存块
>- 插入删除元素的效率很低

### 稀疏数组(sparse array)

#### 基本介绍

>  当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。

#### 处理方法

> 记录数组一共有几行几列，有多少个不同的值
>
> 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模

#### 整体思路分析

![image-20220717103515250](https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220717103515250.png)

#### 代码实现

> 二维数组 -> 稀疏数组

```java
// 1. 先遍历二维数组 得到非 0 数据的个数
int sum = 0;
for (int i = 0; i < 11; i++) {
  for (int j = 0; j < 11; j++) {
    if (chessArr[i][j] != 0) {
      sum++;
    }
  }
}
// 2. 创建对应的稀疏数组
int sparseArray[][] = new int[sum + 1][3];
// 给稀疏数组赋值
sparseArray[0][0] = 11;
sparseArray[0][1] = 11;
sparseArray[0][2] = sum;
// 遍历二维数组，将非 0 的值存放到 sparseArr中
int count = 0;//count 用于记录是第几个非 0 数据
for (int i = 0; i < 11; i++) {
  for (int j = 0; j < 11; j++) {
    if (chessArr[i][j] != 0) {
      count++;
      sparseArray[count][0] = i;
      sparseArray[count][1] = j;
      sparseArray[count][2] = chessArr[i][j];
    }
  }
}
```

> 稀疏数组 -> 二维数组

```java
// 1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组
int chessArr2[][] = new int[sparseArray[0][0]][sparseArray[0][1]];
// 2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可
for (int i = 1; i < sparseArray.length; i++) {
    chessArr2[sparseArray[i][0]][sparseArray[i][1]] = sparseArray[i][2];
}
```

### 队列(Queue)

#### 队列介绍

> - 队列是一个有序列表，可以用**数组或是链表**来实现。
> - 遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出


#### 数组实现队列

> - 队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 maxSize 是该队
>   列的最大容量。
>
> - 因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front及 rear分别记录队列前后端的下标，
>   front 会随着数据输出而改变，而 rear则是随着数据输入而改变
>
> - rear：队列尾部；front：队列头部
>
>   ![image-20220717102208731](https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220717102208731.png)
>
> - 当我们将数据**存入队列**时称为”addQueue”，addQueue 的处理需要有两个步骤：
>   
>   - 将尾指针往后移：rear+ 1，当front==rear 【队列空】
>   - 若尾指针 rear 小于队列的最大下标 maxSize- 1 ，则将数据存入 rear所指的数组元素中，否则无法存入数据。
>     当rear ==maxSize- 1 【队列满】
##### 代码实现

```java
package 数据结构;

import java.util.Scanner;

public class _2_数组实现队列 {
    public static void main(String[] args) {
        //创建一个队列
        ArrayQueue queue = new ArrayQueue(3);
        char key;//接收用户输入
        Scanner scanner = new Scanner(System.in);//
        boolean loop = true;
        //输出一个菜单
        while (loop) {
            System.out.println("s(show): 显示队列");
            System.out.println("e(exit): 退出程序");
            System.out.println("a(add): 添加数据到队列");
            System.out.println("g(get): 从队列取出数据");
            System.out.println("h(head): 查看队列头的数据");
            key = scanner.next().charAt(0);//接收一个字符
            switch (key) {
                case 's':
                    queue.showQueue();
                    break;
                case 'a':
                    System.out.println("输出一个数");
                    int value = scanner.nextInt();
                    queue.addQueue(value);
                    break;
                case 'g'://取出数据
                    try {
                        int res = queue.getQueue();
                        System.out.printf("取出的数据是%d\n", res);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'h'://查看队列头的数据
                    try {
                        int res = queue.headQueue();
                        System.out.printf("队列头的数据是%d\n", res);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'e'://退出
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出~~");
    }
}

// 使用数组模拟队列-编写一个ArrayQueue类
class ArrayQueue {
    private int maxSize;// 表示数组的最大容量
    private int front;// 队列头
    private int rear;// 队列尾
    private int[] arr;// 该数据用于存放数据, 模拟队列

    // 创建队列的构造器
    public ArrayQueue(int arrMaxSize) {
        maxSize = arrMaxSize;
        arr = new int[maxSize];
        front = -1;// 指向队列头部，分析出front是指向队列头的前一个位置.
        rear = -1;// 指向队列尾，指向队列尾的数据(即就是队列最后一个数据)
    }

    // 判断队列是否满
    public boolean isFull() {
        return rear == maxSize - 1;
    }

    // 判断队列是否为空
    public boolean isEmpty() {
        return rear == front;
    }

    // 添加数据到队列
    public void addQueue(int n) {
        // 判断队列是否满
        if (isFull()) {
            System.out.println("队列满，不能加入数据~");
            return;
        }
        rear++;// 让rear 后移
        arr[rear] = n;
    }

    // 获取队列的数据, 出队列
    public int getQueue() {
        // 判断队列是否空
        if (isEmpty()) {
        // 通过抛出异常
            throw new RuntimeException("队列空，不能取数据");
        }
        front++;//front后移
        int res = arr[front];
        arr[front] = 0;
        return res;
    }

    // 显示队列的所有数据
    public void showQueue() {
        // 遍历
        if (isEmpty()) {
            System.out.println("队列空的，没有数据~~");
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.printf("arr[%d]=%d\n", i, arr[i]);
        }
    }

    // 显示队列的头数据， 注意不是取出数据
    public int headQueue() {
        // 判断
        if (isEmpty()) {
            throw new RuntimeException("队列空的，没有数据~~");
        }
        return arr[front + 1];
    }
}
```

#### 数组模拟环形队列.

##### 问题分析并优化

> - 目前数组使用一次就不能用， 没有达到复用的效果
> - 将这个数组使用算法，改进成一个**环形的队列 取模：%**

##### 分析说明

> - 尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定,这个在做判断队列满的时候需要注意 (rear+ 1 )%maxSize==front [满]
>
> - rear==front[空]
>
> - 分析示意图:
>
>   <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220717110348737.png" alt="image-20220717110348737" style="zoom:50%;" />

##### 代码实现
```java
package 数据结构;

import java.util.Scanner;

public class _3_数组实现环形队列 {
    public static void main(String[] args) {
        // 创建一个环形队列
        CircleArray queue = new CircleArray(4);//说明设置 4 , 其队列的有效数据最大是 3
        char key;// 接收用户输入
        Scanner scanner = new Scanner(System.in);//
        boolean loop = true;
        // 输出一个菜单
        while (loop) {
            System.out.println("s(show): 显示队列");
            System.out.println("e(exit): 退出程序");
            System.out.println("a(add): 添加数据到队列");
            System.out.println("g(get): 从队列取出数据");
            System.out.println("h(head): 查看队列头的数据");
            key = scanner.next().charAt(0);// 接收一个字符
            switch (key) {
                case 's':
                    queue.showQueue();
                    break;
                case 'a':
                    System.out.println("输出一个数");
                    int value = scanner.nextInt();
                    queue.addQueue(value);
                    break;
                case 'g':// 取出数据
                    try {
                        int res = queue.getQueue();
                        System.out.printf("取出的数据是%d\n", res);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'h':// 查看队列头的数据
                    try {
                        int res = queue.headQueue();
                        System.out.printf("队列头的数据是%d\n", res);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'e':// 退出
                    scanner.close();

                    loop = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出~~");
    }
}

class CircleArray {
    private int maxSize;// 表示数组的最大容量
    //front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素
    //front 的初始值 = 0
    private int front;
    //rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.
    //rear 的初始值 = 0
    private int rear;// 队列尾
    private int[] arr;// 该数据用于存放数据, 模拟队列

    public CircleArray(int arrMaxSize) {
        maxSize = arrMaxSize;
        arr = new int[maxSize];
    }

    // 判断队列是否满
    public boolean isFull() {
        return (rear + 1) % maxSize == front;
        //如果是这样写的话，不能判断空和满的状态，一开始都为0，默认就是满的
//        return (rear) % maxSize == front;
    }

    // 判断队列是否为空
    public boolean isEmpty() {
        return rear == front;
    }

    // 添加数据到队列
    public void addQueue(int n) {
        // 判断队列是否满
        if (isFull()) {
            System.out.println("队列满，不能加入数据~");
            return;
        }
        //直接将数据加入
        arr[rear] = n;
        //将 rear 后移, 这里必须考虑取模
        rear = (rear + 1) % maxSize;
    }

    // 获取队列的数据, 出队列
    public int getQueue() {
        // 判断队列是否空
        if (isEmpty()) {
            // 通过抛出异常
            throw new RuntimeException("队列空，不能取数据");
        }
        // 这里需要分析出 front是指向队列的第一个元素
        // 1. 先把 front 对应的值保留到一个临时变量
        // 2. 将 front 后移, 考虑取模
        // 3. 将临时保存的变量返回
        int value = arr[front];
        front = (front + 1) % maxSize;
        return value;
    }

    // 显示队列的所有数据
    public void showQueue() {
        // 遍历
        if (isEmpty()) {
            System.out.println("队列空的，没有数据~~");
            return;
        }
        // 思路：从front开始遍历，遍历多少个元素
        // 动脑筋
        for (int i = front; i < front + size(); i++) {
            System.out.printf("arr[%d]=%d\n", i % maxSize, arr[i % maxSize]);
        }
    }

    // 求出当前队列有效数据的个数
    public int size() {
        //rear= 2
        //front= 1
        //maxSize= 3
        return (rear + maxSize - front) % maxSize;
    }

    // 显示队列的头数据， 注意不是取出数据
    public int headQueue() {
        // 判断
        if (isEmpty()) {
            throw new RuntimeException("队列空的，没有数据~~");
        }
        return arr[front];
    }
}
```

## 链表(LinkedList)

### 介绍

> 链表是有序的列表，但是它在内存中是存储如下
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220717150724643.png" alt="image-20220717150724643" style="zoom:50%;" />
>
> - 链表是以节点的方式来存储,是链式存储
>
> - 每个节点包含 data 域， next 域：指向下一个节点.
>
> - 如图：发现链表的各个节点不一定是连续存储.
> - 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定
>
> - 单链表(带头节点) 逻辑结构示意图如下
>
>   <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220717150900936.png" alt="image-20220717150900936" style="zoom:50%;" />


### 单链表的应用实例

> - 使用带head头的单向链表实现 –水浒英雄排行榜管理完成对英雄人物的增删改查操作
>
>   - 添加英雄时，直接添加到链表的尾部思路分析示意图:
>
>     <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220717153201903.png" alt="image-20220717153201903" style="zoom:50%;" />
>
>   - 添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示)
>
>     <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220718134308480.png" alt="image-20220718134308480" style="zoom:60%;" />
>
>   - 修改节点功能思路：先通过遍历找到该节点，在进行修改temp.name=newHeroNode.name;temp.nickname=newHeroNode.nickname
>
>   - 删除节点
>   
>     <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220717153310245.png" alt="image-20220717153310245" style="zoom:50%;" />

#### 代码实现
```java
package 数据结构;

public class _4_单链表代码实现 {
    public static void main(String[] args) {
        //进行测试
        //先创建节点
        HeroNode hero1 = new HeroNode(1, "宋江", "及时雨");
        HeroNode hero2 = new HeroNode(2, "卢俊义", "玉麒麟");
        HeroNode hero3 = new HeroNode(3, "吴用", "智多星");
        HeroNode hero4 = new HeroNode(4, "林冲", "豹子头");

        //创建要给链表
        SingleLinkedList singleLinkedList = new SingleLinkedList();
        //加入
        // singleLinkedList.add(hero1);
        // singleLinkedList.add(hero4);
        // singleLinkedList.add(hero2);
        // singleLinkedList.add(hero3);

        //加入按照编号的顺序
        singleLinkedList.addByNo(hero1);
        singleLinkedList.addByNo(hero4);
        singleLinkedList.addByNo(hero2);
        singleLinkedList.addByNo(hero3);
        System.out.println("插入后的链表情况~~");
        singleLinkedList.list();

        //测试修改节点的代码
        HeroNode newHeroNode = new HeroNode(2, "小卢", "玉麒麟~~");
        singleLinkedList.update(newHeroNode);
        System.out.println("修改后的链表情况~~");
        singleLinkedList.list();

        //删除一个节点
        singleLinkedList.del(1);
        singleLinkedList.del(4);
        System.out.println("删除后的链表情况~~");
        singleLinkedList.list();
    }
}

//定义SingleLinkedList 管理我们的英雄
class SingleLinkedList {
    //先初始化一个头节点, 头节点不要动, 不存放具体的数据
    private HeroNode head = new HeroNode(0, "", "");

    //添加节点到单向链表，不考虑编号顺序
    // 1. 找到当前链表的最后节点
    // 2. 将最后这个节点的next 指向 新的节点
    public void add(HeroNode heroNode) {
        //因为head节点不能动，因此我们需要一个辅助遍历 temp
        HeroNode temp = head;
        //遍历链表，找到最后
        while (true) {
            //找到链表的最后
            if (temp.next == null) {//
                break;
            }
            //如果没有找到最后, 将temp后移
            temp = temp.next;
        }
        //当退出while循环时，temp就指向了链表的最后
        //将最后这个节点的next 指向 新的节点
        temp.next = heroNode;
    }

    //第二种方式在添加英雄时，根据排名将英雄插入到指定位置
    //(如果有这个排名，则添加失败，并给出提示)
    public void addByNo(HeroNode heroNode) {
        //因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置
        //因为单链表，因为我们找的temp 是位于 添加位置的前一个节点，否则插入不了
        HeroNode temp = head;
        boolean flag = false;//flag标志添加的编号是否存在，默认为false
        while (true) {
            if (temp.next == null) {//说明temp已经在链表的最后
                break;//
            }
            if (temp.next.no > heroNode.no) {//位置找到，就在temp的后面插入
                break;
            } else if (temp.next.no == heroNode.no) {//说明希望添加的heroNode 的编号已然存在
                flag = true;//说明编号存在
                break;
            }
            temp = temp.next;//后移，遍历当前链表
        }
        //判断flag 的值
        if (flag) {//不能添加，说明编号存在
            System.out.printf("准备插入的英雄的编号 %d 已经存在了, 不能加入\n", heroNode.no);
        } else {
            //插入到链表中,temp的后面
            heroNode.next = temp.next;
            temp.next = heroNode;
        }
    }

    //修改节点的信息, 根据no编号来修改，即no编号不能改.
    // 1. 根据 new HeroNode  的 no 来修改即可
    public void update(HeroNode newHeroNode) {
        //判断是否空
        if (head.next == null) {
            System.out.println("链表为空~");
            return;
        }
        //找到需要修改的节点, 根据no编号
        //定义一个辅助变量
        HeroNode temp = head;
        boolean flag = false;//表示是否找到该节点
        while (true) {
            if (temp.next == null) {
                break;//已经遍历完链表
            }
            if (temp.next.no == newHeroNode.no) {
                //找到
                flag = true;
                break;
            }
            temp = temp.next;
        }
        //根据flag 判断是否找到要修改的节点
        if (flag) {
            temp.next.name = newHeroNode.name;
            temp.next.nickname = newHeroNode.nickname;
        } else {//没有找到
            System.out.printf("没有找到 编号 %d 的节点，不能修改\n", newHeroNode.no);
        }
    }

    //删除节点
    // 1 .head 不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点
    // 2. 说明我们在比较时，是temp.next.no 和 需要删除的节点的no比较
    public void del(int no) {
        HeroNode temp = head;
        boolean flag = false;// 标志是否找到待删除节点的
        while (true) {
            if (temp.next == null) {//已经到链表的最后
                break;
            }
            if (temp.next.no == no) {
                //找到的待删除节点的前一个节点temp
                flag = true;
                break;
            }
            temp = temp.next;//temp后移，遍历
        }
        //判断flag
        if (flag) {//找到
            //可以删除
            temp.next = temp.next.next;
        } else {
            System.out.printf("要删除的 %d 节点不存在\n", no);
        }
    }

    //显示链表[遍历]
    public void list() {
        //判断链表是否为空
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }
        //因为头节点，不能动，因此我们需要一个辅助变量来遍历
        HeroNode temp = head.next;
        while (true) {
            //判断是否到链表最后
            if (temp == null) {
                break;
            }
            //输出节点的信息
            System.out.println(temp);
            //将temp后移， 一定小心
            temp = temp.next;
        }
    }
}

//定义HeroNode，每个HeroNode对象就是一个节点
class HeroNode {
    public int no; // 编号
    public String name;// 名称
    public String nickname;// 昵称
    public HeroNode next;//指向下一个节点

    //构造器
    public HeroNode(int no, String name, String nickname) {
        this.no = no;
        this.name = name;
        this.nickname = nickname;
    }

    //为了显示方法，我们重新toString
    @Override
    public String toString() {
        return "HeroNode [no=" + no + ",name=" + name + ",nickname=" + nickname + "]";
    }
}
```

### 单链表面试题(新浪、百度、腾讯)

#### 求单链表中有效节点的个数
```java
/**
	* @return 返回的就是有效节点的个数(如果是带头节点的链表，需求不统计头节点)
  * @paramhead 链表的头节点
*/
public static int getLength(HeroNode head){
  if (head.next == null) {//空链表
    return 0;
  }
  int length = 0;
  //定义一个辅助的变量, 这里我们没有统计头节点
  HeroNode cur = head.next;
  while (cur != null) {
    length++;
    cur = cur.next;//遍历
  }
  return length;
}
```
#### 查找单链表中的倒数第k个节点 【新浪面试题】

```java
 /**
     * 查找单链表中的倒数第k个节点 【新浪面试题】
     * 1. 编写一个方法，接收head节点，同时接收一个index
     * 2 .index 表示是倒数第index个节点
     * 3. 先把链表从头到尾遍历，得到链表的总的长度 getLength
     * 4. 得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到
     * 5. 如果找到了，则返回该节点，否则返回nulll
     */
public static HeroNode findLastIndexNode(HeroNode head, int index) {
  //判断如果链表为空，返回null
  if (head.next == null) {
    return null;//没有找到
  }
  //第一个遍历得到链表的长度(节点个数)
  int size = getLength(head);
  //第二次遍历 size-index 位置，就是我们倒数的第K个节点
  //先做一个index的校验
  if (index <= 0 || index > size) {
    return null;
  }
  //定义给辅助变量，for 循环定位到倒数的index
  HeroNode cur = head.next;// 3 // 3 - 1 = 2
  for (int i = 0; i < size - index; i++) {
    cur = cur.next;
  }
  return cur;
}
```

#### 单链表的反转【腾讯面试题，有点难度】
```java
/**
     * 将单链表反转1
     */
public static void reversetList1(HeroNode node){
  if(node.next == null || node.next.next == null) return;
  HeroNode newNode = new HeroNode(0, "", "");
  HeroNode temp = node.next;
  Stack<HeroNode> stack = new Stack<>();
  while(temp != null){
    stack.push(temp);
    temp = temp.next;
  }
  HeroNode temp2 = newNode;
  while(!stack.empty()){
    temp = stack.pop();
    temp2.next = temp;
    temp2 = temp2.next;
  }
  temp2.next = null;
  node.next = newNode.next;
}

/**
     * 将单链表反转2
     */
public static void reversetList2(HeroNode head) {
  //如果当前链表为空，或者只有一个节点，无需反转，直接返回
  if (head.next == null || head.next.next == null) return;

  //定义一个辅助的指针(变量)，帮助我们遍历原来的链表
  HeroNode cur = head.next;
  HeroNode next;// 指向当前节点[cur]的下一个节点
  HeroNode reverseHead = new HeroNode(0, "", "");
  //遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端(头插法)
  while (cur != null) {
    next = cur.next;//先暂时保存当前节点的下一个节点，因为后面需要使用
    cur.next = reverseHead.next;//将cur的下一个节点指向新的链表的最前端
    reverseHead.next = cur;//将cur 连接到新的链表上
    cur = next;//让cur后移
  }
  //将head.next 指向 reverseHead.next, 实现单链表的反转
  head.next = reverseHead.next;
}
```
#### 从尾到头打印单链表 【百度，方式1：反向遍历；方式2：Stack栈】

 ```java
 /**
     * 单链表的逆序打印1：栈
      */
public static void reversePrint1(HeroNode head) {
  if (head.next == null) {
    return;//空链表，不能打印
  }
  //创建要给一个栈，将各个节点压入栈
  Stack<HeroNode> stack = new Stack<HeroNode>();
  HeroNode cur = head.next;
  //将链表的所有节点压入栈
  while (cur != null) {
    stack.push(cur);
    cur = cur.next;//cur后移，这样就可以压入下一个节点
  }
  //将栈中的节点进行打印,pop 出栈
  while (stack.size() > 0) {
    System.out.println(stack.pop());//stack的特点是先进后出
  }
}

/**
     * 单链表的逆序打印2：递归
      */
public static void reversePrint2(HeroNode head) {
  if(head.next != null) {
    reversePrint2(head.next);
    System.out.println(head.next);
  }
}
 ```
#### 合并两个有序的单链表，合并之后的链表依然有序

### 双向链表应用实例

> - 使用带head头的双向链表实现 –水浒英雄排行榜
> - 管理单向链表的缺点分析:
>   - 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。
>   - 单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以自我删除，所以前面我们单链表删除时节点，总是找到temp,temp是待删除节点的前一个节点(认真体会).
>   - 分析了双向链表如何完成遍历，添加，修改和删除的思路

#### 双向链表的操作思路

> - 遍历方法和单链表一样，只是可以向前，也可以向后查找
> - 添加 (默认添加到双向链表的最后)
>   - 先找到双向链表的最后这个节点
>   - temp.next=newHeroNode
>   - newHeroNode.pre=temp;
> - 修改 思路和 原来的单向链表一样.
> - 删除
>   - 因为是双向链表，因此，我们可以实现自我删除某个节点
>   - 直接找到要删除的这个节点，比如temp
>   - temp.pre.next=temp.next
>   - temp.next.pre=temp.pre

#### 代码实现

```java
package 数据结构;

public class _6_双向链表代码实现 {
    public static void main(String[] args) {
        System.out.println("双向链表的测试");
        // 先创建节点
        HeroNode2 hero1 = new HeroNode2(1, "宋江", "及时雨");
        HeroNode2 hero2 = new HeroNode2(2, "卢俊义", "玉麒麟");
        HeroNode2 hero3 = new HeroNode2(3, "吴用", "智多星");
        HeroNode2 hero4 = new HeroNode2(4, "林冲", "豹子头");
        // 创建一个双向链表
        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();
        doubleLinkedList.add(hero1);
        doubleLinkedList.add(hero2);
        doubleLinkedList.add(hero3);
        doubleLinkedList.add(hero4);

        doubleLinkedList.list();
        // 修改
        HeroNode2 newHeroNode = new HeroNode2(4, "公孙胜", "入云龙");
        doubleLinkedList.update(newHeroNode);
        System.out.println("修改后的链表情况");
        doubleLinkedList.list();

        // 删除
        doubleLinkedList.del(3);
        System.out.println("删除后的链表情况~~");
        doubleLinkedList.list();
    }
}

// 创建一个双向链表的类
class DoubleLinkedList {
// 先初始化一个头节点, 头节点不要动, 不存放具体的数据
    private HeroNode2 head = new HeroNode2(0, "", "");
    // 返回头节点
    public HeroNode2 getHead() {
        return head;
    }

    // 遍历双向链表的方法
    // 显示链表[遍历]
    public void list() {
        // 判断链表是否为空
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }

        // 因为头节点，不能动，因此我们需要一个辅助变量来遍历
        HeroNode2 temp = head.next;
        while (true) {
            // 判断是否到链表最后
            if (temp == null) {
                break;
            }
            // 输出节点的信息
            System.out.println(temp);
            // 将temp后移， 一定小心
            temp = temp.next;
        }
    }

    // 添加一个节点到双向链表的最后.
    public void add(HeroNode2 heroNode) {
        // 因为head节点不能动，因此我们需要一个辅助遍历 temp
        HeroNode2 temp = head;
        // 遍历链表，找到最后
        while (true) {
            // 找到链表的最后
            if (temp.next == null) {//
                break;
            }
            // 如果没有找到最后, 将将temp后移
            temp = temp.next;
        }
        // 当退出while循环时，temp就指向了链表的最后
        // 形成一个双向链表
        temp.next = heroNode;
        heroNode.pre = temp;
    }

    // 修改一个节点的内容, 可以看到双向链表的节点内容修改和单向链表一样
    // 只是 节点类型改成 HeroNode2
    public void update(HeroNode2 newHeroNode) {
        // 判断是否空
        if (head.next == null) {
            System.out.println("链表为空~");
            return;
        }
        // 找到需要修改的节点, 根据no编号
        // 定义一个辅助变量
        HeroNode2 temp = head.next;
        boolean flag = false;// 表示是否找到该节点
        while (true) {
            if (temp == null) {
                break;// 已经遍历完链表
            }
            if (temp.no == newHeroNode.no) {
                // 找到
                flag = true;
                break;
            }
            temp = temp.next;
        }
        // 根据flag 判断是否找到要修改的节点
        if (flag) {
            temp.name = newHeroNode.name;
            temp.nickname = newHeroNode.nickname;
        } else {// 没有找到
            System.out.printf("没有找到 编号 %d 的节点，不能修改\n", newHeroNode.no);
        }
    }

    // 从双向链表中删除一个节点,
    // 说明
    // 1 对于双向链表，我们可以直接找到要删除的这个节点
    // 2 找到后，自我删除即可
    public void del(int no) {
        //判断当前链表是否为空
        if (head.next == null) {// 空链表
            System.out.println("链表为空，无法删除");
            return;
        }

        HeroNode2 temp = head.next;// 辅助变量(指针)
        boolean flag = false;// 标志是否找到待删除节点的
        while (true) {
            if (temp == null) {// 已经到链表的最后
                break;
            }
            if (temp.no == no) {
                // 找到的待删除节点的前一个节点temp
                flag = true;
                break;
            }
            temp = temp.next;//temp后移，遍历
        }
        // 判断flag
        if (flag) {// 找到
            // 可以删除
            //temp.next=temp.next.next;[单向链表]
            temp.pre.next = temp.next;
            // 这里我们的代码有问题?
            // 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针
            if (temp.next != null) {
                temp.next.pre = temp.pre;
            }
        } else {
            System.out.printf("要删除的 %d 节点不存在\n", no);
        }
    }
}

// 定义HeroNode2  ， 每个HeroNode 对象就是一个节点
class HeroNode2 {
    public int no;
    public String name;
    public String nickname;
    public HeroNode2 next;// 指向下一个节点, 默认为null
    public HeroNode2 pre;// 指向前一个节点, 默认为null
    // 构造器
    public HeroNode2(int no, String name, String nickname) {
        this.no = no;
        this.name = name;
        this.nickname = nickname;
    }

    // 为了显示方法，我们重新toString 
    @Override
    public String toString() {
        return "HeroNode[no=" + no + ",name=" + name + ",nickname=" + nickname + "]";
    }
}
```

#### 课堂作业和思路提示.

> 双向链表的第二种添加方式,按照编号顺序 [示意图]按照单链表的顺序添加，稍作修改即可.

### 单向环形链表

#### 约瑟夫问题

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220717222039069.png" alt="image-20220717222039069" style="zoom:70%;" />

> - 约瑟夫问题(约瑟夫环、Josephu问题)
> - 提示：用一个不带头节点的循环链表来处理Josephu 问题：先构成一个有n个节点的单循环链表，然后由k结
>   点起从 1 开始计数，计到m时，对应节点从链表中删除，然后再从被删除节点的下一个节点又从 1 开始计数，直
>   到最后一个节点从链表中删除算法结束。

> 约瑟夫问题-创建环形链表的思路图解

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220717222355617.png" alt="image-20220717222355617" style="zoom:80%;" />

> 约瑟夫问题-小孩出圈的思路分析图

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220717222434283.png" alt="image-20220717222434283" style="zoom:70%;" />

#### 代码实现

```java
package 数据结构;

public class _7_约瑟夫问题 {
    public static void main(String[] args) {
        // 测试一把看看构建环形链表，和遍历是否ok
        CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();
        circleSingleLinkedList.addBoy(5);// 加入 5 个小孩节点
        circleSingleLinkedList.showBoy();

        //测试一把小孩出圈是否正确
        circleSingleLinkedList.countBoy(1, 2, 5);// 2 - > 4 - > 1 - > 5 - > 3
    }
}

/**
 * 一个环形的单向链表
 */
class CircleSingleLinkedList {
    // 创建一个first节点,当前没有编号
    private Boy first = null;

    /**
     * 添加小孩节点，构建成一个环形的链表
      */
    public void addBoy(int nums) {
        //nums 做一个数据校验
        if (nums < 1) {
            System.out.println("nums的值不正确");
            return;
        }
        Boy curBoy = null;// 辅助指针，帮助构建环形链表
        // 使用for来创建我们的环形链表
        for (int i = 1; i <= nums; i++) {
            // 根据编号，创建小孩节点
            Boy boy = new Boy(i);
            // 如果是第一个小孩
            if (i == 1) {
                first = boy;
                first.setNext(first);// 构成环
                curBoy = first;// 让curBoy 指向第一个小孩
            } else {
                curBoy.setNext(boy);//
                boy.setNext(first);//
                curBoy = boy;
            }
        }
    }

    /**
     * 遍历当前的环形链表
     */
    public void showBoy() {
        // 判断链表是否为空
        if (first == null) {
            System.out.println("没有任何小孩~~");
            return;
        }
        // 因为first不能动，因此我们仍然使用一个辅助指针完成遍历
        Boy curBoy = first;
        while (true) {
            System.out.printf("小孩的编号 %d\n", curBoy.getNo());
            if (curBoy.getNext() == first) {// 说明已经遍历完毕
                break;
            }
            curBoy = curBoy.getNext();//curBoy 后移
        }
    }

    /**
     * 根据用户的输入，计算出小孩出圈的顺序
     * @param startNo 表示从第几个小孩开始数数
     * @param countNum 表示数几下
     * @param nums 表示最初有多少小孩在圈中
     */
    public void countBoy(int startNo, int countNum, int nums) {
        // 先对数据进行校验
        if (first == null || startNo < 1 || startNo > nums) {
            System.out.println("参数输入有误， 请重新输入");
            return;
        }

        // 创建要给辅助指针,帮助完成小孩出圈
        Boy helper = first;
        // 需求创建一个辅助指针(变量)helper, 事先应该指向环形链表的最后这个节点
        while (true) {
            if (helper.getNext() == first) {// 说明helper指向最后小孩节点
                break;
            }
            helper = helper.getNext();
        }
        //小孩报数前，先让 first 和 helper 移动 startNo - 1 次
        for (int j = 0; j < startNo - 1; j++) {
            first = first.getNext();
            helper = helper.getNext();
        }
        //当小孩报数时，让first 和 helper 指针同时 的移动 countNum - 1 次, 然后出圈
        //这里是一个循环操作，知道圈中只有一个节点
        while (true) {
            if (helper == first) {//说明圈中只有一个节点
                break;
            }
            //让 first 和 helper 指针同时 的移动 countNum - 1
            for (int j = 0; j < countNum - 1; j++) {
                first = first.getNext();
                helper = helper.getNext();
            }
            //这时first指向的节点，就是要出圈的小孩节点
            System.out.printf("小孩%d出圈\n", first.getNo());
            //这时将first指向的小孩节点出圈
            first = first.getNext();
            helper.setNext(first);//
        }
        System.out.printf("最后留在圈中的小孩编号%d\n", first.getNo());
    }
}

// 创建一个Boy 类，表示一个节点
class Boy {
    private int no;// 编号
    private Boy next;// 指向下一个节点,默认null

    public Boy(int no) {
        this.no = no;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public Boy getNext() {
        return next;
    }

    public void setNext(Boy next) {
        this.next = next;
    }
}
```
## 栈(Stack)

### 栈的介绍

> - 栈的英文为 **(stack)**
> - **栈是一个先入后出 **(FILO-FirstInLastOut)的有序列表。
> - 栈 **(stack)** 是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的
>   一端，为变化的一端，称为栈顶 **(Top)** ，另一端为固定的一端，称为栈底 **(Bottom)** 。
> - 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元
>   素最先删除，最先放入的元素最后删除
> - 图解方式说明出栈 **(pop)** 和入栈 **(push)** 的概念![image-20220718111944609](https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220718111944609.png)


### 栈的应用场景

> - 子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。
> - 处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。
> - 表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。
> - 二叉树的遍历。
> - 图形的深度优先(depth一first)搜索法。

### 栈的快速入门

> - 用数组模拟栈的使用，由于栈是一种有序列表，当然可以使用数组的结构来储存栈的数据内容，下面我们就用数组模拟栈的出栈，入栈等操作。
>
> - 实现思路分析,并画出示意图
>
>   <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220718113331488.png" alt="image-20220718113331488" style="zoom:80%;" />

#### 代码实现

```java
package 数据结构;

import java.util.Scanner;

public class _8_栈的代码实现 {
    public static void main(String[] args) {
        // 测试一把看看构建
        //测试一下ArrayStack  是否正确
        //先创建一个ArrayStack 对象->表示栈
        ArrayStack stack = new ArrayStack(4);
        String key = "";
        boolean loop = true;//控制是否退出菜单
        Scanner scanner = new Scanner(System.in);

        while (loop) {
            System.out.println("show: 表示显示栈");
            System.out.println("exit: 退出程序");
            System.out.println("push: 表示添加数据到栈(入栈)");
            System.out.println("pop: 表示从栈取出数据(出栈)");
            System.out.println("请输入你的选择");
            key = scanner.next();
            switch (key) {
                case "show":
                    stack.list();
                    break;
                case "push":
                    System.out.println("请输入一个数");
                    int value = scanner.nextInt();
                    stack.push(value);
                    break;
                case "pop":
                    try {
                        int res = stack.pop();
                        System.out.printf("出栈的数据是 %d\n", res);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case "exit":
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出~~~");
    }
}

//定义一个ArrayStack  表示栈
class ArrayStack {
    private int maxSize;// 栈的大小
    private int[] stack;// 数组，数组模拟栈，数据就放在该数组
    private int top = -1;//top表示栈顶，初始化为- 1

    //构造器
    public ArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[this.maxSize];
    }

    //栈满
    public boolean isFull() {
        return top == maxSize - 1;
    }

    //栈空
    public boolean isEmpty() {
        return top == -1;
    }

    //入栈-push
    public void push(int value) {
        //先判断栈是否满
        if (isFull()) {
            System.out.println("栈满");
            return;
        }
        top++;
        stack[top] = value;
    }

    //出栈-pop, 将栈顶的数据返回
    public int pop() {
        //先判断栈是否空
        if (isEmpty()) {
            //抛出异常
            throw new RuntimeException("栈空，没有数据~");
        }
        int value = stack[top];
        top--;
        return value;
    }
    
    //显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据
    public void list() {
        if (isEmpty()) {
            System.out.println("栈空，没有数据~~");
            return;
        }
        //需要从栈顶开始显示数据
        for (int i = top; i >= 0; i--) {
            System.out.printf("stack[%d]=%d\n", i, stack[i]);
        }
    }
}
```

#### 课堂练习

> 将老师写的程序改成使用链表来模拟栈

### 栈实现综合计算器(中缀表达式)

#### 思路分析(图解)

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220718132335881.png" alt="image-20220718132335881" style="zoom:80%;" />

#### 代码实现

> [ 1. 先实现一位数的运算， 2. 扩展到多位数的运算]
```java
package 数据结构;

public class _9_栈实现综合计算器 {
    public static void main(String[] args) {
        String expression = " 7 * 2 * 2 - 5 + 1 - 5 + 3 - 4 ";// 15 //如何处理多位数的问题？
        //创建两个栈，数栈，一个符号栈
        ArrayStack2 numStack = new ArrayStack2(10);
        ArrayStack2 operStack = new ArrayStack2(10);
        //定义需要的相关变量
        int index = 0;//用于扫描
        int num1 = 0;
        int num2 = 0;
        int oper = 0;
        int res = 0;
        char ch;//将每次扫描得到char 保存到ch
        String keepNum = "";//用于拼接 多位数
        //开始while循环的扫描expression
        while (true) {
            //依次得到expression 的每一个字符
            ch = expression.substring(index, index + 1).charAt(0);
            //判断ch是什么，然后做相应的处理
            if (operStack.isOper(ch)) {//如果是运算符
                //判断当前的符号栈是否为空
                if (!operStack.isEmpty()) {
                    //如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符,就需要从数栈中pop出两个数,
                    //在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈
                    if (operStack.priority(ch) <= operStack.priority(operStack.peek())) {
                        num1 = numStack.pop();
                        num2 = numStack.pop();
                        oper = operStack.pop();
                        res = numStack.cal(num1, num2, oper);
                        //把运算的结果如数栈
                        numStack.push(res);
                        //然后将当前的操作符入符号栈
                        operStack.push(ch);
                    } else {
                        //如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈.
                        operStack.push(ch);
                    }
                } else {
                    //如果为空直接入符号栈..
                    operStack.push(ch);// 1 + 3
                }
            } else {//如果是数，则直接入数栈
                //numStack.push(ch- 48 );//?" 1 + 3 "' 1 '=> 1
                //分析思路
                // 1. 当处理多位数时，不能发现是一个数就立即入栈，因为他可能是多位数
                // 2. 在处理数，需要向expression的表达式的index 后再看一位,如果是数就进行扫描，如果是符号才入栈
                // 3. 因此我们需要定义一个变量 字符串，用于拼接处理多位数
                keepNum += ch;

                //如果ch已经是expression的最后一位，就直接入栈
                if (index == expression.length() - 1) {
                    numStack.push(Integer.parseInt(keepNum));
                } else {
                    //判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈
                    //注意是看后一位，不是index++
                    if (operStack.isOper(expression.substring(index + 1, index + 2).charAt(0))) {
                        //如果后一位是运算符，则入栈 keepNum=" 1 " 或者 " 123 "
                        numStack.push(Integer.parseInt(keepNum));
                        //重要的!!!!!!,keepNum清空
                        keepNum = "";
                    }
                }
            }
            //让index+ 1 , 并判断是否扫描到expression最后.
            index++;
            if (index >= expression.length()) {
                break;
            }
        }
        //当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行.
        while (true) {
            //如果符号栈为空，则计算到最后的结果, 数栈中只有一个数字【结果】
            if (operStack.isEmpty()) {
                break;
            }
            num1 = numStack.pop();
            num2 = numStack.pop();
            oper = operStack.pop();
            res = numStack.cal(num1, num2, oper);
            numStack.push(res);//入栈
        }
        //将数栈的最后数，pop出，就是结果
        int res2 = numStack.pop();
        System.out.printf("表达式 %s=%d", expression, res2);
    }
}

//先创建一个栈,直接使用前面创建好
//定义一个ArrayStack2 表示栈, 需要扩展功能
class ArrayStack2 {
    private int maxSize;// 栈的大小
    private int[] stack;// 数组，数组模拟栈，数据就放在该数组
    private int top = -1;//top表示栈顶，初始化为- 1

    //构造器
    public ArrayStack2(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[this.maxSize];
    }

    //增加一个方法，可以返回当前栈顶的值, 但是不是真正的pop
    public int peek() {
        return stack[top];
    }

    //栈满
    public boolean isFull() {
        return top == maxSize - 1;
    }

    //栈空
    public boolean isEmpty() {
        return top == -1;
    }

    //入栈-push
    public void push(int value) {
        //先判断栈是否满
        if (isFull()) {
            System.out.println("栈满");
            return;
        }
        top++;
        stack[top] = value;
    }

    //出栈-pop, 将栈顶的数据返回
    public int pop() {
        //先判断栈是否空
        if (isEmpty()) {
            //抛出异常
            throw new RuntimeException("栈空，没有数据~");
        }

        int value = stack[top];
        top--;
        return value;
    }

    //显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据
    public void list() {
        if (isEmpty()) {
            System.out.println("栈空，没有数据~~");
            return;
        }
        //需要从栈顶开始显示数据
        for (int i = top; i >= 0; i--) {
            System.out.printf("stack[%d]=%d\n", i, stack[i]);
        }
    }

    //返回运算符的优先级，优先级是程序员来确定, 优先级使用数字表示
    //数字越大，则优先级就越高.
    public int priority(int oper) {
        if (oper == '*' || oper == '/') {
            return 1;
        } else if (oper == '+' || oper == '-') {
            return 0;
        } else {
            return -1;// 假定目前的表达式只有 +,-,*,/
        }
    }

    //判断是不是一个运算符
    public boolean isOper(char val) {
        return val == '+' || val == '-' || val == '*' || val == '/';
    }

    //计算方法
    public int cal(int num1, int num2, int oper) {
        int res = 0;//res 用于存放计算的结果
        switch (oper) {
            case '+':
                res = num2 + num1;
                break;
            case '-':
                res = num2 - num1;// 注意顺序
                break;
            case '*':
                res = num2 * num1;
                break;
            case '/':
                res = num2 / num1;
                break;
            default:
                break;
        }
        return res;
    }
}
```
#### 课后的练习

> 给表达式加入小括号

### 逆波兰计算器

> - 输入一个逆波兰表达式(后缀表达式)，使用栈(Stack), 计算其结果
> - 支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算。
> - 思路分析：( 3 + 4 )× 5 - 6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下:
>   - 从左至右扫描，将 3 和 4 压入堆栈；
>   - 遇到+运算符，因此弹出 4 和 3 （ 4 为栈顶元素， 3 为次顶元素），计算出 3 + 4 的值，得 7 ，再将 7 入栈
>   - 将 5 入栈；
>   - 接下来是×运算符，因此弹出 5 和 7 ，计算出 7 × 5 = 35 ，将 35 入栈；
>   - 将 6 入栈；
>   - 最后是-运算符，计算出 35 - 6 的值，即 29 ，由此得出最终结果

#### 代码实现
```java
package 数据结构;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class _10_逆波兰计算器 {
    public static void main(String[] args) {
        //( 30 + 4 )× 5 - 6 => 30 4 + 5 × 6 - => 164
//        String suffixExpression="30 4 + 5 * 6 -";//164

        // 4 * 5 - 8 + 60 + 8 / 2 => 4 5 * 8 - 60 + 8 2 / +   => 76
        String suffixExpression = "4 5 * 8 - 60 + 8 2 / +";// 76

        // (3 + 4) * 5 - 6 => 3 4 + 5 * 6 -   => 29
//        String suffixExpression = "3 4 + 5 * 6 -";// 29

        List<String> list = new ArrayList<>(Arrays.asList(suffixExpression.split(" ")));
        System.out.println("rpnList=" + list);
        int res = calculate(list);
        System.out.println("计算的结果是=" + res);
    }

    /**
     * 完成对逆波兰表达式的运算: 3 4 + 5 * 6 -
     * 1 )从左至右扫描，将 3 和 4 压入堆栈；
     * 2 )遇到+运算符，因此弹出 4 和 3 （ 4 为栈顶元素， 3 为次顶元素），计算出 3 + 4 的值，得 7 ，再将 7 入栈；
     * 3 )将 5 入栈；
     * 4 )接下来是×运算符，因此弹出 5 和 7 ，计算出 7 × 5 = 35 ，将 35 入栈；
     * 5 )将 6 入栈；
     * 6 )最后是-运算符，计算出 35 - 6 的值，即 29 ，由此得出最终结果
     */
    public static int calculate(List<String> ls) {
        // 创建给栈, 只需要一个栈即可
        Stack<String> stack = new Stack<String>();
        // 遍历 ls
        for (String item : ls) {
            // 这里使用正则表达式来取出数
            if (item.matches("\\d+")) {// 匹配的是多位数
                // 入栈
                stack.push(item);
            } else {
                //pop出两个数，并运算， 再入栈
                int num2 = Integer.parseInt(stack.pop());
                int num1 = Integer.parseInt(stack.pop());
                int res = 0;
                if (item.equals("+")) {
                    res = num1 + num2;
                } else if (item.equals("-")) {
                    res = num1 - num2;
                } else if (item.equals("*")) {
                    res = num1 * num2;
                } else if (item.equals("/")) {
                    res = num1 / num2;
                } else {
                    throw new RuntimeException("运算符有误");
                }
                //把res 入栈
                stack.push("" + res);
            }
        }
        //最后留在stack中的数据是运算结果
        return Integer.parseInt(stack.pop());
    }
}
```
### 中缀表达式转换为后缀表达式

> 大家看到，后缀表达式适合计算式进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此在开发中，我们需要将 中缀表达式转成后缀表达式。
>

#### 举例说明

> 将中缀表达式“ 1 +(( 2 + 3 )× 4 )- 5 ”转换为后缀表达式的过程如下，因此结果为 :" 1 2 3 + 4 × + 5 – "

#### 思路分析

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220718151540426.png" alt="image-20220718151540426" style="zoom:80%;" />

#### 代码实现

```java
package 数据结构;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class _11_中缀表达式转换为后缀表达式 {
    public static void main(String[] args) {
        //完成将一个中缀表达式转成后缀表达式的功能：1+((2+3)*4)-5 => 转成 1 2 3 + 4 × + 5 –
        // 2. 因为直接对str 进行操作不方便，因此 先将 "1+((2+3)*4)-5"=》 中缀的表达式对应的List
        // 即 "1+((2+3)*4)-5"=>ArrayList[ 1 ,+,(,(, 2 ,+, 3 ,),*, 4 ,),-, 5 ]
        // 3. 将得到的中缀表达式对应的List=> 后缀表达式对应的List
        // 即ArrayList[ 1 ,+,(,(, 2 ,+, 3 ,),*, 4 ,),-, 5 ] =》ArrayList[ 1 , 2 , 3 ,+, 4 ,*,+, 5 ,–]
        String expression = "1+((2+3)*4)-5";
        List<String> infixExpressionList = toInfixExpressionList(expression);
        System.out.println("中缀表达式对应的List=" + infixExpressionList);//ArrayList[ 1 ,+,(,(, 2 ,+, 3 ,),*, 4 ,),-, 5 ]
        List<String> suffixExpreesionList = parseSuffixExpreesionList(infixExpressionList);
        System.out.println("后缀表达式对应的List" + suffixExpreesionList);//ArrayList[ 1 , 2 , 3 ,+, 4 ,*,+, 5 ,–]

        System.out.printf("expression=%d", _10_逆波兰计算器.calculate(suffixExpreesionList));
        System.out.println();
    }

    /**
     * 中缀表达式List => 后缀表达式List
     */
    public static List<String> parseSuffixExpreesionList(List<String> ls) {
        //定义两个栈
        Stack<String> s1 = new Stack<String>();// 符号栈
        //说明：因为s2这个栈，在整个转换过程中，没有pop操作，而且后面我们还需要逆序输出
        //因此比较麻烦，这里我们就不用 Stack<String > 直接使用 List<String >s2
        //Stack<String >s2= new Stack<String >();// 储存中间结果的栈s2
        List<String> s2 = new ArrayList<String>();// 储存中间结果的Lists2

        //遍历ls
        for (String item : ls) {
            //如果是一个数，加入s2
            if (item.matches("\\d+")) {
                s2.add(item);
            } else if (item.equals("(")) {
                s1.push(item);
            } else if (item.equals(")")) {
                //如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃
                while (!s1.peek().equals("(")) {
                    s2.add(s1.pop());
                }
                s1.pop();//!!! 将 (弹出 s1栈， 消除小括号
            } else {
                //当item的优先级小于等于s1栈顶运算符, 将s1栈顶的运算符弹出并加入到s2中，再次转到( 4. 1 )与s1中新的栈顶运算符相比较
                //问题：我们缺少一个比较优先级高低的方法
                while (s1.size() != 0 && Operation.getValue(s1.peek()) >= Operation.getValue(item)) {
                    s2.add(s1.pop());
                }
                //还需要将item压入栈
                s1.push(item);
            }
        }

        //将s1中剩余的运算符依次弹出并加入s2
        while (s1.size() != 0) {
            s2.add(s1.pop());
        }
        return s2;//注意因为是存放到List, 因此按顺序输出就是对应的后缀表达式对应的List
    }

    /**
     * 中缀表达式 => 对应的List
     */
    public static List<String> toInfixExpressionList(String s) {
        //定义一个List,存放中缀表达式 对应的内容
        List<String> ls = new ArrayList<String>();
        int i = 0;//这时是一个指针，用于遍历 中缀表达式字符串
        String str;// 对多位数的拼接
        char c;// 每遍历到一个字符，就放入到c
        do {
            //如果c是一个非数字，我需要加入到ls
            if ((c = s.charAt(i)) < 48 || (c = s.charAt(i)) > 57) {
                ls.add("" + c);
                i++;//i需要后移
            } else {//如果是一个数，需要考虑多位数
                str = "";//先将str 置成""' 0 '[ 48 ]->' 9 '[ 57 ]
                while (i < s.length() && (c = s.charAt(i)) >= 48 && (c = s.charAt(i)) <= 57) {
                    str += c;//拼接
                    i++;
                }
                ls.add(str);
            }
        } while (i < s.length());
        return ls;//返回
    }
}

//编写一个类 Operation 可以返回一个运算符 对应的优先级
class Operation {
    private static int ADD = 1;
    private static int SUB = 1;
    private static int MUL = 2;
    private static int DIV = 2;

    //写一个方法，返回对应的优先级数字
    public static int getValue(String operation) {
        int result = 0;
        switch (operation) {
            case "+":
                result = ADD;
                break;
            case "-":
                result = SUB;
                break;
            case "*":
                result = MUL;
                break;
            case "/":
                result = DIV;
                break;
            case "(":
                break;
            case ")":
                break;
            default:
                System.out.println("不存在该运算符");
                break;
        }
        return result;
    }
}
```

### 逆波兰计算器完整版

> 完整版的逆波兰计算器，功能包括
>
> - 支持 +-*/()
> - 多位数，支持小数,
>
> - 兼容处理, 过滤任何空白字符，包括空格、制表符、换页符
>
> 说明：逆波兰计算器完整版考虑的因素较多，下面给出完整版代码供同学们学习，其基本思路和前面一样，也是使用到：中缀表达式转后缀表达式。

#### 代码实现：

```java
package 数据结构;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Stack;
import java.util.regex.Pattern;

public class _12_逆波兰计算器完整版 {
    public static void main(String[] args) {
        String math ="9 +( 3 - 1 )* 3 + 10 / 2 ";
//        String math = "12.8+(2-3.55)*4+10/5.0";
        try {
            doCalc(doMatch(math));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 匹配 + - * /() 运算符
     */
    static final String SYMBOL = "\\+|-|\\*|/|\\(|\\)";
    static final String LEFT = "(";
    static final String RIGHT = ")";
    static final String ADD = "+";
    static final String MINUS = "-";
    static final String TIMES = "*";
    static final String DIVISION = "/";

    /**
     * 加減
     */
    static final int LEVEL_01 = 1;

    /**
     * 乘除
     */
    static final int LEVEL_02 = 2;

    /**
     * 括号
     */

    static final int LEVEL_HIGH = Integer.MAX_VALUE;

    static Stack<String> stack = new Stack<>();
    static List<String> data = Collections.synchronizedList(new ArrayList<String>());

    /**
     * 去除所有空白符
     *
     * @return
     * @params
     */
    public static String replaceAllBlank(String s) {
        //  \\s+ 匹配任何空白字符，包括空格、制表符、换页符等等, 等价于[\f\n\r\t\v]
        return s.replaceAll("\\s+", "");
    }

    /**
     * 判断是不是数字 int doublelongfloat
     * @return
     * @params
     */
    public static boolean isNumber(String s) {
        Pattern pattern = Pattern.compile("^[-\\+]?[.\\d]*$");
        return pattern.matcher(s).matches();
    }

    /**
     * 判断是不是运算符
     * @return
     * @params
     */
    public static boolean isSymbol(String s) {
        return s.matches(SYMBOL);
    }

    /**
     * 匹配运算等级
     * @return
     * @params
     */
    public static int calcLevel(String s) {
        if ("+".equals(s) || "-".equals(s)) {
            return LEVEL_01;
        } else if ("*".equals(s) || "/".equals(s)) {
            return LEVEL_02;
        }
        return LEVEL_HIGH;
    }

    /**
     * 匹配
     * @params
     * @throw sException
     */
    public static List<String> doMatch(String s) throws Exception {
        if (s == null || "".equals(s.trim())) throw new RuntimeException("dataisempty");
        if (!isNumber(s.charAt(0) + "")) throw new RuntimeException("datailleagle,startnotwithanumber");
        s = replaceAllBlank(s);
        String each;
        int start = 0;
        for (int i = 0; i < s.length(); i++) {
            if (isSymbol(s.charAt(i) + "")) {
                each = s.charAt(i) + "";
                //栈为空，(操作符，或者 操作符优先级大于栈顶优先级 && 操作符优先级不是()的优先级 及是 )不能直接入栈
                if (stack.isEmpty() || LEFT.equals(each)
                        || ((calcLevel(each) > calcLevel(stack.peek())) && calcLevel(each) < LEVEL_HIGH)) {


                    stack.push(each);
                } else if (!stack.isEmpty() && calcLevel(each) <= calcLevel(stack.peek())) {
                    //栈非空，操作符优先级小于等于栈顶优先级时出栈入列，直到栈为空，或者遇到了(，最后操作符入栈
                    while (!stack.isEmpty() && calcLevel(each) <= calcLevel(stack.peek())) {
                        if (calcLevel(stack.peek()) == LEVEL_HIGH) {
                            break;
                        }
                        data.add(stack.pop());
                    }
                    stack.push(each);
                } else if (RIGHT.equals(each)) {
                    //) 操作符，依次出栈入列直到空栈或者遇到了第一个)操作符，此时)出栈
                    while (!stack.isEmpty() && LEVEL_HIGH >= calcLevel(stack.peek())) {
                        if (LEVEL_HIGH == calcLevel(stack.peek())) {
                            stack.pop();
                            break;
                        }
                        data.add(stack.pop());
                    }
                }
                start = i; //前一个运算符的位置
            } else if (i == s.length() - 1 || isSymbol(s.charAt(i + 1) + "")) {
                each = start == 0 ? s.substring(start, i + 1) : s.substring(start + 1, i + 1);
                if (isNumber(each)) {
                    data.add(each);
                    continue;
                }
                throw new RuntimeException("datanotmatchnumber");
            }
        }
        //如果栈里还有元素，此时元素需要依次出栈入列，可以想象栈里剩下栈顶为/，栈底为+，应该依次出栈入列，可以直接翻转整个stack 添加到队列
        Collections.reverse(stack);
        data.addAll(new ArrayList<>(stack));
        System.out.println(data);
        return data;
    }

    /**
     * 算出结果
     * @return
     * @paramlist
     */
    public static Double doCalc(List<String> list) {
        Double d = 0d;
        if (list == null || list.isEmpty()) {
            return null;
        }
        if (list.size() == 1) {
            System.out.println(list);
            d = Double.valueOf(list.get(0));
            return d;
        }
        ArrayList<String> list1 = new ArrayList<>();
        for (int i = 0; i < list.size(); i++) {
            list1.add(list.get(i));
            if (isSymbol(list.get(i))) {
                Double d1 = doTheMath(list.get(i - 2), list.get(i - 1), list.get(i));
                list1.remove(i);
                list1.remove(i - 1);
                list1.set(i - 2, d1 + "");
                list1.addAll(list.subList(i + 1, list.size()));
                break;
            }
        }
        doCalc(list1);
        return d;
    }

    /**
     * 运算
     * @return
     * @params 1
     * @params 2
     * @paramsymbol
     */
    public static Double doTheMath(String s1, String s2, String symbol) {
        Double result;
        switch (symbol) {
            case ADD:
                result = Double.valueOf(s1) + Double.valueOf(s2);
                break;
            case MINUS:
                result = Double.valueOf(s1) - Double.valueOf(s2);
                break;
            case TIMES:
                result = Double.valueOf(s1) * Double.valueOf(s2);
                break;
            case DIVISION:
                result = Double.valueOf(s1) / Double.valueOf(s2);
                break;
            default:
                result = null;
        }
        return result;
    }
}
```


## 递归

### 概念

> 递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂的问题,同时可以让代码变得简洁。

### 递归调用机制

> - 打印问题
>
> - 阶乘问题
>
> - 使用图解方式说明了递归的调用机制
>
>   <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220718163207305.png" alt="image-20220718163207305" style="zoom:50%;" />

#### 代码演示
```java
package 数据结构;

public class _13_递归调用机制 {
    public static void main(String[] args) {
        //通过打印问题，回顾递归调用机制
        test( 4 );
        int res = factorial(3);
        System.out.println("res=" + res);
    }

    //打印问题.
    public static void test(int n) {
        if (n > 2) {
            test(n - 1);
        }
        System.out.println("n=" + n);
    }

    //阶乘问题
    public static int factorial(int n) {
        if (n == 1) {
            return 1;
        } else {
            return factorial(n - 1) * n;// 1 * 2 * 3
        }
    }
}
```
### 递归能解决什么样的问题

> - 各种数学问题如: 8 皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题, 球和篮子的问题(google编程大赛)
> - 各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等.
> - 将用栈解决的问题-->第归代码比较简洁

### 递归遵守规则

> - 执行一个方法时，就创建一个新的受保护的独立空间(栈空间) 
> - 方法的局部变量是独立的，不会相互影响, 比如n变量
> - 如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.
> - 递归**必须向退出递归的条件**逼近，否则就是无限递归,出现StackOverflowError，死龟了:)
> - 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或
>   者返回时，该方法也就执行完毕

### 递归-迷宫问题

> 存在一个8*7的空间，红色为墙面，不可通行，给定小球起始位置，出口位置为[6，5]，求找到出口的最短路径

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220718163937728.png" alt="image-20220718163937728" style="zoom:50%;" />

#### 代码实现
```java
package 数据结构;

public class _14_递归_迷宫问题 {
    static int len = 0;
    public static void main(String[] args) {
        // 建造地图并输出
        int[][] map = getMap();

        //使用递归回溯给小球找路
        setWay(map, 1, 1);
//        setWay2(map, 1, 1);

        //输出新的地图, 小球走过，并标识过的递归
        System.out.println("小球走过总长度：" + (len - 1));
        System.out.println("小球走过，并标识过的 地图的情况");
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 7; j++) {
                System.out.print(map[i][j] + " ");
            }
            System.out.println();
        }
    }

    private static int[][] getMap() {
        // 先创建一个二维数组，模拟迷宫地图
        int[][] map = new int[8][7];
        // 使用 1 表示墙
        // 上下全部置为 1
        for (int i = 0; i < 7; i++) {
            map[0][i] = 1;
            map[7][i] = 1;
        }
        // 左右全部置为 1
        for (int i = 0; i < 8; i++) {
            map[i][0] = 1;
            map[i][6] = 1;
        }
        //设置挡板, 1 表示
        map[3][1] = 1;
        map[3][2] = 1;
//        map[3][3] = 1;
//        map[3][4] = 1;
//        map[3][5] = 1;
        // 输出地图
        System.out.println("地图的情况");
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 7; j++) {
                System.out.print(map[i][j] + " ");
            }
            System.out.println();
        }
        return map;
    }

    //使用递归回溯来给小球找路
    // 1. map 表示地图
    // 2. i,j 表示从地图的哪个位置开始出发 ( 1 , 1 )
    // 3. 如果小球能到 map[ 6 ][ 5 ] 位置，则说明通路找到.
    // 4. 约定： 当map[i][j] 为 0 表示该点没有走过 当为 1 表示墙 ； 2 表示通路可以走 ； 3 表示该点已经走过，但是走不通
    // 5. 在走迷宫时，需要确定一个策 略(方法) 下->右->上->左 , 如果该点走不通，再回溯
    /**
     * @return 如果找到通路，就返回true, 否则返回false
     * @param map 表示地图
     * @param i 从哪个位置开始找
     * @param j
     */
    public static boolean setWay(int[][] map, int i, int j) {
        if (map[6][5] == 2) {// 通路已经找到ok
            return true;
        } else {
            if (map[i][j] == 0) {//如果当前这个点还没有走过
                //按照策略 下->右->上->左 走
                map[i][j] = 2;// 假定该点是可以走通.
                len ++;
                if (setWay(map, i + 1, j)) {//向下走
                    return true;
                } else if (setWay(map, i, j + 1)) {//向右走
                    return true;
                } else if (setWay(map, i - 1, j)) {//向上
                    return true;
                } else if (setWay(map, i, j - 1)) {// 向左走
                    return true;
                } else {
                    //说明该点是走不通，是死路
                    map[i][j] = 3;
                    return false;
                }
            } else {// 如果map[i][j]!= 0 , 可能是 1 ， 2 ， 3
                return false;
            }
        }
    }

    //修改找路的策略，改成 上->右->下->左
    public static boolean setWay2(int[][] map, int i, int j) {
        if (map[6][5] == 2) {// 通路已经找到ok
            return true;
        } else {
            if (map[i][j] == 0) {//如果当前这个点还没有走过
                //按照策略 上->右->下->左
                map[i][j] = 2;// 假定该点是可以走通.
                if (setWay2(map, i - 1, j)) {//向上走
                    return true;
                } else if (setWay2(map, i, j + 1)) {//向右走
                    return true;
                } else if (setWay2(map, i + 1, j)) {//向下
                    return true;
                } else if (setWay2(map, i, j - 1)) {// 向左走
                    return true;
                } else {
                    //说明该点是走不通，是死路
                    map[i][j] = 3;
                    return false;
                }
            } else {// 如果map[i][j]!= 0 , 可能是 1 ， 2 ， 3
                return false;
            }
        }
    }
}
```

#### 对迷宫问题的讨论

> - 小球得到的路径，和程序员设置的找路策略有关即：找路的上下左右的顺序相关
> - 再得到小球路径时，可以先使用(下右上左)，再改成(上右下左)，看看路径是不是有变化
> - 测试回溯现象

### 递归-八皇后问题(回溯算法)

#### 八皇后问题介绍

> 八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848 年提出：在 8 × 8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法 ( 92 ) 。

#### 思路分析

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220718173338829.png" alt="image-20220718173338829" style="zoom:80%;" />

> 说明：
>
> - 理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题
> - arr[ 8 ]={ 0 , 4 , 7 , 5 , 2 , 6 , 1 , 3 }//对应arr 下标 表示第几行，即第几个皇后，arr[i]=val,val 表示第i+ 1 个皇后，放在第i+ 1
>   行的第val+ 1 列

#### 代码实现

```java
package 数据结构;

import java.util.Arrays;

public class _15_递归_八皇后问题 {
    //定义一个max表示共有多少个皇后
    static int max = 8;
    //定义数组array,保存皇后放置位置的结果,比如 arr={ 0 , 4 , 7 , 5 , 2 , 6 , 1 , 3 }
    static int[] array = new int[max];
    // 解法数
    static int count = 0;
    // 判断的冲突次数
    static int judgeCount = 0;

    public static void main(String[] args) {
        //测试一把， 8皇后是否正确
        check(0);
        System.out.printf("一共有%d解法", count);
        System.out.println();
        System.out.printf("一共判断冲突的次数%d次", judgeCount);// 1. 5 w
        System.out.println();
    }

    //编写一个方法，放置第n个皇后
    //特别注意： check 是 每一次递归时，进入到check中都有 for( int i= 0 ;i<max;i++)，因此会有回溯
    private static void check(int n) {
        if (n == max) { //n= 8 , 其实 8 个皇后就既然放好
            count++;
            System.out.println(Arrays.toString(array));
            return;
        }
        //依次放入皇后，并判断是否冲突
        for (int i = 0; i < max; i++) {
            //先把当前这个皇后 n, 放到该行的第 1 列
            array[n] = i;
            //判断当放置第n个皇后到i列时，是否冲突
            if (judge(n)) {// 不冲突
                //接着放 n + 1 个皇后,即开始递归
                check(n + 1);//
            }
            //如果冲突，就继续执行 array[n]=i; 即将第n个皇后，放置在本行得 后移的一个位置
        }
    }

    /**
     * 查看当我们放置第n个皇后, 就去检测该皇后是否和前面已经摆放的皇后冲突：行、列、斜线
     * @param n 表示第n个皇后
     * @return
     */
    private static boolean judge(int n) {
        judgeCount++;
        for (int i = 0; i < n; i++) {
            // 1.判断是否在同一行, 没有必要，n 每次都在递增
            // 2.array[i]==array[n] 表示判断 第n个皇后是否和前面的n- 1 个皇后在同一列
            // 3.Math.abs(n-i)==Math.abs(array[n]-array[i]) 表示判断第n个皇后是否和第i皇后是否在同一斜线
            //n= 1 放置第 2 列 1 n= 1 array[ 1 ]= 1
            //Math.abs( 1 - 0 )== 1 Math.abs(array[n]-array[i])=Math.abs( 1 - 0 )= 1
            if (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) {
                return false;
            }
        }
        return true;
    }
}
```
## 排序算法

### 介绍

> 排序也称排序算法(SortAlgorithm)，排序是将一组数据，依指定的顺序进行排列的过程。

### 分类

> - 内部排序：指将需要处理的所有数据都加载到内部存储器 ( 内存 ) 中进行排序。
>
> - 外部排序：数据量过大，无法全部加载到内存中，需要借助外部存储 ( 文件等 ) 进行排序。
>
> - 常见的排序算法分类
>
>   ![image-20220718195900933](https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220718195900933.png)

### 算法的时间复杂度

#### 度量一个程序(算法)执行时间

> -  事后统计的方法
>
>    - 这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素, 这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。
>
> - 事前估算的方法
>  - 通过分析某个算法的**时间复杂度**来判断哪个算法更优.

#### 时间频度

> 时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。**一个算法中的语句执行次数称为语句频度或时间频度**。记为T(n)

##### 举例说明-基本案例
> 比如计算 1 - 100 所有数字之和, 我们设计两种算法：

![image-20220718200652707](https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220718200652707.png)

##### 举例说明-忽略常数项

> - 2 n+ 20 和 2 n 随着n 变大，执行曲线无限接近, 20 可以忽略
> - 3 n+ 10 和 3 n 随着n 变大，执行曲线无限接近, 10 可以忽略

##### 举例说明-忽略低次项

> - 2 n^ 2 + 3 n+ 10 和 2 n^ 2 随着n 变大, 执行曲线无限接近, 可以忽略 3 n+ 10
> - n^ 2 + 5 n+ 20 和 n^ 2 随着n 变大,执行曲线无限接近, 可以忽略 5 n+ 20


##### 举例说明-忽略系数

> - 随着n值变大， 5 n^ 2 + 7 n 和 3 n^ 2 + 2 n ，执行曲线重合, 说明 这种情况下, 5 和 3 可以忽略。
> - n^ 3 + 5 n 和 6 n^ 3 + 4 n ，执行曲线分离，说明多少次方是关键

#### 时间复杂度

> - 一般情况下，算法中的基本操作语句的重复执行次数是问题规模 **n** 的某个函数，用T(n)表示，若有某个辅
>   助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n) 的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。
>   记作 **T(n)=** Ｏ **(f(n))** ，称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。
> - T(n) 不同，但时间复杂度可能相同。如：T(n)=n²+ 7 n+ 6 与 T(n)= 3 n²+ 2 n+ 2 它们的T(n)不同，但时间复杂
>   度相同，都为 **O(n** ² **)** 。
> - 计算时间复杂度的方法：
>   - 用常数 1 代替运行时间中的所有加法常数 T(n)=n²+ 7 n+ 6 =>T(n)=n²+ 7 n+ 1
>   - 修改后的运行次数函数中，只保留最高阶项 T(n)=n²+ 7 n+ 1 =>T(n)=n²
>   - 去除最高阶项的系数 T(n)=n² =>T(n)=n² =>O(n²)

#### 常见的时间复杂度

> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220718202107168.png" alt="image-20220718202107168" style="zoom:50%;" />
>
> - 常数阶O( 1 )
> - 对数阶O(log 2 n)
> - 线性阶O(n)
> - 线性对数阶O(nlog 2 n)
> - 平方阶O(n^ 2 )
> - 立方阶O(n^ 3 )
> - k次方阶O(n^k)
> - 指数阶O( 2 ^n)
> - 说明
>   - 常见的算法时间复杂度由小到大依次为：Ο( 1 )＜Ο(log 2 n)＜Ο(n)＜Ο(nlog 2 n)＜Ο(n 2 )＜Ο(n 3 )＜ Ο(nk) ＜
>     Ο( 2 n) ，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低
>   - 从图中可见，我们应该尽可能避免使用指数阶的算法

#### 平均时间复杂度和最坏时间复杂度

> - 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。
>
> - 最坏情况下的时间复杂度称最坏时间复杂度。**一般讨论的时间复杂度均是最坏情况下的时间复杂度**。这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。
>
> - 平均时间复杂度和最坏时间复杂度是否一致，和算法有关(如图:)。

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220718202428360.png" alt="image-20220718202428360" style="zoom:60%;" />

### 算法的空间复杂度

#### 基本介绍

> - 类似于时间复杂度的讨论，一个算法的空间复杂度(SpaceComplexity)定义为该算法所耗费的存储空间，它也是
>   问题规模n的函数。
> - 空间复杂度(SpaceComplexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的
>   临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例
>   如快速排序和归并排序算法 **,** 基数排序就属于这种情况
> - 在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品
>   (redis,memcache)和算法(基数排序)本质就是用空间换时间.

### 冒泡排序(Bubble Sort)

#### 基本介绍

> 冒泡排序（Bubble Sort）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较
> 相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。
>
> 优化：因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志flag判断元素是否进行过交换。从而减少不必要的比较。(这里说的优化，可以在冒泡排序写好后，在进行)
>

#### 演示冒泡过程

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220718203011907.png" alt="image-20220718203011907" style="zoom:50%;" />

> - 一共进行 数组的大小- 1 次 大的循环
>
> - 每一趟排序的次数在逐渐的减少
> - 如果我们发现在某趟排序中，没有发生一次交换， 可以提前结束冒泡排序。这个就是优化

#### 代码实现


```java
package 算法;

import java.util.Arrays;

public class _1_冒泡排序 {
    private static int count = 8;

    public static void main(String[] args) {
        int arr[] = {3, 9, -1, 10, 20};
        //测试一下冒泡排序的速度O(n^2), 给 80000 个数据，测试
//        int[] arr = new int[count];
//        for (int i = 0; i < count; i++) {
//            arr[i] = (int) (Math.random() * count * 100);//生成一个[0, 8000000) 数
//        }
        System.out.println("排序前");
        System.out.println(Arrays.toString(arr));

        //测试冒泡排序
        bubbleSort(arr);
        System.out.println("排序后");
        System.out.println(Arrays.toString(arr));
    }

    public static void bubbleSort(int[] arr) {
        // 冒泡排序 的时间复杂度 O(n^2), 自己写出
        int temp;// 临时变量
        boolean flag = false;// 标识变量，表示是否进行过交换
        for (int i = 0; i < arr.length - 1; i++) {
            for (int j = 0; j < arr.length - 1 - i; j++) {
                // 如果前面的数比后面的数大，则交换
                if (arr[j] > arr[j + 1]) {
                    flag = true;
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
            System.out.println("第" + (i + 1) + "趟排序后的数组");
            System.out.println(Arrays.toString(arr));
            if (!flag) {// 在一趟排序中，一次交换都没有发生过
                break;
            } else {
                flag = false;// 重置flag!!!, 进行下次判断
            }
        }
    }
}
```

### 选择排序(Select Sort)

#### 基本介绍

> 选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。

#### 选择排序思想

> 第一次从arr[ 0 ]~arr[ n-1 ]中选取最小值，与arr[ 0 ]交换，
>
> 第二次从arr[ 1 ]~arr[ n-1 ]中选取最小值，与arr[ 1 ]交换，
>
> 第三次从arr[ 2 ]~arr[ n-1 ]中选取最小值，与arr[ 2 ]交换，
>
> ...，
>
> 第i次从arr[ i-1 ]~arr[ n-1 ]中选取最小值，与arr[i- 1 ]交换，
>
> ...，
>
> 第n- 1 次从arr[ n-2 ]~arr[ n-1 ]中选取最小值，与arr[n- 2 ]交换，
>
> 总共通过 n-1 次，得到一个按排序码从小到大排列的有序序列。

#### 选择排序思路分析

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220719094239775.png" alt="image-20220719094239775" style="zoom:80%;" />

#### 代码实现
```java
package 算法;

public class _2_选择排序 {
    public static void selectSort(int[] arr) {
        int minIndex;// 最小值的位置
        int min;// 最小值
        //选择排序时间复杂度是 O(n^2)
        for (int i = 0; i < arr.length - 1; i++) {
            minIndex = i;
            min = arr[i];
            for (int j = i + 1; j < arr.length; j++) {
                if (min > arr[j]) {// 说明假定的最小值，并不是最小
                    min = arr[j];// 重置min
                    minIndex = j;// 重置minIndex
                }
            }

            // 如果最小位置变了，则交换
            if (minIndex != i) {
                arr[minIndex] = arr[i];
                arr[i] = min;
            }
//            System.out.println("第" + (i + 1) + "轮后~~");
//            System.out.println(Arrays.toString(arr));
        }
    }
}
```

### 插入排序(Insertion Sort)

#### 基本介绍

> 插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。

#### 插入排序思想

> 把 n 个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有 n-1 个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。

#### 插入排序思路分析

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220719101825858.png" alt="image-20220719101825858" style="zoom:50%;" />

#### 代码实现
```java
package 算法;

public class _3_插入排序 {
    public static void insertSort(int[] arr) {
        int insertVal;
        int insertIndex;
        //使用for循环来把代码简化
        for (int i = 1; i < arr.length; i++) {
            //定义待插入的数
            insertVal = arr[i];
            insertIndex = i - 1;// 即arr[ 1 ]的前面这个数的下标
            // 给insertVal 找到插入的位置
            // 1. insertIndex >= 0 保证在给insertVal 找插入位置，不越界
            // 2. insertVal<arr[insertIndex] 待插入的数，还没有找到插入位置
            // 3. 就需要将 arr[insertIndex] 后移
            while (insertIndex >= 0 && insertVal < arr[insertIndex]) {
                arr[insertIndex + 1] = arr[insertIndex];//arr[insertIndex]
                insertIndex--;
            }
            // 当退出while循环时，说明插入的位置找到，为 insertIndex + 1
            //这里我们判断是否需要赋值
            if (insertIndex + 1 != i) {
                arr[insertIndex + 1] = insertVal;
            }
//            System.out.println("第" + i + "轮插入");
//            System.out.println(Arrays.toString(arr));
        }
    }
}
```

### 希尔排序(Shell Sort)

#### 简单插入排序存在的问题

> - 数组 arr={ 2 , 3 , 4 , 5 , 6 , 1 }这时需要插入的数 1 **(** 最小), 这样的过程是：
>   { 2 , 3 , 4 , 5 , 6 , 1 }
>   { 2 , 3 , 4 , 5 , 1 , 6 }
>   { 2 , 3 , 4 , 1, 5 , 6 }
>   { 2 , 3 , 1 , 4 , 5 , 6 }
>   { 2 , 1 , 3 , 4 , 5 , 6 }
>   { 1 , 2 , 3 , 4 , 5 , 6 }
> - 结论 **:** 当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响.

#### 希尔排序介绍

>- 希尔排序是希尔（DonaldShell）于 1959 年提出的一种排序算法。
>- 希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个**更高效**的版本，也称为**缩小增量排序**

#### 基本思想

> 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止

#### 示意图

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220719111604496.png" alt="image-20220719111604496" style="zoom:50%;" />

#### 代码实现

```java
package 算法;

public class _4_希尔排序 {
    // 交换法
    public static void shellSort(int[] arr) {
        int temp;
        int count = 0;

        /**
        // 第一次排序
        for(int i = 5; i < arr.length; i++){
            for(int j = i - 5; j >= 0; j -= 5){
                if (arr[j] > arr[j + 5]) {
                    temp = arr[j];
                    arr[j] = arr[j + 5];
                    arr[j + 5] = temp;
                }
            }
        }
        System.out.println("希尔排序第一轮 = " + Arrays.toString(arr));

        // 第二次排序
        for(int i = 2; i < arr.length; i++){
            for(int j = i - 2; j >= 0; j -= 2){
                if (arr[j] > arr[j + 2]) {
                    temp = arr[j];
                    arr[j] = arr[j + 2];
                    arr[j + 2] = temp;
                }
                System.out.println("希尔排序第二轮 = " + Arrays.toString(arr));
            }
        }
        System.out.println("希尔排序第二轮 = " + Arrays.toString(arr));

        // 第三次排序
        for(int i = 1; i < arr.length; i++){
            for(int j = i - 1; j >= 0; j -= 1){
                if (arr[j] > arr[j + 1]) {
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
        System.out.println("希尔排序第三轮 = " + Arrays.toString(arr));
         */

        // 总结上述规律的如下代码
        for (int gap = arr.length / 2; gap > 0; gap /= 2) {
            for (int i = gap; i < arr.length; i++) {
                // 遍历各组中所有的元素(共gap组，每组 arr.length / gap 有个元素), 步长gap
                for (int j = i - gap; j >= 0; j -= gap) {
                    // 如果当前元素大于加上步长后的那个元素，说明交换
                    if (arr[j] > arr[j + gap]) {
                        temp = arr[j];
                        arr[j] = arr[j + gap];
                        arr[j + gap] = temp;
                    }else {
                        break;
                    }
//                    System.out.println("希尔排序第" + (++count) + "轮 = " + Arrays.toString(arr));
                }
            }
//            System.out.println("希尔排序第" + (++count) + "轮 = " + Arrays.toString(arr));
        }
    }

    //优化： 交换法->移位法
    public static void shellSort2(int[] arr) {
        // 增量gap, 并逐步的缩小增量
        for (int gap = arr.length / 2; gap > 0; gap /= 2) {
            // 从第gap个元素，逐个对其所在的组进行直接插入排序
            for (int i = gap; i < arr.length; i++) {
                int j = i;
                int temp = arr[j];

                if (arr[j] < arr[j - gap]) {
                    while (j - gap >= 0 && temp < arr[j - gap]) {
                        //移动
                        arr[j] = arr[j - gap];
                        j -= gap;
                    }
                    //当退出while后，就给temp找到插入的位置
                    arr[j] = temp;
                }
            }
        }
    }
}
```

### 快速排序(Quick Sort)

#### 快速排序介绍

> - 快速排序（Quick Sort）是对冒泡排序的一种改进。
>
> - 基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列

#### 快速排序示意图

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220719112626281.png" alt="image-20220719112626281" style="zoom:50%;" />

#### 代码实现


```java
package 算法;

import java.util.Arrays;

public class _5_快速排序 {
    public static void quickSort(int[] arr, int left, int right) {
        int l = left;//左下标
        int r = right;//右下标
        int pivot = arr[(left + right) / 2];//pivot 中轴值
        int temp;//临时变量，作为交换时使用

        //while循环的目的是：让比pivot值小放到左边，比pivot值大放到右边
        while (l < r) {
            // 注意：此处不写=号，如果写了=，会有问题
            // 如：[1, 4, 2, 5, 3, 7, 23]：1.使得l为5，r为4，导致break，没有达到左小右大的目的；2.如果数组中的中轴值最小或最大，导致数组l++，r--数组越界
            //在pivot的左边一直找,找到大于等于pivot值,才退出
            while (arr[l] < pivot) l++;
            //在pivot的右边一直找,找到小于等于pivot值,才退出
            while (arr[r] > pivot) r--;

            //如果l>=r说明pivot 的左右两的值，已经按照左边全部是小于等于pivot值，右边全部是大于等于pivot值
            if (l >= r) break;

            //交换
            temp = arr[l];
            arr[l] = arr[r];
            arr[r] = temp;

            // 交换完后，必然是满足左小于等于，右大于等于条件，不必在参与下次循环判断；
            // 如果不自增自减，左右都是pivot值，会出现死循环，如：[3,4,5,5,6,7]
            l++;
            r--;
        }

        // 如果 l==r, 必须l++,r--, 否则为出现栈溢出：java.lang.StackOverflowError
        // 如：[1,2,3]，r==l==1,
        if (l == r) {
            l++;
            r--;
        }

        //向左递归
        if (left < r) quickSort(arr, left, r);
        //向右递归
        if (right > l) quickSort(arr, l, right);
    }
}
```
### 归并排序(Merge Sort)

#### 归并排序介绍

> - 归并排序（Merge Sort）是利用归并的思想实现的排序方法，该算法采用经典的**分治（ divide-and-conquer ）策略**
>
> - 分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之

#### 归并排序思想示意图

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220720111628647.png" alt="image-20220720111628647" style="zoom:70%;" />

#### 合并相邻有序子序列

> 再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[ 4 , 5 , 7 , 8 ]和[ 1 , 2 , 3 , 6 ]两个已经有序的子序列，合并为最终序列[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ]，来看下实现步骤

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220720111744396.png" alt="image-20220720111744396" style="zoom:67%;" />

#### 代码演示
```java
package 算法;

import java.util.Arrays;

public class _6_归并排序 {
    /**
     * 分治思想：分+合方法
     *
     * @param arr
     * @param left
     * @param right
     * @param temp
     */
    public static void mergeSort(int[] arr, int left, int right, int[] temp) {
        if (left < right) {
            int mid = (left + right) / 2;//中间索引
            //向左递归进行分解
            mergeSort(arr, left, mid, temp);
            //向右递归进行分解
            mergeSort(arr, mid + 1, right, temp);
            //合并
            merge(arr, left, mid, right, temp);
        }
    }

    /**
     * 合并的方法
     *
     * @param arr   排序的原始数组
     * @param left  左边有序序列的初始索引
     * @param mid   中间索引
     * @param right 右边索引
     * @param temp  做中转的数组
     */
    public static void merge(int[] arr, int left, int mid, int right, int[] temp) {
        int i = left;// 初始化i, 左边有序序列的初始索引
        int j = mid + 1;//初始化j, 右边有序序列的初始索引
        int t = 0;// 指向temp数组的当前索引

        //(一)先把左右两边(有序)的数据按照规则填充到temp数组，直到左右两边的有序序列，有一边处理完毕为止
        while (i <= mid && j <= right) {
            //如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素
            //即将左边的当前元素，填充到 temp数组，然后 t++,i++
            if (arr[i] <= arr[j]) {
                temp[t] = arr[i];
                t++;
                i++;
            } else {
                //反之,将右边有序序列的当前元素，填充到temp数组
                temp[t] = arr[j];
                t++;
                j++;
            }
        }

        //(二)把有剩余数据的一边的数据依次全部填充到temp
        while (i <= mid) {
            //左边的有序序列还有剩余的元素，就全部填充到temp
            temp[t] = arr[i];
            t++;
            i++;
        }
        while (j <= right) {//右边的有序序列还有剩余的元素，就全部填充到temp
            temp[t] = arr[j];
            t++;
            j++;
        }

        //(三)将temp数组的元素拷贝到arr，注意，并不是每次都拷贝所有
        t = 0;
        int tempLeft = left;//
        //第一次合并 tempLeft= 0 ,right= 1 // tempLeft= 2 right= 3 //tL= 0 ri= 3
        //最后一次 tempLeft= 0 right= 7
        while (tempLeft <= right) {
            arr[tempLeft] = temp[t];
            tempLeft++;
            t++;
        }
    }
}
```
### 基数排序(Radix Sort)

#### 基数排序(桶排序)介绍

> - 基数排序（Radix Sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用
> - 基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法
> - 基数排序(Radix Sort)是桶排序的扩展
> - 基数排序是 1887 年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。

#### 基数排序基本思想

> - 将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。
>
> - 这样说明，比较难理解，下面我们看一个图文解释，理解基数排序的步骤

#### 基数排序图文说明

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220723110117992.png" alt="image-20220723110117992" style="zoom:50%;" />

#### 代码实现

```java
package 算法;

public class _7_基数排序 {
    public static void radixSort(int[] arr) {
        //根据前面的推导过程，我们可以得到最终的基数排序代码
        // 1. 得到数组中最大的数的位数
        int max = arr[0];//假设第一数就是最大数
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        //得到最大数是几位数
        int maxLength = (max + "").length();

        //定义一个二维数组，表示 10 个桶, 每个桶就是一个一维数组
        // 1. 二维数组包含 10 个一维数组
        // 2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length
        // 3. 很明确，基数排序是使用空间换时间的经典算法
        int[][] bucket = new int[10][arr.length];

        //为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数
        //比如：bucketElementCounts[ 0 ], 记录的就是 bucket[ 0 ]桶的放入数据个数
        int[] bucketElementCounts = new int[10];

        //这里我们使用循环将代码处理
        for (int i = 0, n = 1; i < maxLength; i++, n *= 10) {
            //(针对每个元素的对应位进行排序处理)， 第一次是个位，第二次是十位，第三次是百位..
            for (int j = 0; j < arr.length; j++) {
                //取出每个元素的对应位的值
                int digitOfElement = arr[j] / n % 10;
                //放入到对应的桶中
                bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
                bucketElementCounts[digitOfElement]++;
            }
            //按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)
            int index = 0;
            //遍历每一桶，并将桶中是数据，放入到原数组
            for (int k = 0; k < bucketElementCounts.length; k++) {
                //如果桶中，有数据，我们才放入到原数组
                if (bucketElementCounts[k] != 0) {
                    //循环该桶即第k个桶(即第k个一维数组), 放入
                    for (int l = 0; l < bucketElementCounts[k]; l++) {
                        //取出元素放入到arr
                        arr[index++] = bucket[k][l];
                    }
                }
                //第i+ 1 轮处理后，需要将每个 bucketElementCounts[k]= 0 ！！！！
                bucketElementCounts[k] = 0;
            }
//            System.out.println("第"+(i+ 1 )+"轮，对个位的排序处理 arr="+Arrays.toString(arr));
        }

/**
        //第 1 轮(针对每个元素的个位进行排序处理)
        for (int j = 0; j < arr.length; j++) {
            //取出每个元素的个位的值
            int digitOfElement = arr[j] / 1 % 10;
            //放入到对应的桶中
            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
            bucketElementCounts[digitOfElement]++;
        }
        //按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)
        int index = 0;
        //遍历每一桶，并将桶中是数据，放入到原数组
        for (int k = 0; k < bucketElementCounts.length; k++) {
            //如果桶中，有数据，我们才放入到原数组
            if (bucketElementCounts[k] != 0) {
                // 循环该桶即第k个桶(即第k个一维数组), 放入
                for (int l = 0; l < bucketElementCounts[k]; l++) {
                    //取出元素放入到arr
                    arr[index++] = bucket[k][l];
                }
            }
            //第l轮处理后，需要将每个 bucketElementCounts[k]= 0 ！！！！
            bucketElementCounts[k] = 0;
        }
        System.out.println("第 1 轮，对个位的排序处理 arr=" + Arrays.toString(arr));

        // 第 2 轮(针对每个元素的十位进行排序处理)
        for (int j = 0; j < arr.length; j++) {
            // 取出每个元素的十位的值
            int digitOfElement = arr[j] / 10 % 10;// 748 / 10 => 74 % 10 => 4
            // 放入到对应的桶中
            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
            bucketElementCounts[digitOfElement]++;
        }
        // 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)
        index = 0;
        // 遍历每一桶，并将桶中是数据，放入到原数组
        for (int k = 0; k < bucketElementCounts.length; k++) {
            // 如果桶中，有数据，我们才放入到原数组
            if (bucketElementCounts[k] != 0) {
                // 循环该桶即第k个桶(即第k个一维数组), 放入
                for (int l = 0; l < bucketElementCounts[k]; l++) {
                    // 取出元素放入到arr
                    arr[index++] = bucket[k][l];
                }
            }

            //第 2 轮处理后，需要将每个 bucketElementCounts[k]= 0 ！！！！
            bucketElementCounts[k] = 0;
        }
        System.out.println("第 2 轮，对个位的排序处理 arr=" + Arrays.toString(arr));

        //第 3 轮(针对每个元素的百位进行排序处理)
        for (int j = 0; j < arr.length; j++) {
            // 取出每个元素的百位的值
            int digitOfElement = arr[j] / 100 % 10;// 748 / 100 => 7 % 10 = 7
            // 放入到对应的桶中
            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
            bucketElementCounts[digitOfElement]++;
        }
        // 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)
        index = 0;
        // 遍历每一桶，并将桶中是数据，放入到原数组
        for (int k = 0; k < bucketElementCounts.length; k++) {
            // 如果桶中，有数据，我们才放入到原数组
            if (bucketElementCounts[k] != 0) {
                // 循环该桶即第k个桶(即第k个一维数组), 放入
                for (int l = 0; l < bucketElementCounts[k]; l++) {
                    // 取出元素放入到arr
                    arr[index++] = bucket[k][l];
                }
            }

            //第 3 轮处理后，需要将每个 bucketElementCounts[k]= 0 ！！！！
            bucketElementCounts[k] = 0;
        }
        System.out.println("第 3 轮，对个位的排序处理 arr=" + Arrays.toString(arr));
 */
    }
}
```
#### 基数排序的说明

> 1 ) 基数排序是对传统桶排序的扩展，速度很快.
>
> 2 ) 基数排序是经典的空间换时间的方式，占用内存很大, 当对海量数据排序时，容易造成 OutOfMemoryError 。
> 3 ) 基数排序时稳定的。[注:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的]
> 4 ) 有负数的数组，我们不用基数排序来进行排序, 如果要支持负数，参考:https://code.i-harness.com/zh-CN/q/e98fa9

### 常用排序算法总结和对比

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220720113939412.png" alt="image-20220720113939412" style="zoom:50%;" />

#### 相关术语解释

> 1 ) 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；
>
> 2 ) 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；
>
> 3 ) 内排序：所有排序操作都在内存中完成；
>
> 4 ) 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；
>
> 5 ) 时间复杂度：一个算法执行所耗费的时间。
>
> 6 ) 空间复杂度：运行完一个程序所需内存的大小。
>
> 7 ) n: 数据规模
>
> 8 ) k: “桶”的个数
>
> 9 ) In-place: 不占用额外内存
>
> 10 )Out-place: 占用额外内存


## 查找算法

### 查找算法介绍

> 在java中，我们常用的查找有四种
>
> - 顺序(线性)查找
> - 二分查找/折半查找
> - 插值查找
> - 斐波那契查找

### 线性查找

> 有一个数列： { 1 , 8 , 10 , 89 , 1000 , 1234 } ，判断数列中是否包含此名称【顺序查找】 要求: 如果找到了，就提示找到，并给出下标值

#### 代码实现

```java
package 算法;

public class _8_线性查找 {
    public static void main(String[] args) {
        int arr[] = {1, 9, 11, -1, 34, 89};// 没有顺序的数组
        int index = _8_线性查找.seqSearch(arr, -11);
        if (index == -1) {
            System.out.println("没有找到到");
        } else {
            System.out.println("找到，下标为=" + index);
        }
    }

    /**
     * 这里我们实现的线性查找是找到一个满足条件的值，就返回
     *
     * @return
     * @paramarr
     * @paramvalue
     */
    public static int seqSearch(int[] arr, int value) {
        // 线性查找是逐一比对，发现有相同值，就返回下标
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == value) {
                return i;
            }
        }
        return -1;
    }
}
```
### 二分查找

#### 二分查找

> 请对一个有序数组进行二分查找 { 1 , 8 , 10 , 89 , 1000 , 1234 }，输入一个数看看该数组是否存在此数，并且求出下标，如果没有就提示"没有这个数"。

#### 实现思路

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220720192004148.png" alt="image-20220720192004148" style="zoom:50%;" />


#### 代码实现
```java
/**
     * 二分查找算法
     *
     * @return 如果找到就返回下标，如果没有找到，就返回 - 1
     * @paramarr 数组
     * @paramleft 左边的索引
     * @paramright 右边的索引
     * @paramfindVal 要查找的值
     */
    public static int binarySearch(int[] arr, int left, int right, int findVal) {
        // 当 left>right 时，说明递归整个数组，但是没有找到
        if (left > right) {
            return -1;
        }

        int mid = (left + right) / 2;
        int midVal = arr[mid];

        if (findVal > midVal) {// 向 右递归
            return binarySearch(arr, mid + 1, right, findVal);
        } else if (findVal < midVal) {// 向左递归
            return binarySearch(arr, left, mid - 1, findVal);
        } else {
            return mid;
        }
    }
```
#### 课后思考题

>  { 1 , 8, 10, 89, 1000, 1000, 1234 }当一个有序数组中，有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000

```java
 public static List<Integer> binarySearch2(int[] arr, int left, int right, int findVal) {
   List<Integer> resIndexlist = new ArrayList<Integer>();
   // 当 left > right 时，说明递归整个数组，但是没有找到
   if (left > right) {
     return resIndexlist;
   }
   int mid = (left + right) / 2;
   int midVal = arr[mid];

   if (findVal > midVal) {// 向 右递归
     return binarySearch2(arr, mid + 1, right, findVal);
   } else if (findVal < midVal) {// 向左递归
     return binarySearch2(arr, left, mid - 1, findVal);
   } else {
     // 思路分析
     // 1. 在找到mid 索引值，不要马上返回
     // 2. 向mid 索引值的左边扫描，将所有满足 1000 ， 的元素的下标，加入到集合ArrayList
     // 3. 向mid 索引值的右边扫描，将所有满足 1000 ， 的元素的下标，加入到集合ArrayList
     // 4. 将Arraylist返回
     //向mid 索引值的左边扫描，将所有满足 1000 ， 的元素的下标，加入到集合ArrayList
     int temp = mid - 1;
     while (true) {
       if (temp < 0 || arr[temp] != findVal) {//退出
         break;
       }
       //否则，就temp 放入到 resIndexlist
       resIndexlist.add(temp);
       temp--;//temp左移
     }
     resIndexlist.add(mid); //

     //向mid 索引值的右边扫描，将所有满足 1000 ， 的元素的下标，加入到集合ArrayList
     temp = mid + 1;
     while (true) {
       if (temp > arr.length - 1 || arr[temp] != findVal) {//退出
         break;
       }
       //否则，就temp 放入到 resIndexlist
       resIndexlist.add(temp);
       temp++;//temp右移
     }
     return resIndexlist;
   }
 }
```

### 插值查找

#### 基本介绍

> - 插值查找原理介绍：插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid处开始查找。
> - 将折半查找中的求mid 索引的公式，low 表示左边索引left，high表示右边索引right，key 就是前面我们讲的 findVal
>
> ![image-20220720195044550](https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220720195044550.png)
> - int mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]);/ * 插值索引 */
> 对应前面的代码公式：
> int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left])
>
> - 举例说明插值查找算法 1 - 100 的数组
>
>   <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220720195219363.png" alt="image-20220720195219363" style="zoom:50%;" />

#### 代码实现

```java
package 算法;

public class _10_插值查找 {
    public static void main(String[] args) {
        int arr[] = {1, 8, 10, 89, 1000, 1000, 1234};
        int index = insertValueSearch(arr, 0, arr.length - 1, 1234);
        System.out.println("index = " + index);
    }

    /**
     * 插值查找算法
     * 说明：插值查找算法，也要求数组是有序的
     * @return 如果找到，就返回对应的下标，如果没有找到，返回- 1
     * @paramarr 数组
     * @paramleft 左边索引
     * @paramright 右边索引
     * @paramfindVal 查找值
     */
    public static int insertValueSearch(int[] arr, int left, int right, int findVal) {
        //注意：findVal<arr[ 0 ] 和 findVal>arr[arr.length- 1 ] 必须需要
        // 否则我们得到的 mid 可能越界
        if (left > right || findVal < arr[0] || findVal > arr[arr.length - 1]) {
            return -1;
        }
        // 求出mid, 自适应
        int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);
        int midVal = arr[mid];
        if (findVal > midVal) {// 说明应该向右边递归
            return insertValueSearch(arr, mid + 1, right, findVal);
        } else if (findVal < midVal) {// 说明向左递归查找
            return insertValueSearch(arr, left, mid - 1, findVal);
        } else {
            return mid;
        }
    }
}
```

#### 注意事项

> - 对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找, 速度较快.
> - 关键字分布不均匀的情况下，该方法不一定比折半查找要好

### 斐波那契(黄金分割法)查找

#### 基本介绍

> - 黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是 0. 618 。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神奇的数字，会带来意向不大的效果。 
>
> - 斐波那契数列 { 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 }发现斐波那契数列的两个相邻数 的比例，无限接近 黄金分割值0. 618

#### 斐波那契(黄金分割法)原理

> 斐波那契查找原理与前两种相似，仅仅改变了中间节点（mid）的位置，mid不再是中间或插值得到，而是位于黄金分割点附近，即mid=low+F(k- 1 )- 1 （F代表斐波那契数列），如下图所示
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220720201233478.png" alt="image-20220720201233478" style="zoom:50%;" />

##### 对 **F(k- 1 )- 1** 的理解

>- 由斐波那契数列 F[k]=F[k- 1 ]+F[k- 2 ] 的性质，可以得到（F[k]- 1 ）=（F[k- 1 ]- 1 ）+（F[k- 2 ]- 1 ）+ 1 。该式说明：
>  只要顺序表的长度为F[k]- 1 ，则可以将该表分成长度为F[k- 1 ]- 1 和F[k- 2 ]- 1 的两段，即如上图所示。从而中间位置为mid=low+F(k- 1 )- 1
>- 类似的，每一子段也可以用相同的方式分割
>- 但顺序表长度n不一定刚好等于F[k]- 1 ，所以需要将原来的顺序表长度n增加至F[k]- 1 。这里的k值只要能使得F[k]- 1 恰好大于或等于n即可，由以下代码得到,顺序表长度增加后，新增的位置（从n+ 1 到F[k]- 1 位置），都赋为n位置的值即可。
>  while(n>fib(k)- 1 )
>  k++;

#### 代码实现


```java
package 算法;

import java.util.Arrays;

public class _11_斐波那契查找 {
    // 斐波那契数列大小
    public static int maxSize = 20;
  
    /**
     * 非递归方法得到一个斐波那契数列
     * @return
     */
    public static int[] fib() {
        int[] f = new int[maxSize];
        f[0] = 1;
        f[1] = 1;
        for (int i = 2; i < maxSize; i++) {
            f[i] = f[i - 1] + f[i - 2];
        }
        return f;
    }

    /**
     * 使用非递归的方式编写斐波那契查找算法
     * @return 返回对应的下标，如果没有- 1
     * @param a 数组
     * @param value 我们需要查找的关键码(值)
     */
    public static int fibSearch(int[] a, int value) {
        int low = 0;
        int high = a.length - 1;
        int k = 0;//表示斐波那契分割数值的下标

        int mid;//存放mid值
        int f[] = fib();//获取到斐波那契数列
        //获取到斐波那契分割数值的下标
        while (high > f[k] - 1) {
            k++;
        }
        //因为 f[k] 值 可能大于 a 的 长度，因此我们需要使用Arrays类，构造一个新的数组，并指向temp[]
        //不足的部分会使用 0 填充
        int[] temp = Arrays.copyOf(a, f[k]);
        //实际上需求使用a数组最后的数填充 temp
        //temp={ 1 , 8 , 10 , 89 , 1000 , 1234 , 0 , 0 } =>{ 1 , 8 , 10 , 89 , 1000 , 1234 , 1234 , 1234}
        for (int i = high + 1; i < temp.length; i++) {
            temp[i] = a[high];
        }

        // 使用while来循环处理，找到我们的数 value
        while (low <= high) {// 只要这个条件满足，就可以找
            mid = low + f[k - 1] - 1;
            if (value < temp[mid]) {//我们应该继续向数组的前面查找(左边)
                high = mid - 1;
                // k--
                // 1. 全部元素 =前面的元素 + 后边元素
                // 2 .f[k]=f[k- 1 ]+f[k- 2 ]
                //因为 前面有 f[k- 1 ]个元素,所以可以继续拆分 f[k- 1 ]=f[k- 2 ]+f[k- 3 ]
                //即 在 f[k- 1 ] 的前面继续查找 k--
                //即下次循环 mid=f[k- 1 - 1 ]- 1
                k--;
            } else if (value > temp[mid]) {// 我们应该继续向数组的后面查找(右边)
                low = mid + 1;
                //  k-= 2
                // 1. 全部元素 =前面的元素 + 后边元素
                // 2 .f[k]=f[k- 1 ]+f[k- 2 ]
                // 3. 因为后面我们有f[k- 2 ] 所以可以继续拆分 f[k- 1 ]=f[k- 3 ]+f[k- 4 ]
                // 4. 即在f[k- 2 ] 的前面进行查找 k-= 2
                // 5. 即下次循环 mid=f[k- 1 - 2 ]- 1
                k -= 2;
            } else {//找到
                //需要确定，返回的是哪个下标
                return Math.min(mid, high);
            }
        }
        return -1;
    }
}
```

## 哈希表

### 哈希表(散列)-GOOGLE上机题.

> 1 ) 看一个实际需求，google公司的一个上机题:
> 2 ) 有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,住址..),当输入该员工的id时,要求查找到该员工的 所有信息.
> 3 ) 要求: 不使用数据库,尽量节省内存,速度越快越好=>哈希表(散列)

### 哈希表的基本介绍

> 散列表（Hashtable，也叫哈希表），是根据关键码值(Keyvalue)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。


### GOOGLE公司的一个上机题

> 有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,名字,住址..),当输入该员工的id时,要求查找到该员工的 所有信息.
>
> 要求:
> 1 ) 不使用数据库,,速度越快越好=>哈希表(散列)
> 2 ) 添加时，保证按照id从低到高插入 [课后思考：如果 **id** 不是从低到高插入，但要求各条链表仍是从低到高，怎么解决?]
> 3 ) 使用链表来实现哈希表, 该链表不带表头[即: 链表的第一个节点就存放雇员信息]
> 4 ) 思路分析并画出示意图
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220720213528577.png" alt="image-20220720213528577" style="zoom:50%;" />

##### 代码实现

```java
import java.util.Scanner;

public class _16_哈希表 {
    public static void main(String[] args) {

        //创建哈希表
        HashTab hashTab = new HashTab(7);

        //写一个简单的菜单
        String key = "";
        Scanner scanner = new Scanner(System.in);
        while (true) {
            System.out.println("a(add): 添加雇员");
            System.out.println("l(list): 显示雇员");
            System.out.println("e(find): 查找雇员");
            System.out.println("e(exit): 退出系统");

            key = scanner.next();
            switch (key) {
                case "a":
                    System.out.println("输入id");
                    int id = scanner.nextInt();
                    System.out.println("输入名字");
                    String name = scanner.next();
                    //创建 雇员
                    Emp emp = new Emp(id, name);
                    hashTab.add(emp);
                    break;
                case "l":
                    hashTab.list();
                    break;
                case "f":
                    System.out.println("请输入要查找的id");
                    id = scanner.nextInt();
                    hashTab.findEmpById(id);
                    break;
                case "e":
                    scanner.close();
                    System.exit(0);
                default:
                    break;
            }
        }
    }
}

//创建HashTab  管理多条链表
class HashTab {
    private EmpLinkedList[] empLinkedListArray;
    private int size;//表示有多少条链表

    //构造器
    public HashTab(int size) {
        this.size = size;
        //初始化empLinkedListArray
        empLinkedListArray = new EmpLinkedList[size];
        //？留一个坑, 这时不要分别初始化每个链表
        for (int i = 0; i < size; i++) {
            empLinkedListArray[i] = new EmpLinkedList();
        }
    }

    //添加雇员
    public void add(Emp emp) {
        //根据员工的id,得到该员工应当添加到哪条链表
        int empLinkedListNO = hashFun(emp.id);
        //将emp 添加到对应的链表中
        empLinkedListArray[empLinkedListNO].add(emp);

    }

    //遍历所有的链表,遍历hashtab
    public void list() {
        for (int i = 0; i < size; i++) {
            empLinkedListArray[i].list(i);
        }
    }

    //根据输入的id,查找雇员
    public void findEmpById(int id) {
        //使用散列函数确定到哪条链表查找
        int empLinkedListNO = hashFun(id);
        Emp emp = empLinkedListArray[empLinkedListNO].findEmpById(id);
        if (emp != null) {//找到
            System.out.printf("在第%d条链表中找到 雇员 id=%d\n", (empLinkedListNO + 1), id);
        } else {
            System.out.println("在哈希表中，没有找到该雇员~");
        }
    }

    //编写散列函数, 使用一个简单取模法
    public int hashFun(int id) {
        return id % size;
    }
}

//表示一个雇员
class Emp {
    public int id;
    public String name;
    public Emp next;//next 默认为 null

    public Emp(int id, String name) {
        super();
        this.id = id;
        this.name = name;
    }
}

//创建 EmpLinkedList,表示链表
class EmpLinkedList {
    //头指针，执行第一个 Emp ,因此我们这个链表的head 是直接指向第一个 Emp 
    private Emp head;//默认null

    //添加雇员到链表
    // 1. 假定，当添加雇员时，id 是自增长，即id的分配总是从小到大
    // 因此我们将该雇员直接加入到本链表的最后即可
    public void add(Emp emp) {
        //如果是添加第一个雇员
        if (head == null) {
            head = emp;
            return;
        }
        //如果不是第一个雇员，则使用一个辅助的指针，帮助定位到最后
        Emp curEmp = head;
        while (true) {
            if (curEmp.next == null) {//说明到链表最后
                break;
            }
            curEmp = curEmp.next;//后移
        }
        //退出时直接将emp 加入链表
        curEmp.next = emp;
    }

    //遍历链表的雇员信息
    public void list(int no) {
        if (head == null) {//说明链表为空
            System.out.println("第 " + (no + 1) + " 链表为空");
            return;
        }
        System.out.print("第 " + (no + 1) + " 链表的信息为");
        Emp curEmp = head;//辅助指针
        while (true) {
            System.out.printf("=>id=%dname=%s\t", curEmp.id, curEmp.name);
            if (curEmp.next == null) {//说明curEmp 已经是最后节点
                break;
            }
            curEmp = curEmp.next;//后移，遍历
        }
        System.out.println();
    }

    //根据id查找雇员
    // 如果查找到，就返回 Emp , 如果没有找到，就返回null
    public Emp findEmpById(int id) {
        //判断链表是否为空
        if (head == null) {
            System.out.println("链表为空");
            return null;
        }
        //辅助指针
        Emp curEmp = head;
        while (true) {
            if (curEmp.id == id) {//找到
                break;//这时curEmp 就指向要查找的雇员
            }
            //退出
            if (curEmp.next == null) {//说明遍历当前链表没有找到该雇员
                curEmp = null;
                break;
            }
            curEmp = curEmp.next;//以后
        }
        return curEmp;
    }
}
```


## 树

### 二叉树

#### 树的优势

> **数组存储方式的分析**
>
> - 优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。
>
> - 缺点：如果要检索具体某个值，或者插入值 ( 按一定顺序 ) 会整体移动，效率较低 
>
>   <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220720215247437.png" alt="image-20220720215247437" style="zoom:50%;" />
>
> **链式存储方式的分析**
>
> - 优点：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可，删除效率也很好)
>
> - 缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历) 
>
>   <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220720215357292.png" alt="image-20220720215357292" style="zoom:50%;" />
>
> **树存储方式的分析**
>
> - 能提高数据存储，读取的效率, 比如利用 二叉排序树(BinarySortTree)，既可以保证数据的检索速度，同时也
>   可以保证数据的插入，删除，修改的速度。
>
>   <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220720215533230.png" alt="image-20220720215533230" style="zoom:50%;" />

#### 树示意图

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220720215639304.png" alt="image-20220720215639304" style="zoom:67%;" />


##### 树的常用术语

> 1 ) 节点
>
> 2 ) 根节点
>
> 3 ) 父节点
>
> 4 ) 子节点
>
> 5 ) 叶子节点 (没有子节点的节点)
>
> 6 ) 节点的权(节点值)
>
> 7 ) 路径(从root节点找到该节点的路线)
>
> 8 ) 层
>
> 9 ) 子树
>
> 10 )树的高度(最大层数)
>
> 11 )森林 :多颗子树构成森林
>
> 12)度：子节点个数

####  二叉树的概念

> - 树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树
>
> - 二叉树的子节点分为左节点和右节点
>
>   <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220720220019311.png" alt="image-20220720220019311" style="zoom:50%;" />
>
> - 如果该二叉树的所有叶子节点都在最后一层，并且节点总数= **(2 ^n) - 1** ,n 为层数，则我们称为满二叉树
>
>   <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220723110236715.png" alt="image-20220723110236715" style="zoom:50%;" />
>
> - 完全二叉树是由满二叉树而引出来的，若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的节点数都达到最大个数(即1~h-1层为一个满二叉树)，第 h 层所有的节点都连续集中在最左边，这就是完全二叉树
>
>   <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220720220147029.png" alt="image-20220720220147029" style="zoom:50%;" />

#### 二叉树遍历

> - 前序遍历: 先输出父节点，再遍历左子树和右子树
> - 中序遍历: 先遍历左子树，再输出父节点，再遍历右子树
> - 后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点
> - 小结 : 看输出父节点的顺序，就确定是前序，中序还是后序

##### 遍历思路

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220720221554462.png" alt="image-20220720221554462" style="zoom:60%;" />

##### 代码实现
```java
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class _17_二叉树遍历 {
    public static List<Integer> res = new ArrayList<>();
    public static void main(String[] args) {
        //创建需要的节点
        HeroNode2 root = new HeroNode2(1, "宋江");
        HeroNode2 node2 = new HeroNode2(2, "吴用");
        HeroNode2 node3 = new HeroNode2(3, "卢俊义");
        HeroNode2 node4 = new HeroNode2(4, "林冲");
        HeroNode2 node5 = new HeroNode2(5, "关胜");
        //说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树
        root.left = node2;
        root.right = node3;
        node3.right = node4;
        node3.left = node5;
        //     1
        //   2   3
        //      5 4
        System.out.println("前序遍历");// 1 , 2 , 3 , 5 , 4
//        System.out.println(preorderTraversal(root));
        System.out.println(preorderTraversal2(root));
        System.out.println("中序遍历");
        res = new ArrayList<>();
//        System.out.println(inorderTraversal(root));// 2 , 1 , 5 , 3 , 4
        System.out.println(inorderTraversal2(root));// 2 , 1 , 5 , 3 , 4
        System.out.println("后序遍历");
        res = new ArrayList<>();
//        System.out.println(postorderTraversal(root));// 2 , 5 , 4 , 3 , 1
        System.out.println(postorderTraversal2(root));// 2 , 5 , 4 , 3 , 1
    }

    /**
     * 前序遍历-递归
     */
    public static List<Integer> preorderTraversal(HeroNode2 root) {
        if(root == null) return res;
        res.add(root.no);
        preorderTraversal(root.left);
        preorderTraversal(root.right);
        return res;
    }

    /**
     * 中序遍历-递归
     */
    public static List<Integer> inorderTraversal(HeroNode2 root){
        if(root == null) return res;
        inorderTraversal(root.left);
        res.add(root.no);
        inorderTraversal(root.right);
        return res;
    }

    /**
     * 后序遍历-递归
     */
    public static List<Integer> postorderTraversal(HeroNode2 root){
        if(root == null) return res;
        postorderTraversal(root.left);
        postorderTraversal(root.right);
        res.add(root.no);
        return res;
    }

    /**
     * 前序遍历-循环
     */
    public static List<Integer> preorderTraversal2(HeroNode2 root) {
        Stack<HeroNode2> stack = new Stack<>();
        List<Integer> res = new ArrayList<>();
        while(root != null || !stack.empty()){
            while(root != null){
                res.add(root.no);
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            root = root.right;
        }
        return res;
    }
    /**
     * 中序遍历-循环
     */
    public static List<Integer> inorderTraversal2(HeroNode2 root){
        Stack<HeroNode2> stack = new Stack<>();
        List<Integer> res = new ArrayList<>();
        while(root != null || !stack.empty()){
            while (root != null){
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            res.add(root.no);
            root = root.right;
        }
        return res;
    }
    /**
     * 后序遍历-循环
     */
    public static List<Integer> postorderTraversal2(HeroNode2 root){
        Stack<HeroNode2> stack = new Stack<>();
        List<Integer> res = new ArrayList<>();
        HeroNode2 pre = null;//用来记录上一节点
        while(root != null || !stack.empty()){
            while(root != null){
                stack.push(root);
                root = root.left;
            }
            root = stack.peek();
            // 如果没有右节点，或者已经遍历了右节点，就将根节点放入res中
            if(root.right == null || root.right == pre){
                res.add(root.no);
                pre = stack.pop();;
                root = null;
            }else{
                // 如果有右节点，且未被访问过，则访问右节点
                root = root.right;
            }
        }
        return res;
    }
}

class HeroNode2 {
    public int no;
    public String name;
    public HeroNode2 left;//默认null
    public HeroNode2 right;//默认null

    public HeroNode2(int no, String name) {
        this.no = no;
        this.name = name;
    }

    @Override
    public String toString() {
        return "HeroNode2 [no=" + no + ",name=" + name + "]";
    }
}
```
#### 二叉树查找节点

> 请编写前序查找，中序查找和后序查找的方法。
>
> 并分别使用三种查找方式，查找 heroNO= 5 的节点
>
> 并分析各种查找方式，分别比较了多少次
>
> 思路分析图解
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220720223608913.png" alt="image-20220720223608913" style="zoom:50%;" />

##### 代码实现

```java
import java.util.ArrayList;
import java.util.List;

public class _18_二叉树查找 {
    public static List<Integer> res = new ArrayList<>();
    public static HeroNode2 resNode;
    public static boolean found = false;
    public static void main(String[] args) {
        //创建需要的节点
        HeroNode2 root = new HeroNode2(1, "宋江");
        HeroNode2 node2 = new HeroNode2(2, "吴用");
        HeroNode2 node3 = new HeroNode2(3, "卢俊义");
        HeroNode2 node4 = new HeroNode2(4, "林冲");
        HeroNode2 node5 = new HeroNode2(5, "关胜");
        //说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树
        root.left = node2;
        root.right = node3;
        node3.right = node4;
        node3.left = node5;
        //     1
        //   2   3
        //      5 4
        System.out.println("前序查找");// 1 , 2 , 3 , 5 , 4
        found = false;
        System.out.println(preorderSearch(root, 2));
        System.out.println("中序查找");
        found = false;
        System.out.println(inorderSearch(root, 2));// 2 , 1 , 5 , 3 , 4
        System.out.println("后序查找");
        found = false;
        System.out.println(postorderSearch(root, 2));// 2 , 5 , 4 , 3 , 1
    }

    /**
     * 前序查找-递归
     */
    public static HeroNode2 preorderSearch(HeroNode2 root, int no) {
        if(root == null) return null;
        System.out.println("查找至：" + root);
        if(root.no == no) {
            found = true;
            return root;
        }
        if(!found) resNode = preorderSearch(root.left, no);
        if(!found) resNode = preorderSearch(root.right, no);
        return resNode;
    }

    /**
     * 中序查找-递归
     */
    public static HeroNode2 inorderSearch(HeroNode2 root, int no){
        if(root == null) return null;
        if(!found) resNode = inorderSearch(root.left, no);
        System.out.println("查找至：" + root);
        if(root.no == no) {
            found = true;
            return root;
        }
        if(!found) resNode = inorderSearch(root.right, no);
        return resNode;
    }

    /**
     * 后序查找-递归
     */
    public static HeroNode2 postorderSearch(HeroNode2 root, int no){
        if(root == null) return null;
        if(!found) resNode = postorderSearch(root.left, no);
        if(!found) resNode= postorderSearch(root.right, no);
        System.out.println("查找至：" + root);
        if(root.no == no){
            found = true;
            return root;
        }
        return resNode;
    }
}
```

#### 二叉树删除节点

> 如果删除的节点是叶子节点，则删除该节点
>
> 如果删除的节点是非叶子节点，则删除该子树.
>
> 测试，删除掉 5 号叶子节点 和 3 号子树
>
> 完成删除思路分析
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220721152653171.png" alt="image-20220721152653171" style="zoom:50%;" />

##### 代码实现

```java
import java.util.ArrayList;
import java.util.List;

public class _19_二叉树删除 {
    public static List<Integer> res = new ArrayList<>();
    public static HeroNode2 resNode;
    public static boolean delete = false;
    public static void main(String[] args) {
        //创建需要的节点
        HeroNode2 root = new HeroNode2(1, "宋江");
        HeroNode2 node2 = new HeroNode2(2, "吴用");
        HeroNode2 node3 = new HeroNode2(3, "卢俊义");
        HeroNode2 node4 = new HeroNode2(4, "林冲");
        HeroNode2 node5 = new HeroNode2(5, "关胜");
        //说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树
        root.left = node2;
        root.right = node3;
        node3.right = node4;
        node3.left = node5;
        //     1
        //   2   3
        //      5 4
        System.out.println(_17_二叉树遍历.preorderTraversal(root));
        _17_二叉树遍历.res = new ArrayList<>();
        System.out.println("二叉树删除");// 1 , 2 , 3 , 5 , 4
        System.out.println(preorderSearch(root, 3));
        System.out.println(_17_二叉树遍历.preorderTraversal(root));
    }

    /**
     * 二叉树删除-递归
     */
    public static boolean preorderSearch(HeroNode2 root, int no) {
        if(root == null) return false;
        if(root.left != null && root.left.no == no) {
            root.left = null;
            delete = true;
            return delete;
        }
        if(root.right != null && root.right.no == no){
            root.right = null;
            delete = true;
            return delete;
        }
        if(!delete) delete = preorderSearch(root.left, no);
        if(!delete) delete = preorderSearch(root.right, no);
        return delete;
    }
}
```
##### 思考题

>如果要删除的节点是非叶子节点，现在我们不希望将该非叶子节点为根节点的子树删除，需要指定规则， 假如规定如下:
>
>- 如果该非叶子节点A只有一个子节点B，则子节点B替代节点A
>- 如果该非叶子节点A有左子节点B和右子节点C，则让左子节点B替代节点A。

### 顺序存储二叉树

#### 概念

> - 基本说明：从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组，如示意图。
>
>   <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220721154334419.png" alt="image-20220721154334419" style="zoom:50%;" />
>
> - 要求
>
>   - 右图的二叉树的节点，要求以数组的方式来存放 arr:[ 1 , 2 , 3 , 4 , 5 , 6 , 6 ]
>   - 要求在遍历数组 arr时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成节点的遍历
>
> - 特点
>
>   - 顺序二叉树通常只考虑完全二叉树
>   - 下标为 n 的的元素的左子节点下标为 2 * n + 1
>   - 下标为 n 的的元素的右子节点下标为 2 * n + 2
>   - 下标为 n 的的元素的父节点下标为 (n - 1) / 2



#### 遍历

> 需求: 给你一个数组 { 1 , 2 , 3 , 4 , 5 , 6 , 7 }，要求以二叉树前序遍历的方式进行遍历。 前序遍历的结果应当为1 , 2 , 4 , 5 , 3 , 6 , 7

##### 代码实现
```java
public class _20_顺序存储二叉树 {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6, 7};
        System.out.print("前序遍历输出：");
        preorderArray(arr, 0);
        System.out.println();
        System.out.print("中序遍历输出：");
        inorderArray(arr, 0);
        System.out.println();
        System.out.print("后序遍历输出：");
        postorderArray(arr, 0);
        System.out.println();
    }

    /**
     * 前序遍历输出
     * @param arr
     * @param index
     */
    public static void preorderArray(int[] arr, int index){
        if(index < 0 || index >= arr.length)  return;
        System.out.print(arr[index] + " ");
        preorderArray(arr, 2 * index + 1);
        preorderArray(arr, 2 * index + 2);
    }

    /**
     * 中序遍历输出
     * @param arr
     * @param index
     */
    public static void inorderArray(int[] arr, int index){
        if(index < 0 || index >= arr.length)  return;
        inorderArray(arr, 2 * index + 1);
        System.out.print(arr[index] + " ");
        inorderArray(arr, 2 * index + 2);
    }

    /**
     * 后序遍历输出
     * @param arr
     * @param index
     */
    public static void postorderArray(int[] arr, int index){
        if(index < 0 || index >= arr.length)  return;
        postorderArray(arr, 2 * index + 1);
        postorderArray(arr, 2 * index + 2);
        System.out.print(arr[index] + " ");
    }
}
```

#### 应用实例

> 八大排序算法中的堆排序，就会使用到顺序存储二叉树，关于堆排序，我们放在<<树结构实际应用>> 章节讲解。

### 线索二叉树

#### 提出问题

> 将数列 { 1 , 3 , 6 , 8 , 10 , 14 }构建成一颗二叉树
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220721165143660.png" alt="image-20220721165143660" style="zoom:50%;" />
>
> - 问题分析:
> - 当我们对上面的二叉树进行中序遍历时，数列为 { 8 , 3 , 10 , 1 , 6 , 14 }，但是 6 , 8 , 10 , 14 这几个节点的 左右指针，并没有完全的利用上。如果我们希望充分的利用 各个节点的左右指针， 让各个节点可以指向自己的前后节点,怎么办?
> - 解决方案-线索二叉树

#### 基本介绍

> - n个节点的二叉链表中含有n + 1 【公式 2 n - ( n - 1 ) = n + 1 】个空指针域。利用二叉链表中的空指针域，存放指向该节点在某种遍历次序下的前驱和后继节点的指针（这种附加的指针称为"线索"）
> - 这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(ThreadedBinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种
> - 一个节点的前一个节点，称为前驱节点。比如在中序遍历下：3的前驱节点为8
> - 一个节点的后一个节点，称为后继节点。比如在中序遍历下：3的后继节点为10

#### 应用案例

> 应用案例说明：将下面的二叉树，进行中序线索二叉树。中序遍历的数列为 { 8 , 3 , 10 , 1 , 14 , 6 }
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220721170918936.png" alt="image-20220721170918936" style="zoom:50%;" />
>
> 说明: 当线索化二叉树后，Node节点的 属性 left 和 right ，有如下情况:
> 1 ) left 指向的是左子树，也可能是指向的前驱节点. 比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的
> 就是前驱节点.
> 2 ) right指向的是右子树，也可能是指向后继节点，比如 ① 节点right 指向的是右子树，而⑩ 节点的right 指向
> 的是后继节点.

#### 代码实现

```java
public class _21_线索二叉树 {
    public static void main(String[] args) {
        //测试一把中序线索二叉树的功能
        HeroNode root = new HeroNode(1, "tom");
        HeroNode node2 = new HeroNode(3, "jack");
        HeroNode node3 = new HeroNode(6, "smith");
        HeroNode node4 = new HeroNode(8, "mary");
        HeroNode node5 = new HeroNode(10, "king");
        HeroNode node6 = new HeroNode(14, "dim");

        //二叉树，后面我们要递归创建, 现在简单处理使用手动创建
        root.setLeft(node2);
        root.setRight(node3);
        node2.setLeft(node4);
        node2.setRight(node5);
        node3.setLeft(node6);
        //               1
        //           3      6
        //          8 10  14

        //测试中序线索化
        ThreadedBinaryTree threadedBinaryTree = new ThreadedBinaryTree();
        threadedBinaryTree.setRoot(root);
        threadedBinaryTree.threadedNodes();

        //测试: 以 10 号节点测试
        HeroNode leftNode = node5.getLeft();
        HeroNode rightNode = node5.getRight();
        System.out.println(" 10 号节点的前驱节点是 =" + leftNode);// 3
        System.out.println(" 10 号节点的后继节点是=" + rightNode);// 1

        //当线索化二叉树后，能在使用原来的遍历方法
        //threadedBinaryTree.infixOrder();
        System.out.println("使用线索化的方式遍历 线索化二叉树");
        threadedBinaryTree.threadedList();// 8 , 3 , 10 , 1 , 14 , 6
    }
}

//定义ThreadedBinaryTree  实现了线索化功能的二叉树
class ThreadedBinaryTree {
    private HeroNode root;

    //为了实现线索化，需要创建要给指向当前节点的前驱节点的指针
    //在递归进行线索化时，pre 总是保留前一个节点
    private HeroNode pre = null;

    public void setRoot(HeroNode root) {
        this.root = root;
    }

    //重载一把threadedNodes方法
    public void threadedNodes() {
        this.threadedNodes(root);
    }

    //遍历线索化二叉树的方法
    public void threadedList() {
        //定义一个变量，存储当前遍历的节点，从root开始
        HeroNode node = root;
        while (node != null) {
            //循环的找到leftType== 1 的节点，第一个找到就是 8 节点
            // 后面随着遍历而变化,因为当leftType== 1 时，说明该节点是按照线索化
            // 处理后的有效节点
            while (node.getLeftType() == 0) {
                node = node.getLeft();
            }
            //打印当前这个节点
            System.out.println(node);
            //如果当前节点的右指针指向的是后继节点,就一直输出
            while (node.getRightType() == 1) {
                //获取到当前节点的后继节点
                node = node.getRight();
                System.out.println(node);
            }
            //替换这个遍历的节点
            node = node.getRight();

        }
    }

    /**
     * 对二叉树进行中序线索化
     * @paramnode 就是当前需要线索化的节点
     */
    public void threadedNodes(HeroNode node) {
        //如果node==null, 不能线索化
        if (node == null) {
            return;
        }

        //(一)先线索化左子树
        threadedNodes(node.getLeft());
        //(二)线索化当前节点[有难度]，处理当前节点的前驱节点
        // /以 8 节点来理解，8 节点的.left=null, 8 节点的.leftType= 1
        if (node.getLeft() == null) {
            ///让当前节点的左指针指向前驱节点
            node.setLeft(pre);
            ///修改当前节点的左指针的类型,指向前驱节点
            node.setLeftType(1);
        }
        ///处理后继节点
        if (pre != null && pre.getRight() == null) {
            ///让前驱节点的右指针指向当前节点
            pre.setRight(node);
            //修改前驱节点的右指针类型
            pre.setRightType(1);
        }
        //!!! 每处理一个节点后，让当前节点是下一个节点的前驱节点
        pre = node;

        //(三)在线索化右子树
        threadedNodes(node.getRight());
    }

    //删除节点
    public void delNode(int no) {
        if (root != null) {
            //如果只有一个root节点, 这里立即判断root是不是就是要删除节点
            if (root.getNo() == no) {
                root = null;
            } else {
                //递归删除
                root.delNode(no);
            }
        } else {
            System.out.println("空树，不能删除~");
        }
    }

    //前序遍历
    public void preOrder() {
        if (this.root != null) {
            this.root.preOrder();
        } else {
            System.out.println("二叉树为空，无法遍历");
        }
    }

    //中序遍历
    public void infixOrder() {
        if (this.root != null) {
            this.root.infixOrder();
        } else {
            System.out.println("二叉树为空，无法遍历");
        }
    }

    //后序遍历
    public void postOrder() {
        if (this.root != null) {
            this.root.postOrder();
        } else {
            System.out.println("二叉树为空，无法遍历");
        }


    }

    //前序遍历
    public HeroNode preOrderSearch(int no) {
        if (root != null) {
            return root.preOrderSearch(no);
        } else {
            return null;
        }
    }

    //中序遍历
    public HeroNode infixOrderSearch(int no) {
        if (root != null) {
            return root.infixOrderSearch(no);
        } else {
            return null;
        }
    }

    //后序遍历
    public HeroNode postOrderSearch(int no) {
        if (root != null) {
            return this.root.postOrderSearch(no);
        } else {
            return null;
        }
    }
}

//先创建HeroNode  节点
class HeroNode {
    private int no;
    private String name;
    private HeroNode left;//默认null
    private HeroNode right;//默认null
    //说明
    // 1. 如果leftType== 0 表示指向的是左子树, 如果 1 则表示指向前驱节点
    // 2. 如果rightType== 0 表示指向是右子树, 如果 1 表示指向后继节点
    private int leftType;
    private int rightType;

    public int getLeftType() {
        return leftType;
    }

    public void setLeftType(int leftType) {
        this.leftType = leftType;
    }

    public int getRightType() {
        return rightType;
    }

    public void setRightType(int rightType) {
        this.rightType = rightType;
    }

    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "HeroNode [no=" + no + ",name=" + name + "]";
    }

    //递归删除节点
    // 1 .如果删除的节点是叶子节点，则删除该节点
    // 2 .如果删除的节点是非叶子节点，则删除该子树
    public void delNode(int no) {
        /**
         * 1. 因为我们的二叉树是单向的，所以我们是判断当前节点的子节点是否需要删除节点，而不能去判断当前这个节点是不是需要删除节点.
         * 2. 如果当前节点的左子节点不为空，并且左子节点 就是要删除节点，就将this.left=null; 并且就返回(结束递归删除)
         * 3. 如果当前节点的右子节点不为空，并且右子节点 就是要删除节点，就将this.right=null;并且就返回(结束递归删除)
         * 4. 如果第 2 和第 3 步没有删除节点，那么我们就需要向左子树进行递归删除
         * 5. 如果第 4 步也没有删除节点，则应当向右子树进行递归删除.
         */
        // 2. 如果当前节点的左子节点不为空，并且左子节点 就是要删除节点，就将this.left=null; 并且就返回(结束递归删除)
        if (this.left != null && this.left.no == no) {
            this.left = null;
            return;
        }
        // 3 .如果当前节点的右子节点不为空，并且右子节点 就是要删除节点，就将this.right=null;并且就返回(结束递归删除)
        if (this.right != null && this.right.no == no) {
            this.right = null;
            return;
        }
        // 4 .我们就需要向左子树进行递归删除
        if (this.left != null) {
            this.left.delNode(no);
        }
        // 5 .则应当向右子树进行递归删除
        if (this.right != null) {
            this.right.delNode(no);
        }
    }

    //编写前序遍历的方法
    public void preOrder() {
        System.out.println(this);//先输出父节点
        // 递归向左子树前序遍历
        if (this.left != null) {
            this.left.preOrder();
        }
        //递归向右子树前序遍历
        if (this.right != null) {
            this.right.preOrder();
        }
    }

    //中序遍历
    public void infixOrder() {
        //递归向左子树中序遍历
        if (this.left != null) {
            this.left.infixOrder();
        }
        //输出父节点
        System.out.println(this);
        //递归向右子树中序遍历
        if (this.right != null) {
            this.right.infixOrder();
        }
    }

    //后序遍历
    public void postOrder() {
        if (this.left != null) {
            this.left.postOrder();
        }

        if (this.right != null) {
            this.right.postOrder();
        }
        System.out.println(this);
    }

    /**
     * 前序遍历查找
     *
     * @return 如果找到就返回该Node, 如果没有找到返回 null
     * @paramno 查找no
     */
    public HeroNode preOrderSearch(int no) {
        System.out.println("进入前序遍历");
        //比较当前节点是不是
        if (this.no == no) {
            return this;
        }
        // 1 .则判断当前节点的左子节点是否为空，如果不为空，则递归前序查找
        // 2 .如果左递归前序查找，找到节点，则返回
        HeroNode resNode = null;
        if (this.left != null) {
            resNode = this.left.preOrderSearch(no);
        }
        if (resNode != null) {//说明我们左子树找到
            return resNode;
        }
        // 1 .左递归前序查找，找到节点，则返回，否继续判断，
        // 2 .当前的节点的右子节点是否为空，如果不空，则继续向右递归前序查找
        if (this.right != null) {
            resNode = this.right.preOrderSearch(no);
        }
        return resNode;
    }

    //中序遍历查找
    public HeroNode infixOrderSearch(int no) {
        //判断当前节点的左子节点是否为空，如果不为空，则递归中序查找
        HeroNode resNode = null;
        if (this.left != null) {
            resNode = this.left.infixOrderSearch(no);
        }
        if (resNode != null) {
            return resNode;
        }
        System.out.println("进入中序查找");
        //如果找到，则返回，如果没有找到，就和当前节点比较，如果是则返回当前节点
        if (this.no == no) {
            return this;
        }
        //否则继续进行右递归的中序查找
        if (this.right != null) {
            resNode = this.right.infixOrderSearch(no);
        }
        return resNode;

    }

    //后序遍历查找
    public HeroNode postOrderSearch(int no) {
        //判断当前节点的左子节点是否为空，如果不为空，则递归后序查找
        HeroNode resNode = null;
        if (this.left != null) {
            resNode = this.left.postOrderSearch(no);
        }
        if (resNode != null) {//说明在左子树找到
            return resNode;
        }

        //如果左子树没有找到，则向右子树递归进行后序遍历查找
        if (this.right != null) {
            resNode = this.right.postOrderSearch(no);
        }
        if (resNode != null) {
            return resNode;
        }

        System.out.println("进入后序查找");
        //如果左右子树都没有找到，就比较当前节点是不是
        if (this.no == no) {
            return this;
        }
        return resNode;
    }
}
```
#### 课后作业

> 我这里讲解了中序线索化二叉树，前序线索化二叉树和后序线索化二叉树的分析思路类似，同学们作为课后作业完成.

### 堆排序

#### 基本介绍

>- 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为 **O(nlogn)** ，它也是不稳定排序。
>
>- 堆是具有以下性质的完全二叉树：每个节点的值都大于或等于其左右孩子节点的值，称为大顶堆, 注意 : 没有要求节点的左孩子的值和右孩子的值的大小关系。
>
>- 每个节点的值都小于或等于其左右孩子节点的值，称为小顶堆
>
>- 大顶堆举例说明
>
>  <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220721180922680.png" alt="image-20220721180922680" style="zoom:50%;" />
>
>- 小顶堆举例说明
>
>  <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220721180937445.png" alt="image-20220721180937445" style="zoom:50%;" />
>
>- 一般升序采用大顶堆，降序采用小顶堆


#### 基本思想

> 1 ) 将待排序序列构造成一个大顶堆
>
> 2 ) 此时，整个序列的最大值就是堆顶的根节点。
>
> 3 ) 将其与末尾元素进行交换，此时末尾就为最大值。
>
> 4 ) 然后将剩余 n - 1 个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。
>
> 可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了.

#### 步骤图解说明

> **步骤一 构造初始堆**。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。原始的数组 [ 4 , 6 , 8 , 5 , 9 ]
>
> ​	1 ) .假设给定无序序列结构如下
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220721192444599.png" alt="image-20220721192444599" style="zoom:50%;" />
>
> ​	2 ) .此时我们从最后一个非叶子节点开始（叶节点自然不用调整，第一个非叶子节点arr.length/ 2 - 1 = 5 / 2 - 1 = 1 ，也就是下面的 6 节点），从左至右，从下至上进行调整。
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220721192507514.png" alt="image-20220721192507514" style="zoom:50%;" />
>
> ​	3 ) .找到第二个非叶节点 4 ，由于[ 4 , 9 , 8 ]中 9 元素最大， 4 和 9 交换。
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220721192524908.png" alt="image-20220721192524908" style="zoom:50%;" />
>
> ​	4 ) 这时，交换导致了子根[ 4 , 5 , 6 ]结构混乱，继续调整，[ 4 , 5 , 6 ]中 6 最大，交换 4 和 6 。
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220721192547775.png" alt="image-20220721192547775" style="zoom:50%;" />
>
> ​	此时，我们就将一个无序序列构造成了一个大顶堆。
>
> **步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大**。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。
>
> ​	1 ) .将堆顶元素 9 和末尾元素 4 进行交换
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220721192605378.png" alt="image-20220721192605378" style="zoom:50%;" />
>
> ​	2 ) .重新调整结构，使其继续满足堆定义
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220721192624824.png" alt="image-20220721192624824" style="zoom:50%;" />
>
> ​	3 ) .再将堆顶元素 8 与末尾元素 5 进行交换，得到第二大元素 8.
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220723110308785.png" alt="image-20220723110308785" style="zoom:50%;" />
>
> ​	4 ) 后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220721192657769.png" alt="image-20220721192657769" style="zoom:50%;" />




#### 基本思路

> 1 ).将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;
>
> 2 ).将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;
>
> 3 ).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。

#### 代码实现
```java
import java.util.Arrays;

public class _12_堆排序 {
    public static void main(String[] args) {
        int arr[] = {4, 6, 8, 5, 9};
        heapSort(arr);
        System.out.println("排序后 = " + Arrays.toString(arr));
    }

    public static void heapSort(int arr[]) {
        int temp;

        //将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆
        for (int i = arr.length / 2 - 1; i >= 0; i--) {
            adjustHeap(arr, i, arr.length);
        }

        /**
         * 将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;
         * 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。
         */
        for (int j = arr.length - 1; j > 0; j--) {
            //交换
            temp = arr[j];
            arr[j] = arr[0];
            arr[0] = temp;
            // 传入0，因为是位置0的元素变化了，所有从0开始调整
            adjustHeap(arr, 0, j);
        }
    }

    /**
     * 功能： 完成 将 以 i 对应的非叶子节点的树调整成大顶堆
     * 举例 int arr[]={ 4 , 6 , 8 , 5 , 9 };=>i= 1 =>adjustHeap=> 得到 { 4 , 9 , 8 , 5 , 6 }
     * 如果我们再次调用 adjustHeap 传入的是 i= 0 =>得到 { 4 , 9 , 8 , 5 , 6 }=>{ 9 , 6 , 8 , 5 , 4 }
     *
     * @param arr 待调整的数组
     * @param i 表示非叶子节点在数组中索引
     * @param length 表示对多少个元素继续调整， length 是在逐渐的减少
     */
    public static void adjustHeap(int arr[], int i, int length) {
        int temp = arr[i];//先取出当前元素的值，保存在临时变量
        // left 是 i节点 的左子节点
        int left = i * 2 + 1;
        for (int k = left; k < length; k = k * 2 + 1) {
            // 如果有右节点，且左子节点的值小于右子节点的值，则将k 指向右子节点
            if (k + 1 < length && arr[k] < arr[k + 1]) {
                k++;
            }
            // 如果子节点大于父节点，把较大的值赋给父节点
            if (arr[k] > temp) {
                arr[i] = arr[k];
                i = k;//!!!i 指向 k,继续循环比较
            } else {
                break;
            }
        }
        //当for 循环结束后，我们已经将以i 为父节点的树的最大值，放在了 最顶(局部)
        arr[i] = temp;//将temp值放到调整后的位置
    }
}
```

### 哈夫曼树(最优二叉树)

#### 基本介绍

> 1 ) 给定n个权值作为n个**叶子节点**，构造一棵二叉树，若该树的带权路径长度 **(wpl)** 达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(HuffmanTree), 还有的书翻译为霍夫曼树。
> 2 ) 哈夫曼树是带权路径长度最短的树，权值较大的节点离根较近

#### 重要概念和举例说明

>1 ) 路径和路径长度：在一棵树中，从一个节点往下可以达到的孩子或孙子节点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根节点的层数为 1 ，则从根节点到第L层节点的路径长度为L- 1
>
>2 ) 节点的权及带权路径长度：若将树中节点赋给一个有着某种含义的数值，则这个数值称为该节点的权。结点的带权路径长度为：从根节点到该节点之间的路径长度与该节点的权的乘积
>
>3 ) 树的带权路径长度：树的带权路径长度规定为所有叶子节点的带权路径长度之和，记为WPL(weighted path length)，权值越大的节点离根节点越近的二叉树才是最优二叉树。
>
>4 ) WPL最小的就是哈夫曼树
>
><img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220721205849390.png" alt="image-20220721205849390" style="zoom:50%;" />



#### 哈夫曼树创建思路图解

> 给你一个数列 { 13 , 7 , 8 , 3 , 29 , 6 , 1 }，要求转成一颗哈夫曼树
>
> 步骤：
>
> - 从小到大进行排序，每个数据都是一个节点 ，每个节点可以看成是一颗最简单的二叉树
>
> - 取出根节点权值最小的两颗二叉树
>
> - 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和
>
> - 再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1 - 2 - 3 - 4 的步骤，直到数列中，所有的数据都被处理，就得到一颗哈夫曼树
>
> - 图解:
>
>   <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220721215931230.png" alt="image-20220721215931230" style="zoom:50%;" />

#### 代码实现
```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class _22_哈夫曼树 {
    public static void main(String[] args) {
        int arr[] = {13, 7, 8, 3, 29, 6, 1};
        System.out.println(_17_二叉树遍历.preorderTraversal(createHuffmanTree(arr)));
    }

    /**
     * 创建哈夫曼树的方法
     * @return 创建好后的哈夫曼树的root节点
     * @paramarr 需要创建成哈夫曼树的数组
     */
    public static HeroNode2 createHuffmanTree(int[] arr) {
        List<HeroNode2> nodes = new ArrayList<>();
        for (int value : arr) {
            nodes.add(new HeroNode2(value));
        }

        while (nodes.size() > 1) {
            //排序 从小到大
            Collections.sort(nodes, Comparator.comparingInt(o -> o.no));

            //取出根节点权值最小的两颗二叉树
            //( 1 ) 取出权值最小的节点（二叉树）
            HeroNode2 leftHeroNode2 = nodes.get(0);
            //( 2 ) 取出权值第二小的节点（二叉树）
            HeroNode2 rightHeroNode2 = nodes.get(1);
            //( 3 )构建一颗新的二叉树
            HeroNode2 parent = new HeroNode2(leftHeroNode2.no + rightHeroNode2.no);
            parent.left = leftHeroNode2;
            parent.right = rightHeroNode2;
            //( 4 )从ArrayList删除处理过的二叉树
            nodes.remove(leftHeroNode2);
            nodes.remove(rightHeroNode2);
            //( 5 )将parent加入到nodes
            nodes.add(parent);
        }
        //返回哈夫曼树的root节点
        return nodes.get(0);
    }
}
```

### 哈夫曼编码

#### 基本介绍

> 1 ) 哈夫曼编码也翻译为 哈夫曼编码(HuffmanCoding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法
>
> 2 ) 哈夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。
>
> 3 ) 哈夫曼编码广泛地用于**数据文件压缩**。其压缩率通常在 20 %～ 90 %之间
>
> 4 ) 哈夫曼码是可变字长编码(VLC)的一种。Huffman于 1952 年提出一种编码方法，称之为最佳编码

#### 原理剖析

##### 定长编码

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220721225202949.png" alt="image-20220721225202949" style="zoom:50%;" />

##### 变长编码

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220721225237218.png" alt="image-2022072122 5237218" style="zoom:50%;" />


##### 哈夫曼编码

###### 步骤如下

> 传输的 字符串
>
> 1 ) i like like like java do you like a java
>
> 2 ) d: 1 y: 1 u: 1 j: 2 v: 2 o: 2 l: 4 k: 4 e: 4 i: 5 a: 5  空格: 9 // 各个字符对应的个数
>
> 3 ) 按照上面字符出现的次数构建一颗哈夫曼树, 次数作为权值
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220721235307346.png" alt="image-20220721235307346" style="zoom:50%;" />
>
> 4 ) 根据哈夫曼树，给各个字符,规定编码 (前缀编码)， 向左的路径为 0 向右的路径为 1 ， 编码如下:
>
> o: 1000 u: 10010 d: 100110 y: 100111 i: 101 a: 110 k: 1110 e: 1111 j: 0000 v: 0001 l: 001 : 01
>
> 5 ) 按照上面的哈夫曼编码，我们的"i like like like java do you like a java" 字符串对应的编码为 (注意这里我们使用的无损压缩)
>
> **10101001** 101111011110100110111101111010011011110111101000011000011100110011110000110
>
> 01111000100100100110111101111011100100001100001110 通过哈夫曼编码处理 长度为 133
>
> 6 ） 长度为 ： 133，说明：原来长度是 359 , 压缩了 ( 359 - 133 )/ 359 = 62. 9 %。此编码满足前缀编码, 即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性。哈夫曼编码是无损处理方案

###### 注意事项

> 注意, 这个哈夫曼树根据排序方法不同，也可能不太一样，这样对应的哈夫曼编码也不完全一样，但是 **wpl** 是一样的，都是最小的, 最后生成的哈夫曼编码的长度是一样，比如: 如果我们让每次生成的新的二叉树总是排在权值相同的二叉树的最后一个，则生成的二叉树为:

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220721235343604.png" alt="image-20220721235343604" style="zoom:80%;" />

#### 最佳实践-数据压缩

> 将给出的一段文本，比如 "i like like like java do you like a java" ， 根据前面的讲的哈夫曼编码原理，对其进行数据压缩处理，形式如
>
> " 1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100
> 110111101111011100100001100001110"

##### 代码实现
```java
import java.nio.charset.StandardCharsets;
import java.time.LocalDate;
import java.util.*;

public class _23_哈夫曼编码 {
    static Map<Byte, String> byteMap = new HashMap<>();
    public static void main(String[] args) {
        String s = "i like like like java do you like a java";
        byte[] hfmCode = getHfmCode(s);
        System.out.println(Arrays.toString(hfmCode));
    }

    /**
     * 将字符串转为哈夫曼编码
     * @param s
     * @return
     */
    private static byte[] getHfmCode(String s) {
        byte[] bytes = s.getBytes(StandardCharsets.UTF_8);
        // 构建哈夫曼树
        HeroNode2 root = createHuffmanTree(bytes);
        // 获取映射表
        StringBuffer codeRes = new StringBuffer();
        preorderTraversal(root, "", codeRes);
        // 根据映射表将s转为哈夫曼编码
        byte [] byteArray = conver2ByteArray(s);
        return byteArray;
    }

    /**
     * 可以通过List 创建对应的哈夫曼树
     * @param bytes
     * @return
     */
    private static HeroNode2 createHuffmanTree(byte[] bytes) {
        List<HeroNode2> nodes = new ArrayList<>();
        Map<Byte, Integer> map = new HashMap<>();
        for (byte c : bytes) {
            if (map.get(c) == null) {
                map.put(c, 1);
            } else {
                int count = map.get(c);
                map.put(c, ++count);
            }
        }
        for (Map.Entry<Byte, Integer> entity : map.entrySet()) {
            nodes.add(new HeroNode2(entity.getValue(), "" +entity.getKey()));
        }
        while (nodes.size() > 1) {
            Collections.sort(nodes, Comparator.comparingInt(o -> o.no));
            HeroNode2 leftNode = nodes.get(0);
            HeroNode2 rightNode = nodes.get(1);
            HeroNode2 parent = new HeroNode2(leftNode.no + rightNode.no);
            parent.left = leftNode;
            parent.right = rightNode;
            nodes.remove(leftNode);
            nodes.remove(rightNode);
            nodes.add(parent);
        }
        return nodes.get(0);
    }

    /**
     * 将字符在哈夫曼树上的位置转为编码，左子节点为0，右子节点为1
     * @param root
     * @param code
     * @param stringBuffer
     */
    private static void preorderTraversal(HeroNode2 root, String code, StringBuffer stringBuffer){
        if(root == null) return;
        StringBuffer sb = new StringBuffer(stringBuffer);
        sb.append(code);
        // 如果是叶子节点
        if(root.name != null) {
            byteMap.put((byte)Integer.parseInt(root.name), sb.toString());
        }else {
            // 如果不是叶子节点，就递归查找
            preorderTraversal(root.left, "0", sb);
            preorderTraversal(root.right, "1", sb);
        }
    }

    /**
     * 将字符串根据映射表转为 byte[]
     * @param s
     * @return
     */
    private static byte[] conver2ByteArray(String s) {
        StringBuilder res = new StringBuilder();
        for (byte entity : s.getBytes(StandardCharsets.UTF_8)) {
            res.append(byteMap.get(entity));
        }
        // 将哈夫曼编码的StringBuilder转为 byte[]
        int length = (res.length() % 8 == 0) ? res.length() / 8 : res.length() / 8 + 1;
        byte[] resByte = new byte[length];
        int index = 0;
        for (int i = 0; i < res.length(); i += 8) {
            resByte[index++] = (byte) Integer.parseInt(res.substring(i, Math.min(i + 8, res.length())));
        }
        return resByte;
    }
}
```
#### 最佳实践-数据解压

> 根据byte[], 即:[- 88 ,- 65 ,- 56 ,- 65 ,- 56 ,- 65 ,- 55 , 77,- 57 , 6 ,- 24 ,- 14 ,- 117 ,- 4 ,- 60 ,- 90 , 28 ]，使用哈夫曼编码， 进行解码，又
> 重新得到原来的字符串"i like like like java do you like a java"
>
> 10101000
>
> 11011000

##### 代码实现

```java
/**
     * 完成对压缩数据的解码
     *
     * @return 就是原来的字符串对应的数组
     * @param huffmanCodes 哈夫曼编码表map
     * @param huffmanBytes 哈夫曼编码得到的字节数组
     */
private static byte[] decode(Map<Byte, String> huffmanCodes, byte[] huffmanBytes) {
  StringBuilder stringBuilder = new StringBuilder();
  //将byte数组转成二进制的字符串
  for (int i = 0; i < huffmanBytes.length; i++) {
    byte b = huffmanBytes[i];
    //判断是不是最后一个字节
    boolean notLast = (i != huffmanBytes.length - 1);
    stringBuilder.append(byteToBitString(notLast, b));
  }
  // 把哈夫曼编码表进行调换，因为反向查询 a-> 100100 - >a
  Map<String, Byte> map = new HashMap<String, Byte>();
  for (Map.Entry<Byte, String> entry : huffmanCodes.entrySet()) {
    map.put(entry.getValue(), entry.getKey());
  }

  //创建要给集合，存放byte
  List<Byte> list = new ArrayList<>();
  //i 可以理解成就是索引,扫描 stringBuilder
  for (int i = 0; i < stringBuilder.length(); ) {
    int count = 1;// 小的计数器
    boolean flag = true;
    Byte b = null;

    while (flag) {
      String key = stringBuilder.substring(i, i + count);//i 不动，让count移动，指定匹配到一个字符
      b = map.get(key);
      if (b == null) {//说明没有匹配到
        count++;
      } else {//匹配到
        flag = false;
      }
    }
    list.add(b);
    i += count;//i 直接移动到 count
  }
  //当for循环结束后，我们list中就存放了所有的字符 "i like like like java do you like a java"
  //把list 中的数据放入到byte[] 并返回
  byte b[]=new byte[list.size()];
  for (int i = 0; i < b.length; i++) {
    b[i] = list.get(i);
  }
  return b;
}

/**
     * 将一个byte 转成一个二进制的字符串, 如果看不懂，可以参考我讲的Java基础 二进制的原码，反码，补码
     *
     * @return 是该b 对应的二进制的字符串，（注意是按补码返回）
     * @param b 传入的 byte
     * @param notLast 非最后一个字节，如果是true，表示不是最后一个字节，需要补高位，如果是false，表示是最后一个字节，无需补高位
     */
private static String byteToBitString(boolean notLast, byte b) {
  // 如果是正数就要补高位，否则substring会越界，比如 2 转为2进制是 10，subString(2-8)会越界
  // 按位或 256 100000000 | 00000001 => 100000001
  String str = Integer.toBinaryString(notLast ? b | 256 : b);//返回的是temp对应的二进制的补码
  // 最后一个正数不用补0
  return notLast ? str.substring(str.length() - 8) : str;
}
```
#### 最佳实践-文件压缩-解压缩

> - 我们学习了通过哈夫曼编码对一个字符串进行编码和解码, 下面我们来完成对文件的压缩和解压， 具体要求：给你一个图片文件，要求对其进行无损压缩, 看看压缩效果如何。思路：读取文件-> 得到哈夫曼编码表 ->完成压缩
> - 具体要求：将前面压缩的文件，重新恢复成原来的文件。思路：读取压缩文件(数据和哈夫曼编码表)-> 完成解压(文件恢复)

##### 代码实现
```java
File file1 = new File("/Users/leon_chiang/Study/Github/Programming/BasicKnowledge/数据结构与算法/数据结构/src.bmp");
File file2 = new File("/Users/leon_chiang/Study/Github/Programming/BasicKnowledge/数据结构与算法/数据结构/temp.zip");
File file3 = new File("/Users/leon_chiang/Study/Github/Programming/BasicKnowledge/数据结构与算法/数据结构/des.bmp");
try(InputStream is = new FileInputStream(file1);
    OutputStream os = new FileOutputStream(file3);
    ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file2));
    ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file2))){

  /** 压缩 */
  byte[] bytes = new byte[is.available()];
  is.read(bytes, 0, bytes.length);
  System.out.println("压缩前，长度：" + bytes.length);
  byte[] hfmBytes = getHfmCode(bytes);
  System.out.println("压缩后，长度：" + hfmBytes.length);
  oos.writeObject(hfmBytes);
  oos.writeObject(byteMap);

  /** 解压缩 */
  byte[] hfmBytes2 = (byte[])ois.readObject();
  System.out.println("解压缩前，长度：" + hfmBytes2.length);
  Map<Byte, String> byteMap2 = (Map<Byte, String>)ois.readObject();
  byte[] res = decode(byteMap2, hfmBytes2);
  System.out.println("解压缩后，长度：" + res.length);
  os.write(res);
}
```

#### 注意事项

> 1 ) 如果文件本身就是经过压缩处理的，那么使用哈夫曼编码再压缩效率不会有明显变化, 比如视频,ppt 等等文件
> 2 ) 哈夫曼编码是按字节来处理的，因此可以处理所有的文件(二进制文件、文本文件)
> 3 ) 如果一个文件中的内容，重复的数据不多，压缩效果也不会很明显.

### 二叉排序树(二叉搜索树)

> 给你一个数列 ( 7 , 3 , 10 , 12 , 5 , 1 , 9 )，要求能够高效的完成对数据的查询和添加
>
> **使用数组**
>
> - 数组未排序， 优点：直接在数组尾添加，速度快。 缺点：查找速度慢
> - 数组排序，优点：可以使用二分查找，查找速度快，缺点：为了保证数组有序，在添加新数据时，找到插入位置后，后面的数据需整体移动，速度慢。
>
> **使用链式存储-链表**
>
> - 不管链表是否有序，查找速度都慢，添加数据速度比数组快，不需要数据整体移动
>
> **使用二叉排序树**

#### 二叉排序树介绍

> 二叉排序树：BST：(Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求：**左子节点 < 当前节点 < 右子节点**
>
> 特别说明：如果有相同的值，可以将该节点放在左子节点或右子节点
>
> 比如针对前面的数据 ( 7 , 3 , 10 , 12 , 5 , 1 , 9 ) ，对应的二叉排序树为：
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220722172846616.png" alt="image-20220722172846616" style="zoom:50%;" />


#### 二叉排序树的创建

> 一个数组创建成对应的二叉排序树，并使用中序遍历二叉排序树，比如: 数组为 Array( 7 , 3 , 10 , 12 , 5 , 1 , 9 ) ，创建成对应的二叉排序树为 :
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220723092315742.png" alt="image-20220723092315742" style="zoom:50%;" />

##### 代码实现

```java
/**
 * 新增节点
 * @param root
 * @param addNode
 */
public static void addNode(HeroNode2 root, HeroNode2 addNode){
    if(root.no >= addNode.no){
        if(root.left == null){
            root.left = addNode;
        }else {
            addNode(root.left, addNode);
        }
    }else{
        if(root.right == null){
            root.right = addNode;
        }else {
            addNode(root.right, addNode);
        }
    }
}
```

#### 二叉排序树的删除

> 二叉排序树的删除情况比较复杂，有下面三种情况需要考虑
>
> **第一种情况**：删除叶子节点 (比如： 2 , 5 , 9 , 12 )
>
> ( 1 ) 需求先去找到要删除的节点 targetNode
> ( 2 ) 找到targetNode 的 父节点 parent
> ( 3 ) 确定 targetNode 是 parent的左子节点 还是右子节点
> ( 4 ) 根据前面的情况来对应删除：左子节点 parent.left=null，右子节点 parent.right=null;
>
> **第二种情况**： 删除只有一颗子树的节点 比如 1
>( 1 ) 需求先去找到要删除的节点 targetNode
> ( 2 ) 找到targetNode 的 父节点 parent
> ( 3 ) 确定targetNode 的子节点是左子节点还是右子节点
> ( 4 ) targetNode 是 parent 的左子节点还是右子节点
> ( 5 ) 如果 targetNode 是 parent 的左子节点
> 		如果targetNode 有左子节点 parent.left=targetNode.left;
> 		如果targetNode 有右子节点 parent.left=targetNode.right;
> ( 6 ) 如果 targetNode 是 parent 的右子节点
> 		如果targetNode 有左子节点 parent.right=targetNode.left;
> 		如果targetNode 有右子节点 parent.right=targetNode.right
> 
> **第三种情况** ： 删除有两颗子树的节点.(比如： 7 , 3 ， 10 )
>( 1 ) 需求先去找到要删除的节点 targetNode
> ( 2 ) 找到targetNode 的 父节点 parent
> ( 3 ) 从targetNode 的右子树找到最小的节点
> ( 4 ) 用一个临时变量，将 最小节点的值保存 temp= 11
> ( 5 ) 删除该最小节点
> ( 6 ) targetNode.value=temp

##### 代码实现

```java
 /**
     * 根据id删除节点
     *
     * @param root
     * @param no
     */
    public static void delNodeByNo(HeroNode2 root, int no) {
        // 找到需要删除的节点，判断该节点是否有子节点
        HeroNode2 desNode = new _18_二叉树查找().inorderSearch(root, no);
        // 如果没找到，直接返回
        if (desNode == null) return;
        // 查找需要删除节点的父节点
        HeroNode2 parentNode = new _24_二叉排序树().getParentNodeByNo(root, no);
        // 如果没有父节点，说明是根节点，重置根节点
        if (parentNode == null) {
            root.no = 0;
            root.left = null;
            root.right = null;
            return;
        }
        /** 情况1：删除节点为叶子节点：直接父节点的该叶子节点设为null */
        if (desNode.left == null && desNode.right == null) {
            if (desNode.no > parentNode.no) {
                parentNode.right = null;
            } else {
                parentNode.left = null;
            }
            return;
        }

        /** 情况2：删除节点为只有一个子节点：直接将 该节点 用 该节点的子节点 替换 */
        if(desNode.left == null || desNode.right == null){
            if (desNode.no > parentNode.no) {
                parentNode.right = desNode.left == null ? desNode.right : desNode.left;
            } else {
                parentNode.left = desNode.left == null ? desNode.right : desNode.left;
            }
            return;
        }

        /** 情况3：删除节点有两个子节点：直接将 该节点 用 右子树最左 或者 左子树最右节点 替换 */
        if(desNode.left != null && desNode.right != null) {
            HeroNode2 leftest = desNode.right;
            HeroNode2 preNode = null;
            // 找到右子树最左边节点
            while(leftest != null){
                preNode = leftest;
                leftest = leftest.left;
            }
            // 删除右子树最左边节点，并将该节点值放到 no节点位置
            new _19_二叉树删除().preorderDelete(root, preNode.no);
            // 如果右子树最左边节点，有右节点没有左节点，要将右节点上移
            if (desNode.no > parentNode.no) {
                parentNode.right.no = preNode.no;
                parentNode.right.right = (preNode.right != null) ? preNode.right :parentNode.left.right;
            } else {
                parentNode.left.no = preNode.no;
                parentNode.left.right = (preNode.right != null) ? preNode.right : parentNode.left.right;
            }
            return;
        }
    }
```

#### 课后练习

> 完成老师代码，并使用第二种方式来解决.如果我们从左子树找到最大的节点，然后前面的思路完成.

### 平衡二叉树(AVL树)

#### 二叉排序树的问题

> 给你一个数列{ 1 , 2 , 3 , 4 , 5 , 6 }，要求创建一颗二叉排序树(BST), 并分析问题所在.
> 1 ) 左子树全部为空，从形式上看，更像一个单链表.
> 2 ) 插入速度没有影响
> 3 ) 查询速度明显降低(因为需要依次比较), 不能发挥BST的优势，因为每次还需要比较左子树，其查询速度比单链表还慢
> 4 ) 解决方案-平衡二叉树(AVL)

#### 基本介绍

> 1 ) 平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树，可以保证查询效率较高。根据它的发明者G.M. **A**delson-**V**elsky和E.M. **L**andis命名
> 2 ) 具有以下特点：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过 **1** ，并且左右两个子树都是一棵平衡二叉树。
> 3 ) 平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。
> 4 ) 举例说明, 看看下面哪些AVL树, 为什么?
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220723155555673.png" alt="image-20220723155555673" style="zoom:50%;" />

#### 应用案例-单旋转(左旋转)

> 要求: 给你一个数列，创建出对应的平衡二叉树.数列 { 4 , 3 , 6 , 5 , 7 , 8 }

##### 思路分析(示意图)

> - 根节点成为右儿子的左子树；
> - 右儿子原有的左子树成为根节点的右子树

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220723160404494.png" alt="image-20220723160404494" style="zoom:50%;" />

##### 代码实现


```java
/**
     * 左旋转
     * @param root
     */
public static void leftRotate(HeroNode2 root) {
  //创建新的节点，以当前根节点的值
  HeroNode2 newRoot = new HeroNode2(root.no);
  //把新的节点的左子树设置成当前节点的左子树
  newRoot.left = root.left;
  //把新的节点的右子树设置成带你过去节点的右子树的左子树
  newRoot.right = root.right.left;
  //把当前节点的值替换成右子节点的值
  root.no = root.right.no;
  //把当前节点的右子树设置成当前节点右子树的右子树
  root.right = root.right.right;
  //把当前节点的左子树(左子节点)设置成新的节点
  root.left = newRoot;
}
```
#### 应用案例-单旋转(右旋转)

> 要求: 给你一个数列，创建出对应的平衡二叉树.数列 { 10 , 12 , 8 , 9 , 7 , 6 }

##### 思路分析(示意图)

> - 根节点成为左儿子的右子树
> - 左儿子原有的右子树成为根节点的左子树

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220723195010317.png" alt="image-20220723195010317" style="zoom:50%;" />

##### 代码实现

```java
/**
     * 右旋转
     * @param root
     */
public static void rightRotate(HeroNode2 root) {
  HeroNode2 newRoot = new HeroNode2(root.no);
  newRoot.right = root.right;
  newRoot.left = root.left.right;
  root.no = root.left.no;
  root.left = root.left.left;
  root.right = newRoot;
}
```
#### 应用案例-双旋转

> 前面的两个数列，进行单旋转(即一次旋转)就可以将非平衡二叉树转成平衡二叉树，但是在某些情况下，单旋转不能完成平衡二叉树的转换。比如数列
>
> int[]arr={ 10 , 11 , 7 , 6 , 8 , 9 }; 运行原来的代码可以看到，并没有转成AVL树.
> int[]arr={ 2 , 1 , 6 , 5 , 7 , 3 };// 运行原来的代码可以看到，并没有转成AVL树
>

##### 思路分析
> 1. 当符合右旋转的条件时
> 2. 如果它的左子树的右子树高度大于它的左子树的高度
> 3. 先对当前这个节点的左节点进行左旋转
> 4. 在对当前节点进行右旋转的操作即可

```java
/** 双旋转 */
//      10
//   7     11
//  6 8
//     9
/**
 * 左右旋转（LR）
 * 1. 如果它的左子树的右子树高度大于左子树的左子树的高度
 * 2. 先对当前这个节点的左节点进行左旋转
 * 3. 在对当前节点进行右旋转的操作即可*
 */
int leftLeftHeight = root.left == null ? 0 : getTreeHeight(root.left.left);
int leftRightHeight = root.left == null ? 0 : getTreeHeight(root.left.right);
if(leftLeftHeight < leftRightHeight) {
    leftRotate(root.left);
    rightRotate(root);
    return;
}
/**
 * 右左旋转（RL）
 * 1. 如果它的右子树的左子树高度大于右子树的左子树的高度
 * 2. 先对当前这个节点的右节点进行右旋转
 * 3. 在对当前节点进行左旋转的操作即可*
 */
int rightLeftHeight = root.right == null ? 0 : getTreeHeight(root.right.left);
int rightRightHeight = root.right == null ? 0 : getTreeHeight(root.right.right);
if(rightLeftHeight > rightRightHeight) {
    rightRotate(root.right);
    leftRotate(root);
    return;
}
```

### 红黑树(Red Black Tree)

> 具体参考链接：https://blog.csdn.net/cy973071263/article/details/122543826

#### AVL树存在的问题

> - AVL的左右子树高度差不能超过1，每次进行插入/删除操作时，几乎都需要通过旋转操作保持平衡
> - 在频繁进行插入/删除的场景中，频繁的旋转操作使得AVL的性能大打折扣
> - 红黑树通过牺牲严格的平衡，换取插入/删除时少量的旋转操作，整体性能优于AVL
>   - 红黑树插入时的不平衡，不超过两次旋转就可以解决；删除时的不平衡，不超过三次旋转就能解决
> - 红黑树的红黑规则，保证最坏的情况下，也能在O(log2N)时间内完成查找操作。

#### 基本介绍

> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220725155929403.png" alt="image-20220725155929403" style="zoom:50%;" />
>
> 红黑树是二叉排序树的一种，是平衡二叉树的变种。红黑树遵守如下5个规则：
>
> - 节点不是黑色就是红色
> - 根节点是黑色
> - 叶子节点（外部节点，空节点）都是**黑色，**这里的叶子节点指的是最底层的空节点（外部节点），下图中的那些null节点才是叶子节点，null节点的父节点在红黑树里不将其看作叶子节点
> - 根到叶子的所有路径，不可能存在两个连续的红色节点
> - 每个节点到叶子节点的所有路径，都包含相同数目的黑色节点（相同的黑色高度）
>
> 红黑树在每个节点增加了一个存储位记录节点的颜色，可以是RED,也可以是BLACK；通过任意一条从根到叶子简单路径上颜色的约束，红黑树保证最长路径不超过最短路径的**二倍**，因而近似平衡（最短路径就是全黑节点，最长路径就是一个红节点一个黑节点，当从根节点到叶子节点的路径上黑色节点相同时，最长路径刚好是最短路径的两倍）

#### 红黑树的定义

> 相较于AVL树，红黑树多了多一个颜色属性；为了方便确认插入位置，还可以多一个parent属性，用于表示当前节点的父节点

```java
class RedBlackTreeNode {
    public int val;
    public RedBlackTreeNode left;
    public RedBlackTreeNode right;
    // 记录节点颜色的color属性，暂定true表示红色
    public boolean color;
    // 为了方便迭代插入，所需的parent属性
    public RedBlackTreeNode parent;

    // 一些构造函数，根据实际需求构建
    public RedBlackTreeNode() {
    }
}
```

#### 红黑树等价变换

> 将所有的红色节点上移到和他们的父节点同一高度上，红黑树就变成了一棵四阶B树（一个节点最多放三个数据），结论：
>
> 1. 红黑树 和 4阶B树（2-3-4树）具有等价性
> 2. 黑色节点与它的红色子节点融合在一起，形成1个B树节点
> 3. 红黑树的**黑色节点个数** 与 4阶B树的节点总个数相等
> 4. 在所有的B树节点中，永远是黑色节点是父节点，红色节点是子节点。黑色节点在中间，红色节点在两边。

![image-20220725160507079](https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220725160507079.png)

> 利用四阶B树与红黑树等价的性质，以红黑树转换成B树之后的节点情况来进行一个分类

![image-20220725160823450](https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220725160823450.png)

#### 旋转

> 红黑树的旋转类似AVL的旋转，不同的是，红黑树不仅需要更新左右子树的引用，还需要更新父节点的引用

##### 左旋
<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220725103936069.png" alt="image-20220725103936069" style="zoom:67%;" />

```java
/**
 * 左旋转
 * @param p
 */
public static void leftRotate(RedBlackTreeNode p) {
    // 先记录p的右节点
    RedBlackTreeNode rightChild = p.right;

    // 1. p的右子树设置为右节点的左子树
    p.right = rightChild.left;
    // 左子树不为空，需要更新父节点
    if (rightChild.left != null) {
        rightChild.left.parent = p;
    }

    // 2. p的右节点的左子树设置为p
    rightChild.left = p;
    p.parent = rightChild;
    
    // 3. p的父节点的儿子 指向 p的右节点
    rightChild.parent = p.parent;
    // 父节点指向右儿子
    if (p.parent == null) {
        return;
    } else if (p == p.parent.left) { 
        p.parent.left = rightChild;
    } else {
        p.parent.right = rightChild;
    }
}
```

##### 右旋

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220725105800005.png" alt="image-20220725105800005" style="zoom:67%;" />

```java
/**
 * 右旋转
 * @param p
 */
public static void rightRotate(RedBlackTreeNode p) {
    // 记录p的左儿子
    RedBlackTreeNode leftChild = p.left;
    // 1. p的左子树设置为左节点的右子树
    p.left = leftChild.right;
    // 右子树不为空，需要更新父节点
    if (leftChild.right != null) {
        leftChild.right.parent = p;
    }

    // 2. p的左节点的右子树设置为p
    leftChild.right = p;
    p.parent = leftChild;
    
    // 3. p的父节点的儿子 指向 p的左节点
    leftChild.parent = p.parent;
    // 父节点指向左儿子
    if (p.parent == null) { 
        return;
    } else if (p.parent.left == p) { 
        p.parent.left = leftChild;
    } else { 
        p.parent.right = leftChild;
    }
}
```

#### 插入

> 插入新节点为红色，如果插入的节点是黑色，那么这个节点所在路径比其他路径多出一个黑色节点，这个调整起来会比较麻烦。如果插入的节点是红色，此时所有路径上的黑色节点数量不变，仅可能会出现两个连续的红色节点的情况。这种情况下，通过变色和旋转进行调整即可。所以插入的时候将节点设置为红色，可以保证满足性质 1、2、3、5 ，只有性质4不一定满足，需要进行相关调整。如果是添加根节点，则将节点设定为黑色。

##### 所有情况

> 在我们进行插入操作的时候，会将节点插入到所有的叶子节点中，总共就会有12种情况。
>
> 其中4种情况不需要调整即可满足红黑树的性质。
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220725162535119.png" alt="image-20220725162535119" style="zoom:25%;" />
>
> 另外8种情况不满足红黑树性质则需要调整。
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220725162705921.png" alt="image-20220725162705921" style="zoom:25%;" />

##### LL和RR插入情况

> 父节点没有兄弟节点
>
> **RR情况**：父节点为祖父节点的右节点，插入节点为父节点的右节点
>
> **LL情况**：父节点为祖父节点的左节点，插入节点为父节点的左节点

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220725162923082.png" alt="image-20220725162923082" style="zoom:25%;" />

> 1. parent 染成黑色，grand 染成红色
> 2. grand 进行单旋操作
>    1. LL：右旋转
>    2. RR：左旋转

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220725163628912.png" alt="image-20220725163628912" style="zoom:25%;" />

##### LR和RL插入情况

> 父节点没有兄弟节点
>
> **RL情况**：父节点为祖父节点的右节点，插入节点为父节点的左节点
>
> **LR情况**：父节点为祖父节点的左节点，插入节点为父节点的右节点

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220725163533370.png" alt="image-20220725163533370" style="zoom:25%;" />

> 1. 插入节点染成黑色，grand 染成红色
> 2. 进行双旋操作
>    - LR：parent 左旋转， grand 右旋转
>    - RL：parent 右旋转， grand 左旋转

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220725163931003.png" alt="image-20220725163931003" style="zoom:25%;" />

##### 上溢的LL插入情况

> 父节点存在兄弟节点，父节点为祖父节点的左节点，插入节点为父节点的左节点。并且构成的新的B树节点已经超过了B树节点容量大小范围

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220725164141122.png" alt="image-20220725164141122" style="zoom:25%;" />

> 1. parent、uncle 染成黑色
> 2. grand 向上合并
>    1. 将向上合并的grand染成红色，相对上一层，就当做是新添加的节点，再次来一遍插入情况的判断，进行处理
>    2. 如果上溢后没有超过3个节点，且出现两个连续的红色节点，则按照不上溢的LL处理，进行右旋，38为根节点并变成黑色，55变成红色且为38的右节点，46为55的左节点
>    3. 如果上溢后超过了3个节点，则继续上溢，直至不上溢为止

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220725164249251.png" alt="image-20220725164249251" style="zoom:25%;" />

##### 上溢的RR插入情况

> 父节点存在兄弟节点，父节点为祖父节点的右节点，插入节点为父节点的右节点。并且构成的新的B树节点已经超过了B树节点容量大小范围。

<img src="/Users/leon_chiang/Library/Application%20Support/typora-user-images/image-20220725165327764.png" alt="image-20220725165327764" style="zoom:25%;" />

> 1. parent、uncle 染成黑色
> 2. grand 向上合并
>    - 染成红色（其实染成红色就已经是完成了向上合并，因为祖父节点和祖父节点的父节点的连接指向并没有变），当做是新添加的节点进行处理

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220725165424780.png" alt="image-20220725165424780" style="zoom:25%;" />

##### 上溢的LR插入情况

> 父节点存在兄弟节点，父节点为祖父节点的左节点，插入节点为父节点的右节点。并且构成的新的B树节点已经超过了B树节点容量大小范围。

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220725165556669.png" alt="image-20220725165556669" style="zoom:25%;" />

> 1. parent、uncle 染成黑色
> 2. grand 向上合并
>    - 染成红色，当做是新添加的节点进行处理

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220725165708425.png" alt="image-20220725165708425" style="zoom:25%;" />

##### 上溢的RL插入情况

> 父节点存在兄弟节点，父节点为祖父节点的右节点，插入节点为父节点的左节点。并且构成的新的B树节点已经超过了B树节点容量大小范围。

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220725165844702.png" alt="image-20220725165844702" style="zoom:25%;" />

> 1. parent、uncle 染成黑色
> 2. grand 向上合并
>    - 染成黑色，当做是新添加的节点进行处理

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220725165925456.png" alt="image-20220725165925456" style="zoom:25%;" />

#### 删除

> 删除节点一定都在最后一层（可以参考二叉树节点删除，如果删除非叶子节点，会将右子树的最左节点或者左子树的最右节点删除，并将节点值复制到要删除的非叶子节点处），最后一层有红色节点和黑色节点，我们就以删除节点的颜色来区分删除操作的所有情况。

##### 所有情况

> - **删除红色节点**：直接删除，不用作任何调整。因为删除最后一层的红色节点，并没有影响红黑树的任何性质（如果是删除了下图调整后的80节点，直接将80用左节点72或者右节点88替换，颜色变成红色即可）
> - **删除黑色节点**：有2种情况：
>   1. 有1个或2个红色子节点的黑色节点
>   2. 黑色叶子节点

##### 有1个或2个红色子节点的黑色节点

> 1. 用删除节点的红色子节点对其进行替代
> 2. 将替代节点染成黑色

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220725172425697.png" alt="image-20220725172425697" style="zoom:50%;" />

##### 黑色叶子节点

###### 删除节点为根节点

> 一棵红黑树只有一个黑色根节点（也就是唯一的一个叶子节点，整个红黑树只有这一个黑色节点），可直接删除该节点，无需做其他操作

###### 删除节点的兄弟节点为黑色

> 兄弟节点有两个红色左右子节点

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220726093849435.png" alt="image-20220726093849435" style="zoom:50%;" />

> 兄弟节点有一个红色右子节点

![image-20220726093232552](https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220726093232552.png)

> 兄弟节点有一个红色左子节点

![image-20220726093556040](https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220726093556040.png)

> 兄弟节点没有红色子节点，且父节点为红色

![image-20220726094428278](https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220726094428278.png)

> 兄弟节点没有红色子节点，且父节点为黑色

![image-20220726094610935](https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220726094610935.png)

###### 删除节点的兄弟节点为红色

![image-20220726095407239](https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220726095407239.png)

#### AVL树 vs 红黑树
##### AVL树

>  平衡标准比较严格：每个左右子树的高度差不超过1
> 最大高度是 1.44 ∗ log2 n + 2 − 1.328（100W个节点，AVL树最大树高28）
> 搜索、添加、删除都是 O(logn) 复杂度，其中添加仅需 O(1) 次旋转调整、删除最多需要 O(logn) 次旋转调整
##### 红黑树
> 平衡标准比较宽松：没有一条路径会大于其他路径的2倍
> 最大高度是 2 ∗ log2(n + 1)（ 100W个节点，红黑树最大树高40）
> 搜索、添加、删除都是 O(logn) 复杂度，其中添加、删除都仅需 O(1) 次旋转调整
##### 如何选择
> - 搜索的次数远远大于插入和删除，选择AVL树；
> - 搜索、插入、删除次数几乎差不多，选择红黑树
> - 相对于AVL树来说，红黑树牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树
>   红黑树的平均统计性能优于AVL树，实际应用中更多选择使用红黑树



### 多路查找树

#### 二叉树与多叉树

##### 二叉树存在的问题

> 问题 1 ：在构建二叉树时，需要多次进行i/o操作(海量数据存在数据库或文件中)，节点海量，构建二叉树时，速度有影响
> 问题 2 ：节点海量，也会造成二叉树的高度很大，会降低操作速度.

##### 多叉树

> - 多叉树(multiway tree)： 在二叉树中，每个节点有数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点
>
> - 后面我们讲解的 2 - 3 树， 2 - 3 - 4 树就是多叉树，多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化。
>
> - 举例说明(下面 2 - 3 树就是一颗多叉树)
>
>   <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220724153143507.png" alt="image-20220724153143507" style="zoom:50%;" />


#### B树

##### B树的介绍

> B-tree树即B树，B即Balanced，平衡的意思。有人把B-tree翻译成B-树，容易让人产生误解。会以为B-树是一种树，而B树又是另一种树。实际上，B-tree就是指的B树。
>
> 我们在学习Mysql时，经常听到说某种类型的索引是基于B树或者B+树的，如图:
>
> <img src="/Users/leon_chiang/Library/Application%20Support/typora-user-images/image-20220724160747948.png" alt="image-20220724160747948" style="zoom:50%;" />
>
> 对上图的说明:
>
> 1 ) B树的阶：节点的最多子节点个数。比如 2-3 树的阶是 3 ， 2-3-4 树的阶是 4
>
> 2 ) B树的搜索，从根节点开始，对节点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子节点；重复，直到所对应的儿子指针为空，或已经是叶子节点
>
> 3 ) 关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据.
>
> 4 ) 搜索有可能在非叶子节点结束
>
> 5 ) 其搜索性能等价于在关键字全集内做一次二分查找

##### B树的作用

> B树通过重新组织节点，降低树的高度，并且减少i/o读写次数来提升效率。
>
> 1 ) 如图B树通过重新组织节点， 降低了树的高度.
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220724153255210.png" alt="image-20220724153255210" style="zoom:50%;" />
>
> 2 ) 文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页(页得大小通常为 4 k)，这样每个节点只需要一次I/O就可以完全载入
>
> 3 ) 将树的度M设置为 1024 ，在 600 亿个元素中最多只需要 4 次I/O操作就可以读取到想要的元素,B树(B+)广泛应用于文件存储系统以及数据库系统中

#### 2-3 树

> 2-3 树是最简单的B树结构,具有如下特点:
> 1 ) 2-3 树的所有叶子节点都在同一层.(只要是B树都满足这个条件)
> 2 ) 有两个子节点的节点叫**二节点**，二节点要么没有子节点，要么有两个子节点.
> 3 ) 有三个子节点的节点叫**三节点**，三节点要么没有子节点，要么有三个子节点.
> 4 ) 2-3 树是由二节点和三节点构成的树。

##### 2-3 树应用案例

> 将数列{ 16 , 24 , 12 , 32 , 14 , 26 , 34 , 10 , 8 , 28 , 38 , 20 } 构建成 2 - 3 树，并保证数据插入的大小顺序。(演示一下构建 2 - 3树的过程.)
>
> 插入规则:
>
> 1 ) 2 - 3 树的所有叶子节点都在同一层.(只要是B树都满足这个条件)
>
> 2 ) 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.
>
> 3 ) 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点
>
> 4 ) 当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层，拆后仍然需要满足上面 3 个条件。
>
> 5 ) 对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则

##### 其它说明

> 除了 23 树，还有 234 树等，概念和 23 树类似，也是一种B树。 如图:
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220724155343928.png" alt="image-20220724155343928" style="zoom:50%;" />

#### B+树

##### B+树的介绍

> B+树是B树的变体，也是一种多路搜索树。
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220724161050876.png" alt="image-20220724161050876" style="zoom:50%;" />
>
> 对上图的说明:
>
> 1 ) B+树的搜索与B树也基本相同，区别是B+树只有达到叶子节点才命中（B树可以在非叶子节点命中），其性能也等价于在关键字全集做一次二分查找
>
> 2 ) 所有关键字都出现在叶子节点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的。
>
> 3 ) 不可能在非叶子节点命中
>
> 4 ) 非叶子节点相当于是叶子节点的索引（稀疏索引），叶子节点相当于是存储（关键字）数据的数据层
>
>
> 5 ) 更适合文件索引系统
>
> 6 ) B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然.

##### B+树与B树的区别

> - 所有关键码都存放在叶节点中，上层的非叶节点的关键码是其子树中最小（或最大）关键码的复写
> - 叶节点包含了全部关键码及指向相应数据记录存放地址的指针，且叶节点本身按关键码从小到大顺序连接。如果按下层结点“最小关键码复写”原则，则树中每个非叶结点中有 m 棵子树必有 m - 1 个关键码；如果按下层结点“最大关键码复写”原则，则树中每个非叶结点中有 m 棵子树必有 m 个关键码
> - 在搜索过程中，如果查询和内部节点的关键字一致，那么搜索过程不停止，而是继续向下搜索这个分支
>
> 根据B+树的结构，我们可以发现B+树相比于B树，在文件系统，数据库系统当中，更有优势，原因如下：
>
> - B+树的磁盘读写代价更低 
>   B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说I/O读写次数也就降低了。
>
> - B+树的查询效率更加稳定 
>   由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
>
> - B+树更有利于对数据库的扫描 
>   B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题，而B+树只需要遍历叶子节点就可以解决对全部关键字信息的扫描，所以对于数据库中频繁使用的range query，B+树有着更高的性能

#### B*树

##### B*树的介绍

> B* 树是B+树的变体，在B+树的非根和非叶子节点再增加指向兄弟的指针。
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220724161535403.png" alt="image-20220724161535403" style="zoom:50%;" />
>
> B*树的说明:
>
> 1 ) B* 树定义了非叶子节点关键字个数至少为( 2 / 3 ) * M（M为树的度），即块的最低使用率为 2 / 3 ，而B+树的块的最低使用率为的1 / 2 。
>
> 2 ) 从第 1 个特点我们可以看出，B*树分配新节点的概率比B+树要低，空间使用率更高

## 图

### 基本介绍

#### 为什么要有图

> 1 ) 前面我们学了线性表和树
>
>  2 ) 线性表局限于一个直接前驱和一个直接后继的关系
>
>  3 ) 树也只能有一个直接前驱也就是父节点
>
>  4 ) 当我们需要表示多对多的关系时， 这里我们就用到了图。

#### 图的举例说明

>  图是一种数据结构，其中节点可以具有零个或多个相邻元素。两个节点之间的连接称为边。 节点也可以称为顶点。如图：
>
>  <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220724192343496.png" alt="image-20220724192343496" style="zoom:50%;" />

#### 图的常用概念

> 1 ) 顶点(vertex)
> 2 ) 边(edge)
> 3 ) 路径
> 4 ) 无向图
> 5 ) 有向图
> 6 ) 带权图
>
> ![image-20220726101313864](https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220726101313864.png)


### 图的表示方式

> 图的表示方式有两种：二维数组表示（邻接矩阵）；链表表示（邻接表）。

#### 邻接矩阵

> 邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是的row和col表示的是 1 ....n个点。
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220726101435645.png" alt="image-20220726101435645" style="zoom:50%;" />

#### 邻接表

> 1 ) 邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在,会造成空间的一定损失.
> 2 ) 邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220726101510436.png" alt="image-20220726101510436" style="zoom:40%;" />




### 图的快速入门案例

> 要求: 代码实现如下图结构.
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220726111201177.png" alt="image-20220726111201177" style="zoom:50%;" />
>
> 思路分析
> ( 1 ) 存储顶点：ArrayList<String> vertexList
> ( 2 ) 保存矩阵：int[] [] edges


#### 代码实现

```java
//插入节点
public void insertVertex(String vertex) {
  vertexList.add(vertex);
}

/**
     * 添加边
     * @param v1 表示点的下标即使第几个顶点 "A"-"B""A"-> 0 "B"-> 1
     * @param v2 第二个顶点对应的下标
     * @param weight 表示
     */
public void insertEdge(int v1, int v2, int weight) {
  edges[v1][v2] = weight;
  edges[v2][v1] = weight;
  numOfEdges++;
}
```
### 图的遍历

> 所谓图的遍历，即是对节点的访问。一个图有那么多个节点，如何遍历这些节点，需要特定策略，一般有两种访问策略：深度优先遍历、广度优先遍历
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220726111201177.png" alt="image-20220726111201177" style="zoom:50%;" />

#### 深度优先遍历(Depth First Search)

##### 基本思想

> 1 ) 深度优先遍历，从初始访问节点出发，初始访问节点可能有多个邻接节点，深度优先遍历的策略就是首先访问第一个邻接节点，然后再以这个被访问的邻接节点作为初始节点，访问它的第一个邻接节点，可以这样理解：每次都在访问完当前节点后首先访问当前节点的第一个邻接节点。
> 2 ) 我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个节点的所有邻接节点进行横向访问。
> 3 ) 显然，深度优先搜索是一个递归的过程

##### 算法步骤

> 1 ) 访问初始节点v，并标记节点v为已访问。
> 2 ) 查找节点v的第一个邻接节点w。
> 3 ) 若w存在，则继续执行 ，如果w不存在，则回到第 1 步，将从v的下一个节点继续。
> 4 ) 若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤 123 ）。
> 5 ) 查找节点v的w邻接节点的下一个邻接节点，转到步骤 3 。

#### 广度优先遍历(Broad First Search)

##### 基本思想

> 类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的节点的顺序，以便按这个顺序来访问这些节点的邻接节点

##### 算法步骤

> 1 ) 访问初始节点v并标记节点v为已访问。
> 2 ) 节点v入队列
> 3 ) 当队列非空时，继续执行，否则算法结束。
> 4 ) 出队列，取得队头节点u。
> 5 ) 查找节点u的第一个邻接节点w。
> 6 ) 若节点u的邻接节点w不存在，则转到步骤 3 ；否则循环执行以下三个步骤：
> 	1 若节点w尚未被访问，则访问节点w并标记为已访问。
> 	2 节点w入队列
> 	3 查找节点u的继w邻接节点后的下一个邻接节点w，转到步骤 6 。

### 图的代码汇总

```java
import java.util.*;

public class _27_图 {
    private ArrayList<String> vertexList;//存储顶点集合
    private int[][] edges;               //存储图对应的邻结矩阵
    private int numOfEdges;              //表示边的数目
    private boolean[] isVisited;         //定义给数组boolean[],记录某个节点是否被访问

    public _27_图() {}
    public _27_图(int n) {
        vertexList = new ArrayList<>(n);
        edges = new int[n][n];
        numOfEdges = 0;
    }

    public static void main(String[] args) {
        String vertexs[] = {" 1 ", " 2 ", " 3 ", " 4 ", " 5 ", " 6 ", " 7 ", " 8 "};

        // 创建图对象
        _27_图 graph = new _27_图(vertexs.length);
        // 添加顶点
        for (String vertex : vertexs) {
            graph.insertVertex(vertex);
        }
        // 添加边
        graph.insertEdge(0, 1, 1);
        graph.insertEdge(0, 2, 1);
        graph.insertEdge(1, 3, 1);
        graph.insertEdge(1, 4, 1);
        graph.insertEdge(3, 7, 1);
        graph.insertEdge(4, 7, 1);
        graph.insertEdge(2, 5, 1);
        graph.insertEdge(2, 6, 1);
        graph.insertEdge(5, 6, 1);

        // 显示邻结矩阵
        graph.showGraph();

        System.out.print("深度优先遍历：");
        graph.search("dfs");// 1 -> 2 -> 4 -> 8 -> 5 -> 3 -> 6 -> 7
        System.out.println();

        System.out.print("广度优先遍历：");
        graph.search("bfs");// 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8
        System.out.println();
    }

    //显示图对应的矩阵
    public void showGraph() {
        for (int[] link : edges) {
            System.err.println(Arrays.toString(link));
        }
    }

    //得到边的数目
    public int getNumOfEdges() {
        return numOfEdges;
    }

    //返回v1 和v2的权值
    public int getWeight(int v1, int v2) {
        return edges[v1][v2];
    }

    //插入节点
    public void insertVertex(String vertex) {
        vertexList.add(vertex);
    }

    /**
     * 添加边
     * @param v1 表示点的下标即使第几个顶点 "A"-"B""A"-> 0 "B"-> 1
     * @param v2 第二个顶点对应的下标
     * @param weight 表示
     */
    public void insertEdge(int v1, int v2, int weight) {
        edges[v1][v2] = weight;
        edges[v2][v1] = weight;
        numOfEdges++;
    }

    /**
     * 得到第一个邻接节点下标
     * @param index
     * @return 如果存在就返回对应的下标，否则返回- 1
     */
    public int getFirstNeighbor(int index) {
        for (int j = 0; j < vertexList.size(); j++) {
            if (edges[index][j] > 0) {
                return j;
            }
        }
        return -1;
    }

    /**
     * 获取下一个邻接节点下标
     * @param v1
     * @param v2
     * @return
     */
    public int getNextNeighbor(int v1, int v2) {
        for (int j = v2 + 1; j < vertexList.size(); j++) {
            if (edges[v1][j] > 0) {
                return j;
            }
        }
        return -1;
    }

    public void search(String searchType) {
        int size = vertexList.size();
        isVisited = new boolean[size];
        for (int i = 0; i < size; i++) {
            // 如果没有被访问过
            if (!isVisited[i]) {
                if("dfs".equals(searchType)) {
                    dfs(isVisited, i);
                }else if("bfs".equals(searchType)){
                    bfs(isVisited, i);
                }
            }
        }
    }

    /**
     * 深度优先遍历
     * @param isVisited
     * @param i
     */
    private void dfs(boolean[] isVisited, int i) {
        //首先我们访问该节点,输出
        System.out.print(vertexList.get(i) + "->");
        //将节点设置为已经访问
        isVisited[i] = true;
        //查找节点i的第一个邻接节点w
        int w = getFirstNeighbor(i);
        while (w != -1) {//说明有
            if (!isVisited[w]) {
                dfs(isVisited, w);
            }
            //如果w节点已经被访问过，获取w节点后的下一个i的邻接节点
            w = getNextNeighbor(i, w);
        }
    }

    /**
     * 广度优先遍历
     * @param isVisited
     * @param i
     */
    private void bfs(boolean[] isVisited, int i) {
        int u;// 表示队列的头节点对应下标
        int w;// 邻接节点w
        // 队列，记录节点访问的顺序
        LinkedList queue = new LinkedList();
        //访问节点，输出节点信息
        System.out.print(vertexList.get(i) + "=>");
        //标记为已访问
        isVisited[i] = true;
        //将节点加入队列
        queue.addLast(i);
        while (!queue.isEmpty()) {
            //取出队列的头节点下标
            u = (Integer) queue.removeFirst();
            //得到第一个邻接节点的下标 w
            w = getFirstNeighbor(u);
            while (w != -1) {//找到
                // 是否访问过
                if (!isVisited[w]) {
                    System.out.print(vertexList.get(w) + "=>");
                    //标记已经访问
                    isVisited[w] = true;
                    //入队
                    queue.addLast(w);
                }
                //以u为前驱点，找w后面的下一个邻节点
                w = getNextNeighbor(u, w);//体现出我们的广度优先
            }
        }
    }
}
```

## 常用 10 种算法

### 二分查找算法(非递归)

> 数组 { 1 , 3 , 8 , 10 , 11 , 67 , 100 }, 编程实现二分查找， 要求使用非递归的方式完成.

#### 代码实现

```java
/**
     * 二分查找的非递归实现
     * @retur n 返回对应下标，- 1 表示没有找到
     * @param arr 待查找的数组, arr是升序排序
     * @param target 需要查找的数
     */
    public static int binarySearch(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        while (left <= right) {//说明继续查找
            int mid = (left + right) / 2;
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] > target) {
                right = mid - 1;//需要向左边查找
            } else {
                left = mid + 1;//需要向右边查找
            }
        }
        return -1;
    }
```

### 分治算法

#### 分治算法介绍

> 1 ) 分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)
>
> 2 ) 分治算法可以求解的一些经典问题
>
> - 二分搜索
> - 大整数乘法
> - 棋盘覆盖
> - 合并排序
> - 快速排序
> - 线性时间选择
> - 最接近点对问题
> - 循环赛日程表
> - 汉诺塔

#### 分治算法的基本步骤
> 1 ) 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题
> 2 ) 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题
> 3 ) 合并：将各个子问题的解合并为原问题的解。

#### 汉诺塔

##### 汉诺塔的传说

> 汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着 64 片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。
>
> 假如每秒钟一次，共需多长时间呢？移完这些金片需要 5845. 54 亿年以上，太阳系的预期寿命据说也就是数百亿年。真的过了 5845. 54 亿年，地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。

##### 思路分析

> 1 ) 有ABC三个柱子，要把n个盘子A->C移动，如果n>= 2 ，我们总是可以看做是两个盘：最下边的盘、上面的盘
> 2 ) 先把 最上面的盘A->B
> 3 ) 把最下边的盘A->C
> 4 ) 把B塔的所有盘 从 B->C


##### 代码实现:

```java
public class _14_分治算法_汉诺塔 {
  public static void main(String[] args) {
    hanoiTower(5, 'A', 'B', 'C');
  }

  /**
     * 汉诺塔的移动的方法：从柱子：A -> C
     */
  public static void hanoiTower(int num, char a, char b, char c) {
    //如果只有一个盘
    if (num == 1) {
      System.out.println("第 1 个盘从 " + a + "->" + c);
    } else {
      //如果我们有 n>= 2 情况，我们总是可以看做是两个盘 1 .最下边的一个盘 2. 上面的所有盘
      // 1. 先把 最上面的所有盘A->B， 移动过程会使用到 c
      hanoiTower(num - 1, a, c, b);
      // 2. 把最下边的盘A->C
      System.out.println("第 " + num + " 个盘从 " + a + "->" + c);
      // 3. 把B塔的所有盘 从 B->C, 移动过程使用到 a塔
      hanoiTower(num - 1, b, a, c);
    }
  }
}
```
### 动态规划算法(DP)


#### 动态规划算法介绍

> 1 ) 动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法
> 2 ) 动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。
> 3 ) 与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )
> 4 ) 动态规划可以通过填表的方式来逐步推进，得到最优解.

#### 背包问题

> 背包问题：有一个背包，容量为 4 磅 ， 现有如下物品。
>
> 要求达到的目标为装入的背包的总价值最大，并且重量不超出装入的物品不能重复
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220726171805854.png" alt="image-20220726171805854" style="zoom:50%;" />


#### 思路分析和图解

> - 背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分 01 背包和完全背包(完全背包指的是：每种物品都有无限件可用)
>- 这里的问题属于 01 背包，即每个物品最多放一个。而无限背包可以转化为 01 背包
> - 利用动态规划来解决。对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，capacity为背包的容量，res[i] [j]表示在前i个物品中能够装入容量为j的背包中的最大价值。每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。
> - 我们有下面的结果：
>   ( 1 ) 填入表 第一行和第一列是 0： res[i] [0] = res[0] [j] = 0 ;
>   ( 2 ) 当准备加入商品的重量大于背包的容量，就直接使用上一个单元格的装入策略：当w[i - 1] > j 时：res[i] [j] = res[i-1] [j] 
>   ( 3 ) 当准备加入商品的重量小于等于背包的容量：当j >= w[i-1]时： res[i] [j] = max{res[i-1] [j], v[i-1] + res[i-1] [j - w[i-1]]}
>   res[i-1] [j]： 就是上一个单元格的装入的最大值
>   v[i-1]: 表示当前商品的价值
>   res[i-1] [j-w[i-1]]： 装入i-1 商品，到剩余空间 j-w[i-1] 的最大值

##### 图解的分析

<img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220727094255991.png" alt="image-20220727094255991" style="zoom:80%;" />


#### 代码实现

```java
public class _15_动态规划算法 {
    public static void main(String[] args) {
        int[] w = {1, 4, 3};                //物品的重量
        int[] v = {1500, 3000, 2000};       //物品的价值 这里val[i]就是前面讲的v[i]
        int capacity = 4;                   //背包的容量
        packageProblem(w, v, capacity);
    }

    public static void packageProblem(int[] w, int [] v, int capacity){
        int count = v.length;               //物品的个数
        int[][] res = new int[count + 1][capacity + 1];//res[i][j] 表示在前i个物品中能够装入容量为j的背包中的最大价值
        int[][] path = new int[count + 1][capacity + 1];// 最优解数组

        //初始化第一行和第一列为 0
        for (int i = 0; i < res.length; i++) {
            res[i][0] = 0;//将第一列设置为 0
        }
        for (int i = 0; i < res[0].length; i++) {
            res[0][i] = 0;//将第一行设置 0
        }

        //根据前面得到公式来动态规划处理
        for (int i = 1; i < count + 1; i++) {//不处理第一行，物品 i是从 1 开始的
            for (int j = 1; j < capacity + 1; j++) {//不处理第一列，容量 j 是从 1 开始的
                if (w[i - 1] > j) {
                    res[i][j] = res[i - 1][j];
                } else {
                    //res[i][j]=Math.max(res[i- 1 ][j], v[i-1] + res[i-1][j-w[i-1]]);
                    //为了记录商品存放到背包的情况，我们不能直接的使用上面的公式，需要使用if-else来体现公式
                    if (res[i - 1][j] < v[i - 1] + res[i - 1][j - w[i - 1]]) {
                        res[i][j] = v[i - 1] + res[i - 1][j - w[i - 1]];
                        //把当前的情况记录到path
                        path[i][j] = 1;
                    } else {
                        res[i][j] = res[i - 1][j];
                    }
                }
            }
        }

        for (int i = 0; i < res.length; i++) {
            for (int j = 0; j < res[i].length; j++) {
                System.out.print(res[i][j] + "\t");
            }
            System.out.println();
        }

        System.out.println("============================");
        //输出最后我们是放入的哪些商品
        //遍历path, 这样输出会把所有的放入情况都得到, 其实我们只需要最后的放入
        for (int i = 0; i < path.length; i++) {
            for (int j = 0; j < path[i].length; j++) {
                System.out.print(path[i][j] + "\t");
            }
            System.out.println();
        }
        
        System.out.println("============================");
        //最优解
        int i = path.length - 1;//行的最大下标
        int j = path[0].length - 1; //列的最大下标
        while (i > 0 && j > 0) {//从path的最后开始找
            if (path[i][j] == 1) {
                System.out.printf("第%d个商品放入到背包\n", i);
                j -= w[i - 1];//w[i- 1 ]
            }
            i--;
        }
    }
}
```
### KMP算法

#### 字符串匹配问题

> 1 ) 有一个字符串 str 1 ="BBC ABCDAB ABCDABCDABDE"，和一个子串 str2 ="ABCDABD"
> 2 ) 现在要判断 str1 是否含有 str2 , 如果存在，就返回第一次出现的位置, 如果没有，则返回- 1

#### 暴力匹配算法

##### 思路分析

> 如果用暴力匹配的思路，并假设现在 str1 匹配到 i 位置，子串 str2 匹配到 j 位置，则有:
>
> 1 ) 如果当前字符匹配成功（即str1[i] == str2[j]），则i++，j++，继续匹配下一个字符
> 2 ) 如果失配（即str1[i] != str2[j]），令i = i - (j- 1 )，j = 0。相当于每次匹配失败时，i 回溯，j 被置为 0 。
> 3 ) 用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间。(不可行!)
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220727105158017.png" alt="image-20220727105158017" style="zoom:25%;" />

##### 代码实现

```java
/**
     * 暴力匹配算法实现
     * @param str1 父字符串
     * @param str2 子字符串
     * @return
     */
public static int violenceMatch(String str1, String str2) {
  int i = 0;//i索引指向s1
  int j = 0;//j索引指向s2
  while (i < str1.length() && j < str2.length()) {// 保证匹配时，不越界
    if (str1.charAt(i) == str1.charAt(j)) {//匹配ok
      i++;
      j++;
    } else {
      //如果匹配不成功，则i 前移j-1个位置，重新对比，i -= (j-1)，j = 0 。
      i -= (j - 1);
      j = 0;
    }
  }

  //判断是否匹配成功
  return (j == str2.length()) ? (i - j) : -1;
}
```
#### KMP算法
> 1 ) KMP是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法
2 ) Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找个模式串P 的出现位置，这个算法由Donald .Knuth、JamesH.Morris、Vaughan.Pratt三人于 1977 年联合发表，故取这 3 人的姓氏命名此算法.
3 ) KMP方法算法就利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间
4 ) 参考资料：https://www.cnblogs.com/zzuuoo666/p/9028287.html

##### 思路分析

> 1. 首先，用 str1 的第一个字符和 str2 的第一个字符去比较，不符合，关键词向后移动一位
>
>    <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220727151509130.png" alt="image-20220727151509130" style="zoom:40%;" />
>
> 2. 重复第一步，还是不符合，再后移
>
>    <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220727151546027.png" alt="image-20220727151546027" style="zoom:40%;" />
>
> 3. 一直重复，直到 str1 有一个字符与 str2 的第一个字符符合为止
>
>    <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220727151625475.png" alt="image-20220727151625475" style="zoom:40%;" />
>
>
> 4. 接着比较字符串和搜索词的下一个字符，还是符合。
>
>    <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220727151707691.png" alt="image-20220727151707691" style="zoom:40%;" />
>
> 5. 遇到 str1 有一个字符与 str2 对应的字符不符合。
>
>    <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220727151802069.png" alt="image-20220727151802069" style="zoom:40%;" />
>
> 6. 这时候，想到的是继续遍历str1的下一个字符，重复第 1 步。(其实是很不明智的，因为此时BCD已经比较过了，没有必要再做重复的工作，一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。)
>
>    <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220727151935802.png" alt="image-20220727151935802" style="zoom:40%;" />
>
> 7. 怎么做到把刚刚重复的步骤省略掉？可以对 str2 计算出一张《部分匹配表》，这张表的产生在后面介绍
>
>    <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220727152000401.png" alt="image-20220727152000401" style="zoom:40%;" />
>
> 8. 已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B对应的”部分匹配值”为 2 ，因此按照下面的公式算出向后移动的位数：**移动位数 = 已匹配的字符数 - 对应的部分匹配值**，因为 6 - 2 等于 4 ，所以将搜索词向后移动 4 位。
>
>    <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220727152125083.png" alt="image-20220727152125083" style="zoom:40%;" />
>
> 9. 因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为 2 （”AB”），对应的”部分匹配值”为^0 。所以，移动位数 = 2 - 0 ，结果为 2 ，于是将搜索词向后移 2 位。
>
>    <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220727152412962.png" alt="image-20220727152412962" style="zoom:40%;" />
>
> 10. 因为空格与A不匹配，继续后移一位。
>
>     <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220727152446975.png" alt="image-20220727152446975" style="zoom:40%;" />
>
> 11. 逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动 4 位。
>
>     <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220727152543620.png" alt="image-20220727152543620" style="zoom:40%;" />
>
> 12. 逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0 ，再将搜索词向后移动 7 位，这里就不再重复了。
>
> 13. **重点：《部分匹配表》产生**
>
>     - 先介绍前缀，后缀，“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。
>
>     <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220727152828711.png" alt="image-20220727152828711" style="zoom:40%;" />
>
>     ```java
>     以”ABCDABD”为例
>     ”A”的前缀和后缀都为空集，共有元素的长度为 0 ；
>     ”AB”的前缀为[A]，后缀为[B]，共有元素的长度为 0 ；
>     ”ABC”的前缀为[A,AB]，后缀为[BC,C]，共有元素的长度 0 ；
>     ”ABCD”的前缀为[A,AB,ABC]，后缀为[BCD,CD,D]，共有元素的长度为 0 ；
>     ”ABCDA”的前缀为[A,AB,ABC,ABCD]，后缀为[BCDA,CDA,DA,A]，共有元素为”A”，长度为^1 ；
>     ”ABCDAB”的前缀为[A,AB,ABC,ABCD,ABCDA]，后缀为[BCDAB,CDAB,DAB,AB,B]，共有元素为”AB”，长度为 2 ；
>     ”ABCDABD”的前缀为[A,AB,ABC,ABCD,ABCDA,ABCDAB]，后缀为[BCDABD,CDABD,DABD,ABD,BD,D]，共有元素的长度为 0 。
>     ```

##### 代码实现
```java
import java.util.*;

public class _16_KMP算法 {
    public static void main(String[] args) {
        //测试暴力匹配算法
        String str1 = "BBC ABCDAB ABCDABCDABDE";
//        String str2 = "acaacac";
//        String str2 = "AAABAAAA";
        String str2 = "ABCDABD";
        System.out.println(str1.indexOf(str2));
        int index = violenceMatch(str1, str2);
        System.out.println("index = " + index);

        int[] next = kmpNext(str2);// [0, 0, 0, 0, 1, 2, 0]
        System.out.println("next = " + Arrays.toString(next));

        index = kmpSearch(str1, str2, next);
        System.out.println("index = " + index);
    }

    /**
     * 获取到一个字符串(子串)的部分匹配值：ABCDABD -> [0, 0, 0, 0, 1, 2, 0]
     */
    public static int[] kmpNext(String dest) {
        int[] next = new int[dest.length()];
        int j = 0;// j：匹配字符个数；前缀末尾
        for (int i = 1; i < dest.length(); i++) {// i：后缀末尾
            // 如果前几个字符匹配（j>0），第i个字符不匹配，就将第（前一个字符的匹配个数-1）位置的字符 的匹配个数来重置j
            // 上述目的：将j置为0；或者如果出现AABAAA这种情况，相当于把第2个A的匹配个数赋给了最后一个A
            // 如 acaacac -> [0, 0, 1, 1, 2, 3, 2]：求最后一个c的next值，
            // acaacac
            // acac
            // 此时j为3，意味着c之前已经有3个匹配字符，即 acaacac 前3个字符与 子串 acac 的前3个字符相等
            // 如果第3个字符a的next值为0，说明前3个字符不存在更小的对称子串，要重新开始匹配；next值=0
            // 如果第3个字符a的next值不为0，如例为1，说明 aca 字符串还存在长度为1的对称子串 a，
            // 用c和第1个后面的字符串匹配，相当于把后缀切小了，由acac变成了ac，如果匹配上，就++，即j=1+1=2；匹配不上继续上一步操作直至next值=0
            while (j > 0 && dest.charAt(j) != dest.charAt(i)) {
                j = next[j - 1];
            }
            // 如果匹配，就将个数+1
            if (dest.charAt(j) == dest.charAt(i)) {
                next[i] = ++j;
            }
        }
        return next;
    }

    /**
     * kmp搜索算法
     * @return 如果是 -1 就是没有匹配到，否则返回第一个匹配的位置
     * @param str1 源字符串
     * @param str2 子串
     * @param next 部分匹配表, 是子串对应的部分匹配表
     */
    public static int kmpSearch(String str1, String str2, int[] next) {
        int j = 0;
        //遍历
        for (int i = 0; i < str1.length(); i++) {
            //需要处理 str1 .charAt(i) ！=str2 .charAt(j), 去调整j的大小
            while (j > 0 && str1.charAt(i) != str2.charAt(j)) {
                j = next[j - 1];
            }
            if (str1.charAt(i) == str2.charAt(j)) {
                j++;
            }
            if (j == str2.length()) {
                return i - j + 1;
            }
        }
        return -1;
    }
}
```
### 贪心算法

#### 贪心算法介绍

> 1 ) 贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优 ( 即最有利 ) 的选择，从而希望能够导致结果是最好或者最优的算法
> 2 ) 贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果

#### 集合覆盖问题

> 假设存在下面需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有的地区都可以接收到信号
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220727191354989.png" alt="image-20220727191354989" style="zoom:50%;" />

##### 思路分析

> - 穷举法实现,列出每个可能的广播台的集合，这被称为幂集。假设总的有n个广播台，则广播台的组合总共有2 ⁿ - 1 个,假设每秒可以计算 10 个子集， 如图:
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220727191654433.png" alt="image-20220727191654433" style="zoom:50%;" />
>
> - 使用贪婪算法，效率高:
>   1 ) 目前并没有算法可以快速计算得到准备的值， 使用贪婪算法，则可以得到非常接近的解，并且效率高。选择策略上，因为需要覆盖全部地区的最小集合:
>   2 ) 遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区，但没有关系）
>   3 ) 将这个电台加入到一个集合中(比如ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。
>   4 ) 重复第 1 步直到覆盖了全部的地区
>   分析的图解:
>
>   <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220727191720862.png" alt="image-20220727191720862" style="zoom:70%;" />

##### 代码实现

```java
import java.util.*;

public class _17_贪心算法 {
    public static void main(String[] args) {
        // 存放广播电台
        HashMap<String, HashSet<String>> broadcasts = new HashMap<String, HashSet<String>>();
        // 存放所有的地区
        HashSet<String> allAreas = new HashSet<>();

        // 准备数据
        prepareData(allAreas, broadcasts);

        // 贪心算法
        List<String> res = greedyAlgorithm(allAreas, broadcasts);
        System.out.println("得到的选择结果是" + res);//[K 1 ,K 2 ,K 3 ,K 5 ]
    }

    public static void prepareData(HashSet<String> allAreas, HashMap<String, HashSet<String>> broadcasts){
        //将各个电台放入到broadcasts
        HashSet<String> hashSet1 = new HashSet<>();
        hashSet1.add("北京");
        hashSet1.add("上海");
        hashSet1.add("天津");

        HashSet<String> hashSet2 = new HashSet<>();
        hashSet2.add("广州");
        hashSet2.add("北京");
        hashSet2.add("深圳");

        HashSet<String> hashSet3 = new HashSet<>();
        hashSet3.add("成都");
        hashSet3.add("上海");
        hashSet3.add("杭州");

        HashSet<String> hashSet4 = new HashSet<>();
        hashSet4.add("上海");
        hashSet4.add("天津");

        HashSet<String> hashSet5 = new HashSet<>();
        hashSet5.add("杭州");
        hashSet5.add("大连");
        //加入到map
        broadcasts.put("K1", hashSet1);
        broadcasts.put("K2", hashSet2);
        broadcasts.put("K3", hashSet3);
        broadcasts.put("K4", hashSet4);
        broadcasts.put("K5", hashSet5);

        allAreas.add("北京");
        allAreas.add("上海");
        allAreas.add("广州");
        allAreas.add("深圳");
        allAreas.add("杭州");
        allAreas.add("成都");
        allAreas.add("天津");
        allAreas.add("大连");
    }

    /**
     * 贪心算法
     * @param allAreas
     * @param broadcasts
     */
    public static List<String> greedyAlgorithm(HashSet<String> allAreas, HashMap<String, HashSet<String>> broadcasts){
        // 存放选择的电台集合
        ArrayList<String> res = new ArrayList<>();
        // 拥有未覆盖的地区数量最多的电台
        String maxBroadcast;
        
        while (allAreas.size() != 0) {// 如果allAreas 不为 0 , 则表示还没有覆盖到所有的地区
            // maxBroadcast为设置第一个电台
            maxBroadcast = broadcasts.keySet().iterator().next();
            for (String broadcast : broadcasts.keySet()) {
                // 当前这个broadcast能够覆盖的地区，注意要new HashSet<>，而不是直接get，否则会改变原来的broadcasts
                HashSet<String> areas = new HashSet<>(broadcasts.get(broadcast));
                // maxBroadcast能够覆盖的地区
                HashSet<String> maxAreas = new HashSet<>(broadcasts.get(maxBroadcast));
                // 求出 areas 和 allAreas 集合的交集, 表示areas中存在未覆盖的数量
                areas.retainAll(allAreas);
                // 表示maxAreas中存在未覆盖的数量
                maxAreas.retainAll(allAreas);
                // 当该电台的未覆盖数量比maxBroadcast的未覆盖还多，重置maxBroadcast，体现出贪心算法特点,每次都最优
                if (areas.size() > 0 && areas.size() > maxAreas.size()) {
                    maxBroadcast = broadcast;
                }
            }
            res.add(maxBroadcast);
            allAreas.removeAll(broadcasts.get(maxBroadcast));
        }
        return res;
    }
}
```

#### 贪心算法注意事项和细节

> 1 ) 贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果
> 2 ) 比如上题的算法选出的是K 1 ,K 2 ,K 3 ,K 5 ，符合覆盖了全部的地区
> 3 ) 但是我们发现 K 2 ,K 3 ,K 4 ,K 5 也可以覆盖全部地区，如果K 2 的使用成本低于K 1 ,那么我们上题的 K 1 ,K 2 ,K 3 ,K 5 虽然是满足条件，但是并不是最优的.


### 普里姆算法(Prim)

#### 最小生成树

> 最小生成树 **(Minimum Cost Spanning Tree)** ，简称 **MST** 。给定一个带权的无向连通图，如何选取一棵生成树，使树上所有边上权的总和为最小，这叫最小生成树
> 1 ) N 个顶点，一定有 N - 1 条边
> 2 ) 包含全部顶点
> 3 ) N- 1 条边都在图中
> 4 ) 举例说明 (如图:)
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220728174959628.png" alt="image-20220728174959628" style="zoom:50%;" />
>
> 5 ) 求最小生成树的算法主要是普里姆算法和克鲁斯卡尔算法

#### 普里姆算法介绍

> 普利姆(Prim)算法求最小生成树，也就是在包含n个顶点的连通图中，找出只有(n-1)条边包含所有n个顶点的连通子图，也就是所谓的极小连通子图
>
> 图解普利姆算法
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220728175202955.png" alt="image-20220728175202955" style="zoom:50%;" />

#### 修路问题

> 1 ) 有胜利乡有 7 个村庄 (A,B,C,D,E,F,G) ，现在需要修路把 7 个村庄连通
> 2 ) 各个村庄的距离用边线表示 ( 权 ) ，比如 A – B 距离 5 公里
> 3 ) 问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短?
>
> 思路 : 尽可能的选择少的路线，并且每条路线最小，保证总里程数最少.
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220728092205373.png" alt="image-20220728092205373" style="zoom:50%;" />
##### 代码实现

```java
import java.util.*;

public class _18_普里姆算法 {
    public static void main(String[] args) {
        char[] nodes = new char[]{'A', 'B', 'C', 'D', 'E', 'F', 'G'};// 节点
        int verxs = nodes.length;// 节点数量
        // 邻接矩阵的关系使用二维数组表示, 10000 这个大数，表示两个点不联通
        int[][] weight = new int[][]{
                {10000, 5, 7, 10000, 10000, 10000, 2},
                {5, 10000, 10000, 9, 10000, 10000, 3},
                {7, 10000, 10000, 10000, 8, 10000, 10000},
                {10000, 9, 10000, 10000, 10000, 4, 10000},
                {10000, 10000, 8, 10000, 10000, 5, 4},
                {10000, 10000, 10000, 4, 5, 10000, 6},
                {2, 3, 10000, 10000, 4, 6, 10000},};
        // 创建MGraph
        MGraph graph = new MGraph(verxs, nodes, weight);
        // 输出邻接矩阵
        showGraph(graph);
        // 普里姆算法
        prim(graph, 0);// 从节点A开始遍历
    }

    // 显示图的邻接矩阵
    public static void showGraph(MGraph graph) {
        for (int[] link : graph.weight) {
            System.out.println(Arrays.toString(link));
        }
    }

    /**
     * prim算法，得到最小生成树
     * @param graph 图
     * @param node 表示从图的第几个顶点开始生成'A'-> 0 'B'-> 1 ...
     */
    public static void prim(MGraph graph, int node) {
        // visited[] 标记节点(顶点)是否被访问过：默认元素的值都是 0 , 表示没有访问过
        int visited[] = new int[graph.verxs];
        // 把当前这个节点标记为已访问
        visited[node] = 1;
        // node1  和 node2  记录两个顶点的下标
        int node1 = -1;
        int node2 = -1;
        int minWeight = 10000;// 将 minWeight 初始成一个大数，后面在遍历过程中，会被替换
        for (int k = 1; k < graph.verxs; k++) {// 因为有 graph.verxs顶点，有 graph.verxs - 1 边，遍历次数
            // 这个是确定每一次生成的子图 ，和哪个节点的距离最近
            for (int i = 0; i < graph.verxs; i++) {// i节点表示被访问过的节点
                for (int j = 0; j < graph.verxs; j++) {// j节点表示还没有访问过的节点
                    if (visited[i] == 1 && visited[j] == 0 && graph.weight[i][j] < minWeight) {
                        // 替换minWeight(寻找已经访问过的节点和未访问过的节点间的权值最小的边)
                        minWeight = graph.weight[i][j];
                        node1 = i;
                        node2 = j;
                    }
                }
            }
            // 找到一条边是最小
            System.out.println("边<" + graph.nodes[node1] + "," + graph.nodes[node2] + "> 权值:" + minWeight);
            // 将当前这个节点标记为已经访问
            visited[node2] = 1;
            // minWeight 重新设置为最大值 10000
            minWeight = 10000;
        }
    }
}

class MGraph {
    int verxs;// 图的节点个数
    char[] nodes;// 节点
    int[][] weight;// 边，就是我们的邻接矩阵

    public MGraph(int verxs, char[] nodes, int[][] weight) {
        this.verxs = verxs;
        this.nodes = nodes;
        this.weight = weight;
    }
}
```
### 克鲁斯卡尔算法(Kruskal)

#### 算法介绍

> 1 ) 克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。
> 2 ) 基本思想：按照权值从小到大的顺序选择n- 1 条边，并保证这 n - 1 条边不构成回路
> 3 ) 具体做法：首先构造一个只含n个顶点的森林，然后依权值`从小到大`从连通网中选择边加入到森林中，并使森林中`不产生回路`，直至森林变成一棵树为止

#### 图解说明

> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220729202642975.png" alt="image-20220729202642975" style="zoom:50%;" />
>
> 以上图为例，来对克鲁斯卡尔进行演示(假设，用数组R保存最小生成树结果)。
>
> ![image-20220729202857564](https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220729202857564.png)
>
>  第 1 步：将边<E,F>加入R中。边<E,F>的权值最小，因此将它加入到最小生成树结果R中。
>
>  第 2 步：将边<C,D>加入R中。上一步操作之后，边<C,D>的权值最小，因此将它加入到最小生成树结果R中。
>
>  第 3 步：将边<D,E>加入R中。上一步操作之后，边<D,E>的权值最小，因此将它加入到最小生成树结果R中。
>
>  第 4 步：将边<B,F>加入R中。上一步操作之后，边<C,E>的权值最小，但<C,E>会和已有的边构成回路；因此，跳过边<C,E>。同理，跳过边<C,F>。将边<B,F>加入到最小生成树结果R中。
>
>  第 5 步：将边<E,G>加入R中。上一步操作之后，边<E,G>的权值最小，因此将它加入到最小生成树结果R中。
>
>  第 6 步：将边<A,B>加入R中。上一步操作之后，边<F,G>的权值最小，但<F,G>会和已有的边构成回路；因此，跳过边<F,G>。同理，跳过边<B,C>。将边<A,B>加入到最小生成树结果R中。
>
>  此时，最小生成树构造完成！它包括的边依次是：` <E,F><C,D><D,E><B,F><E,G><A,B> `。 

##### 如何判断是否构成回路

> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220729203330845.png" alt="image-20220729203330845" style="zoom:50%;" />
>
>  在将<E,F><C,D><D,E>加入到最小生成树R中之后，这几条边的顶点就都有了终点：
>  ( 01 ) C的终点是F。
>  ( 02 ) D的终点是F。
>  ( 03 ) E的终点是F。
>  ( 04 ) F的终点是F。
>
>  关于终点的说明：
>  1 )就是将所有顶点按照从小到大的顺序排列好之后；`某个顶点的终点就是与它连通的最大顶点`。
>  2 )因此，接下来，虽然<C,E>是权值最小的边。但是C和E的终点都是F，即它们的终点相同，因此，将<C,E>加入最小生成树的话，会形成回路。这就是判断回路的方式。也就是说，`我们加入的边的两个顶点不能都指向同一个终点，否则将构成回路`。

#### 公交站问题

> 1 ) 某城市新增 7 个站点(A,B,C,D,E,F,G) ，现在需要修路把 7 个站点连通
> 2 ) 各个站点的距离用边线表示(权) ，比如A– B 距离 12 公里
> 3 ) 问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短?
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220729202432835.png" alt="image-20220729202432835" style="zoom:50%;" />

##### 代码实现

```java
import java.util.Arrays;
import java.util.Collections;
import java.util.stream.Collectors;

public class _19_克鲁斯卡尔算法 {
    private char[] vertexs;// 顶点数组
    private int[][] matrix;// 邻接矩阵
    private int edgeNum;// 边的个数
    // 使用 INF 表示两个顶点不能连通
    private static final int INF = Integer.MAX_VALUE;

    public _19_克鲁斯卡尔算法(char[] vertexs, int[][] matrix) {
        this.vertexs = vertexs;
        this.matrix = matrix;

        // 初始化顶点数和边的个数
        int length = vertexs.length;
        // 统计边的条数
        for (int i = 0; i < length; i++) {
            for (int j = i + 1; j < length; j++) {
                if (this.matrix[i][j] != INF) {
                    edgeNum++;
                }
            }
        }
    }

    public static void main(String[] args) {
        char[] vertexs = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
        // 克鲁斯卡尔算法的邻接矩阵
        int matrix[][] = {{0, 12, INF, INF, INF, 16, 14},
                          {12, 0, 10, INF, INF, 7, INF},
                          {INF, 10, 0, 3, 5, 6, INF},
                          {INF, INF, 3, 0, 4, INF, INF},
                          {INF, INF, 5, 4, 0, 2, 8},
                          {16, 7, 6, INF, 2, 0, 9},
                          {14, INF, INF, INF, 8, 9, 0}};

        // 创建_19_克鲁斯卡尔算法  对象实例
        _19_克鲁斯卡尔算法 kruskalCase = new _19_克鲁斯卡尔算法(vertexs, matrix);
        // 输出构建的
//        _18_普里姆算法.showMatrix(matrix);
        kruskalCase.kruskal();
    }

    public void kruskal() {
        // 结果数组, 保存最后的最小生成树
        EData[] res = new EData[edgeNum];
        // 图中所有的边的集合
        EData[] allEdges = getEdges();
        System.out.println("图的边的集合 = " + Arrays.toString(allEdges) + " 共 " + allEdges.length);// 12

        int[] ends = new int[edgeNum];// 用于保存"已有最小生成树" 中的每个顶点在最小生成树中的终点

        // 按照边的权值大小进行排序(从小到大)
        Collections.sort(Arrays.asList(allEdges), (o1, o2) -> o1.weight - o2.weight);

        // 遍历edges 数组，将边添加到最小生成树中时，判断是准备加入的边否形成了回路，如果没有，就加入 res,否则不能加入
        for (int i = 0; i < edgeNum; i++) {
            // 第i条边的第 1 个顶点下标
            int p1 = getPosition(allEdges[i].start);// p1 = 4
            // 第i条边的第 2 个顶点下标
            int p2 = getPosition(allEdges[i].end);// p2 = 5
            // 获取 p1 顶点在已有最小生成树中的终点
            int e1 = getEnd(ends, p1);// m= 4
            // 获取 p2 顶点在已有最小生成树中的终点
            int e2 = getEnd(ends, p2);// n= 5
            // 没有构成回路
            if (e1 != e2) {
                ends[e1] = e2;// 设置 e1 在"已有最小生成树"中的终点为 e2 // <E,F>[ 0 , 0 , 0 , 0 , 5 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]
                res[i] = allEdges[i];// 有一条边加入到res数组
            }
        }
        // 统计并打印 "最小生成树", 输出 res：<E,F><C,D><D,E><B,F><E,G><A,B>
        System.out.println("最小生成树为：");
        for (int i = 0; i < res.length; i++) {
            if(res[i] != null) System.out.println(res[i]);
        }
    }

    /**
     * 通过matrix 邻接矩阵来获取图中所有边
     * EData [] 形式 [['A','B', 12 ],['B','F', 7 ],.]
     *
     * @return
     */
    private EData[] getEdges() {
        int index = 0;
        EData[] allEdges = new EData[edgeNum];
        for (int i = 0; i < vertexs.length; i++) {
            for (int j = i + 1; j < vertexs.length; j++) {
                if (matrix[i][j] != INF) {
                    allEdges[index++] = new EData(vertexs[i], vertexs[j], matrix[i][j]);
                }
            }
        }
        return allEdges;
    }

    /**
     * @return 返回顶点对应的下标，如果找不到，返回- 1
     * @paramch 顶点的值，比如'A','B'
     */
    private int getPosition(char ch) {
        for (int i = 0; i < vertexs.length; i++) {
            if (vertexs[i] == ch) {// 找到
                return i;
            }
        }
        // 找不到,返回- 1
        return -1;
    }
    
    /**
     * 获取下标为i的顶点的终点()
     *
     * @return 返回的就是 下标为i的这个顶点对应的终点的下标, 一会回头还有来理解
     * @param ends ： 数组就是记录了各个顶点对应的终点是哪个,ends 数组是在遍历过程中，逐步形成
     * @param i: 表示传入的顶点对应的下标
     */
    private int getEnd(int[] ends, int i) {// i= 4 [ 0 , 0 , 0 , 0 , 5 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]
        while (ends[i] != 0) {
            i = ends[i];
        }
        return i;
    }
}

// 创建一个类EData  ，它的对象实例就表示一条边
class EData {
    char start;// 边的一个点
    char end;// 边的另外一个点
    int weight;// 边的权值

    // 构造器
    public EData(char start, char end, int weight) {
        this.start = start;
        this.end = end;
        this.weight = weight;
    }

    // 重写toString , 便于输出边信息
    @Override
    public String toString() {
        return "<" + start + "," + end + "> = " + weight;
    }
}
```
### 迪杰斯特拉算法(Dijkstra)

#### 算法介绍

> 迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。

#### 算法过程

> 1 ) 设置出发顶点为v，顶点集合V{v1,v2 ,vi...}，v到V中各顶点的距离构成距离集合Dis，Dis{d1,d2 ,di...}，Dis集合记录着v到图中各顶点的距离(到自身可以看作 0 ，v到vi距离对应为di)
> 2 ) 从Dis中选择值最小的di并移出Dis集合，同时移出V集合中对应的顶点vi，此时的v到vi即为最短路径
> 3 ) 更新Dis集合，更新规则为：比较v到V集合中顶点的距离值，与v通过vi到V集合中顶点的距离值，保留值较小的一个(同时也应该更新顶点的前驱节点为vi，表明是通过vi到达的)
> 4 ) 重复执行两步骤，直到最短路径顶点为目标顶点即可结束

#### 最短路径问题

> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220730102249024.png" alt="image-20220730102249024" style="zoom:50%;" />
>
> 1 ) 战争时期，胜利乡有 7 个村庄(A,B,C,D,E,F,G) ，现在有六个邮差，从G点出发，需要分别把邮件分别送到A,B,C,D,E,F六个村庄
> 2 ) 各个村庄的距离用边线表示(权) ，比如A– B 距离 5 公里
> 3 ) 问：如何计算出G村庄到 其它各个村庄的最短距离?
> 4 ) 如果从其它点出发到各个点的最短距离又是多少?

##### 图解分析

![image-20220730102910415](https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220730102910415.png)


##### 代码实现
```java
package 算法;

import java.util.Arrays;

public class _20_迪杰斯特拉算法 {
    // 表示不可以连接
    static final int N = 65535;
    public static void main(String[] args) {
        // 起始节点：G，下标 6
        int beginIndex = 6;
        char[] vertex = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
        // 邻接矩阵
        int[][] matrix = {{N, 5, 7, N, N, N, 2},
                          {5, N, N, 9, N, N, 3},
                          {7, N, N, N, 8, N, N},
                          {N, 9, N, N, N, 4, N},
                          {N, N, 8, N, N, 5, 4},
                          {N, N, N, 4, 5, N, 6},
                          {2, 3, N, N, 4, 6, N}};
        // 创建 Graph 对象
        Graph graph = new Graph(vertex, matrix);
        // 测试, 看看图的邻接矩阵是否ok
        graph.showGraph();
        // 测试迪杰斯特拉算法
        graph.dijsktra(beginIndex);
        graph.showDijkstra();

        // dijkstra算法精简
        dijkstra2(vertex, matrix, beginIndex);
    }

    /**
     * dijkstra算法精简
     * @param vertex 节点数组
     * @param matrix 邻接矩阵
     * @param index 起点下标
     */
    public static void dijkstra2(char[] vertex, int[][] matrix, int index){
        // 节点数量
        int nodeCount = vertex.length;
        // 是否访问：0：否；1：是
        int[] isVisit = new int[nodeCount];
        // 距离index最短距离
        int[] des = new int[nodeCount];
        // 前驱节点下标：用来输出到每个节点的路径
        int[] pre = new int[nodeCount];

        // 初始化三个基本数组
        Arrays.fill(des, N);
        des[index] = 0;
        isVisit[index] = 1;

        // 更新G节点不经过第三个节点到其他节点的距离
        update(matrix, isVisit, des, pre, 6);
        for(int i = 0; i < nodeCount; i++){ // 单纯为了循环 nodeCount 次，未用到 i
            // 获取距离index节点最短且未被访问的节点
            int nextIndex = getNextUnVisNode(isVisit, des);
            update(matrix, isVisit, des, pre, nextIndex);
        }

        for(int i = 0; i < nodeCount; i++){
            StringBuilder path = new StringBuilder();
            int preNode = i;
            path.append(vertex[preNode] + " -> ");
            while (pre[preNode] != index && i != index) {
                preNode = pre[preNode];
                path.append(vertex[preNode] + " -> ");
            }
            path.append(vertex[index]);
            System.out.printf("%s \t\t\t %s\n", path.toString(), " 距离：" + des[i]);
        }
    }

    /**
     * 更新 经过index节点，从起点G到其他节点的距离
     * @param matrix
     * @param isVisit
     * @param des
     * @param pre
     * @param index
     */
    public static void update(int[][] matrix, int[] isVisit, int[] des, int[] pre, int index){
        int minLen;
        for(int i = 0; i < isVisit.length; i++){
            // minLen = G到index距离 + index到i的距离
            minLen = des[index] + matrix[index][i];
            // 如果G直接访问i的距离 > minLen；则更新
            if(isVisit[i] == 0 && des[i] > minLen){
                des[i] = minLen;
                pre[i] = index;
            }
        }
    }

    /**
     * 获取距离index节点最短且未被访问的节点
     * @return
     */
    public static int getNextUnVisNode(int[] isVisit, int[] des){
        int minLen = N;
        int nextIndex = 0;
        for(int i = 0; i < des.length; i++){
            if(isVisit[i] == 0 && des[i] < minLen){
                minLen = des[i];
                nextIndex = i;
            }
        }
        isVisit[nextIndex] = 1;
        return nextIndex;
    }
}

class Graph {
    // 顶点数组
    private char[] vertex;
    // 邻接矩阵
    private int[][] matrix;
    // 已经访问的顶点的集合
    private VisitedVertex vv;

    public Graph(char[] vertex, int[][] matrix) {
        this.vertex = vertex;
        this.matrix = matrix;
    }

    public void showDijkstra() {
        vv.show();
    }

    public void showGraph() {
        _18_普里姆算法.showMatrix(matrix);
    }

    /**
     * 迪杰斯特拉算法实现
     *
     * @param index 表示出发顶点对应的下标
     */
    public void dijsktra(int index) {
        vv = new VisitedVertex(vertex.length, index);
        update(index);// 更新index顶点到周围顶点的距离和前驱顶点
        for (int j = 1; j < vertex.length; j++) {
            index = vv.updateArr();// 选择距离最近的节点作为新的访问顶点
            update(index);// 更新index顶点到周围顶点的距离和前驱顶点
        }
    }

    // 更新index下标顶点到周围顶点的距离和周围顶点的前驱顶点,
    private void update(int index) {
        int len;
        // 根据遍历我们的邻接矩阵的 matrix[index]行
        for (int j = 0; j < matrix[index].length; j++) {
            // len 含义是 : 出发点到index顶点的距离 + 从index顶点到j顶点的距离的和
            len = vv.getDis(index) + matrix[index][j];
            // 如果j顶点没有被访问过，并且 len 小于出发顶点到j顶点的距离，就需要更新
            if (!vv.isVisited(j) && len < vv.getDis(j)) {
                vv.updatePre(j, index);// 更新j顶点的前驱为index顶点
                vv.updateDis(j, len);// 更新出发顶点到j顶点的距离
            }
        }
    }
}

class VisitedVertex {
    // 记录各个顶点是否访问过 1 表示访问过, 0 未访问,会动态更新
    public int[] already_arr;

    // 每个下标对应的值为前一个顶点下标, 会动态更新
    public int[] pre_visited;

    // 记录出发顶点到其他所有顶点的距离,比如G为出发顶点，就会记录G到其它顶点的距离，会动态更新，求的最短距离就会存放到dis
    public int[] dis;

    /**
     * @param length:表示顶点的个数
     * @param index:         出发顶点对应的下标, 比如G顶点，下标就是 6
     */
    public VisitedVertex(int length, int index) {
        this.already_arr = new int[length];
        this.pre_visited = new int[length];
        this.dis = new int[length];
        // 初始化 dis数组
        Arrays.fill(dis, 65535);
        this.dis[index] = 0;// 设置出发顶点的访问距离为 0
        this.already_arr[index] = 1;// 设置出发顶点被访问过
    }

    /**
     * 功能: 判断index顶点是否被访问过
     *
     * @param index
     * @return 如果访问过，就返回true, 否则访问false
     */
    public boolean isVisited(int index) {
        return already_arr[index] == 1;
    }

    /**
     * 功能: 更新出发顶点到index顶点的距离
     *
     * @param index
     * @param len
     */
    public void updateDis(int index, int len) {
        dis[index] = len;
    }

    /**
     * 功能: 更新pre这个顶点的前驱顶点为index顶点
     *
     * @param pre
     * @param index
     */
    public void updatePre(int pre, int index) {
        pre_visited[pre] = index;
    }

    /**
     * 功能:返回出发顶点到index顶点的距离
     *
     * @param index
     */
    public int getDis(int index) {
        return dis[index];
    }

    /**
     * 返回距离G最近的节点作为新的访问顶点
     *
     * @return
     */
    public int updateArr() {
        int min = 65535, index = 0;
        for (int i = 0; i < already_arr.length; i++) {
            if (already_arr[i] == 0 && dis[i] < min) {
                min = dis[i];
                index = i;
            }
        }
        // 更新 index 顶点被访问过
        already_arr[index] = 1;
        return index;
    }

    /**
     * 显示最后的结果，将三个数组的情况输出
     */
    public void show() {
        System.out.println("============already_arr==============");
        // 输出already_arr
        for (int i : already_arr) {
            System.out.printf("%10d", i);
        }
        System.out.println();
        System.out.println("===========pre_visited===============");
        // 输出pre_visited
        for (int i : pre_visited) {
            System.out.printf("%10d", i);
        }
        System.out.println();
        System.out.println("============dis==============");
        // 输出dis
        for (int i : dis) {
            System.out.printf("%10d", i);
        }

        System.out.println();
        System.out.println("==========================");
        char[] vertex = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
        int count = 0;
        for (int i : dis) {
            if (i != 65535) {
                System.out.print(vertex[count] + "(" + i + ") ");
            } else {
                System.out.println("N");
            }
            count++;
        }
        System.out.println();
    }
}
```
### 弗洛伊德算法(Floyd)

#### 算法介绍

> 1 ) 和Dijkstra算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法名称以创始人之一、1978 年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名
> 2 ) 弗洛伊德算法(Floyd)计算图中各个顶点之间的最短路径
> 3 ) 迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。
> 4 ) 弗洛伊德算法 VS 迪杰斯特拉算法：
>
> - 迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点的最短路径；
> - 弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。

#### 算法图解分析

> 1 ) 设置顶点vi到顶点vk的最短路径已知为Lik，顶点vk到vj的最短路径已知为Lkj，顶点vi到vj的路径为Lij，则vi到vj的最短路径为：min((Lik+Lkj),Lij)，vk的取值为图中所有顶点，则可获得vi到vj的最短路径
> 2 ) 至于vi到vk的最短路径Lik或者vk到vj的最短路径Lkj，是以同样的方式获得
> 3 ) 弗洛伊德(Floyd)算法图解分析-举例说明
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220801110625186.png" alt="image-20220801110625186" style="zoom:50%;" />
>
> 弗洛伊德算法的步骤：
>
> 第一轮循环中，以A（下标为0）作为中间顶点的所有情况都进行遍历，得到更新距离表和 前驱关系，距离表和前驱关系更新为：
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220801110709301.png" alt="image-20220801110709301" style="zoom:50%;" />
>
>
> 分析如下：
>
> 1 ) 以A顶点作为中间顶点是，B->A->C的距离由N-> 9 ，同理C到B；C->A->G的距离由N-> 12 ，同理G到C
> 2 ) 更换中间顶点，循环执行操作，直到所有顶点都作为中间顶点更新后，计算结束


#### 最短路径问题

> 1 ) 胜利乡有 7 个村庄(A,B,C,D,E,F,G)
>
> 2 ) 各个村庄的距离用边线表示(权) ，比如A– B 距离 5 公里
>
> 3 ) 问：如何计算出各村庄到 其它各村庄的最短距离?

##### 代码实现


```java
package 算法;

import java.util.Arrays;

public class _21_弗洛伊德算法 {
    public static void main(String[] args) {
        // 测试看看图是否创建成功
        char[] vertex = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
        final int N = 65535;
        // 创建邻接矩阵
        int[][] matrix = {{0, 5, 7, N, N, N, 2},
                          {5, 0, N, 9, N, N, 3},
                          {7, N, 0, N, 8, N, N},
                          {N, 9, N, 0, N, 4, N},
                          {N, N, 8, N, 0, 5, 4},
                          {N, N, N, 4, 5, 0, 6},
                          {2, 3, N, N, 4, 6, 0}};

        // 创建 Graph2  对象
        Graph2 graph = new Graph2(matrix, vertex);
        // 调用弗洛伊德算法
        graph.floyd();
        graph.show();
    }
}

class Graph2 {
    private char[] vertex;// 存放顶点的数组
    private int[][] dis;// 保存，从各个顶点出发到其它顶点的距离，最后的结果，也是保留在该数组
    private int[][] pre;// 保存到达目标顶点的前驱顶点

    /**
     * @param matrix 邻接矩阵
     * @param vertex 顶点数组
     */
    public Graph2(int[][] matrix, char[] vertex) {
        int length = vertex.length;
        this.vertex = vertex;
        this.dis = matrix;
        this.pre = new int[length][length];
        // 对pre数组初始化, 注意存放的是前驱顶点的下标
        for (int i = 0; i < length; i++) {
            Arrays.fill(pre[i], i);
        }
    }

    // 显示pre数组和dis数组
    public void show() {
        // 为了显示便于阅读，我们优化一下输出
        for (int k = 0; k < dis.length; k++) {
            // 先将pre数组输出的一行
            for (int i = 0; i < dis.length; i++) {
                System.out.print(vertex[pre[k][i]] + " ");
            }
            System.out.println();
            StringBuilder sb;
            // 输出路径
            for (int i = 0; i < dis.length; i++) {
                sb = new StringBuilder(String.valueOf(vertex[k]));
                int cur = k;
                while(pre[cur][i] != cur){
                    cur = pre[cur][i];
                    sb.append("->").append(vertex[cur]);
                }
                // System.out.print(vertex[k] + "->" + vertex[i] + " " + dis[k][i] + " | ");
                System.out.println(sb.append("->" + vertex[i] + " " + dis[k][i]));
            }
            System.out.println();
        }
    }

    // 弗洛伊德算法, 比较容易理解，而且容易实现
    public void floyd() {
        int minLen;// 变量保存距离
        // 对中间顶点遍历， k 就是中间顶点的下标 [A,B,C,D,E,F,G]
        for (int k = 0; k < dis.length; k++) {// 
            // 从i顶点开始出发 [A,B,C,D,E,F,G]
            for (int i = 0; i < dis.length; i++) {
                // 到达j顶点 // [A,B,C,D,E,F,G]
                for (int j = 0; j < dis.length; j++) {
                    minLen = dis[i][k] + dis[k][j];// => 求出从i 顶点出发，经过 k中间顶点，到达 j 顶点距离
                    if (minLen < dis[i][j]) {// 如果len小于 dis[i][j]
                        dis[i][j] = minLen;// 更新 i 到 j 距离
                        pre[i][j] = k;// 更新 i 到 j 前驱顶点
                    }
                }
            }
        }
    }
}
```

### 回溯算法

#### 马踏棋盘问题(骑士周游问题)

> 1 ) 马踏棋盘算法也被称为骑士周游问题
> 2 ) 将马随机放在国际象棋的 8 × 8 棋盘Board[0～7] [0～7]的某个方格中，马按走棋规则(马走日字)进行移动。要求每个方格只进入一次，走遍棋盘上全部 64 个方格
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220801135654982.png" alt="image-20220801135654982" style="zoom:50%;" />

#### 思路分析

> 1 ) 马踏棋盘问题(骑士周游问题)实际上是图的深度优先搜索(DFS)的应用。
> 2 ) 如果使用回溯（就是深度优先搜索）来解决，假如马儿踏了 53 个点，如图：走到了第 53 个，坐标（ 1 , 0 ），发现已经走到尽头，没办法，那就只能回退了，查看其他的路径，就在棋盘上不停的回溯。
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220801135915810.png" alt="image-20220801135915810" style="zoom:50%;" />
>
> 3 ) 分析第一种方式的问题，并使用贪心算法（greedyalgorithm）进行优化。解决马踏棋盘问题.
>
> <img src="https://raw.githubusercontent.com/pitything/images/main/https://cdn.jsdelivr.net/gh/pitything/images@master/image-20220801140717945.png" alt="image-20220801140717945" style="zoom:50%;" />

#### 代码实现
```java
package 算法;

import java.awt.*;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

public class _22_马踏棋盘算法 {
    private static int X;// 棋盘的列数
    private static int Y;// 棋盘的行数
    // 创建一个数组，标记棋盘的各个位置是否被访问过
    private static boolean visited[];
    // 使用一个属性，标记是否棋盘的所有位置都被访问
    private static boolean finished;

    public static void main(String[] args) {
        X = 8;
        Y = 8;
        int row = 1;// 马儿初始位置的行，从 1 开始编号
        int column = 1;// 马儿初始位置的列，从 1 开始编号
        // 创建棋盘
        int[][] chessboard = new int[X][Y];
        visited = new boolean[X * Y];// 初始值都是false

        traversalChessboard(chessboard, row - 1, column - 1, 1);
        // 输出棋盘的最后情况
        _18_普里姆算法.showMatrix(chessboard);
    }

    /**
     * 完成骑士周游问题的算法
     *
     * @param chessboard 棋盘
     * @param row 马儿当前的位置的行 从 0 开始
     * @param column 马儿当前的位置的列 从 0 开始
     * @param step 是第几步 ,初始位置就是第 1 步
     */
    public static void traversalChessboard(int[][] chessboard, int row, int column, int step) {
        chessboard[row][column] = step;
        // row= 4 X= 8 column= 4 = 4 * 8 + 4 = 36
        visited[row * X + column] = true;// 标记该位置已经访问
        // 获取当前位置可以走的下一个位置的集合
        ArrayList<Point> ps = next(new Point(column, row));
        // 对ps进行排序,排序的规则就是对ps的所有的Point 对象的下一步的位置的数目，进行非递减排序
        ps.sort(Comparator.comparingInt(o -> next(o).size()));
        // 遍历 ps
        while (!ps.isEmpty()) {
            Point p = ps.remove(0);// 取出下一个可以走的位置
            // 如果还没有访问过
            if (!visited[p.y * X + p.x]) {
                traversalChessboard(chessboard, p.y, p.x, step + 1);
            }
        }
        // 判断马儿是否完成了任务，使用 step 和应该走的步数比较 ，
        // 如果没有达到数量，则表示没有完成任务，将整个棋盘置 0
        // 说明:step<X*Y 成立的情况有两种
        // 1. 棋盘到目前位置,仍然没有走完
        // 2. 棋盘处于一个回溯过程
        if (step < X * Y && !finished) {
            chessboard[row][column] = 0;
            visited[row * X + column] = false;
        } else {
            finished = true;
        }
    }

    /**
     * 功能：根据当前位置(Point 对象)，计算马儿还能走哪些位置(Point )，并放入到一个集合中(ArrayList), 最多
     * 有 8 个位置
     *
     * @return
     * @param curPoint
     */
    public static ArrayList<Point> next(Point curPoint) {
        // 创建一个ArrayList
        ArrayList<Point> ps = new ArrayList<Point>();
        // 创建一个Point
        Point p1 = new Point();
        // 表示马儿可以走 5 这个位置
        if ((p1.x = curPoint.x - 2) >= 0 && (p1.y = curPoint.y - 1) >= 0) {
            ps.add(new Point(p1));
        }
        // 判断马儿可以走 6 这个位置
        if ((p1.x = curPoint.x - 1) >= 0 && (p1.y = curPoint.y - 2) >= 0) {
            ps.add(new Point(p1));
        }
        // 判断马儿可以走 7 这个位置
        if ((p1.x = curPoint.x + 1) < X && (p1.y = curPoint.y - 2) >= 0) {
            ps.add(new Point(p1));
        }
        // 判断马儿可以走 0 这个位置
        if ((p1.x = curPoint.x + 2) < X && (p1.y = curPoint.y - 1) >= 0) {
            ps.add(new Point(p1));
        }
        // 判断马儿可以走 1 这个位置
        if ((p1.x = curPoint.x + 2) < X && (p1.y = curPoint.y + 1) < Y) {
            ps.add(new Point(p1));
        }
        // 判断马儿可以走 2 这个位置
        if ((p1.x = curPoint.x + 1) < X && (p1.y = curPoint.y + 2) < Y) {
            ps.add(new Point(p1));
        }
        // 判断马儿可以走 3 这个位置
        if ((p1.x = curPoint.x - 1) >= 0 && (p1.y = curPoint.y + 2) < Y) {
            ps.add(new Point(p1));
        }
        // 判断马儿可以走 4 这个位置
        if ((p1.x = curPoint.x - 2) >= 0 && (p1.y = curPoint.y + 1) < Y) {
            ps.add(new Point(p1));
        }
        return ps;
    }
}
```
